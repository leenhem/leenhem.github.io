<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《 JavaScript DOM编程艺术 （第2版） 》</title>
      <link href="/2023/10/07/JavaScript%20DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%20%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/10/07/JavaScript%20DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%20%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928154151.png" alt="《 JavaScript DOM编程艺术 （第2版） 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>JavaScript是Web开发中最重要的一门语言，它强大而优美。无论是桌面开发，还是移动应用。JavaScript都是必须掌握的技术。W3C的DOM标准是开发Web应用的基石。已经得到所有现代浏览器的支持，这使得跨平台Web开发成了一件轻松惬意的事。</p><p>本书是超级畅销书的升级版，由倡导Web标准的领军人物执笔，揭示了前端开发的真谛，是学习JavaScript和DOM开发的必读之作。</p><p>本 书在简洁明快地讲述JavaScript和DOM的基本知识之后，通过几个实例演示了专业水准的网页开发技术，透彻阐述了平稳退化等一批至关重要的 JavaScript编程原则和最佳实践，并全面探讨了HTML5以及jQuery等JavaScript库。读者将看到JavaScript、 HTML5和CSS如何协作来创建易用的、与标准兼容的Web设计，掌握使用JavaScript和DOM通过客户端动态效果和用户控制的动画来加强 Web页面的必备技术；同时，还将对如何利用库提高开发效率有全面深入的理解。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Jeremy Keith 国际知名的Web设计师，Web标准项目组成员，DOM Scripting任务组负责人之一，任职于Web咨询公司Clearleft。除本书外，还著有HTML5 for Web Designers、Bulletproof Ajax。可通过其个人网站adactio.com与他联系。</p><p>Jeffrey Sambells 资深平面设计师，Web开发人员，创办了软件公司We-Create并担任研发总监。除本书外，还著有《JavaScript高级程序设计》和 Beginning Google Maps Applications with PHP and Ajax等多部畅销书。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 JavaScript简史 1<br>1.1 JavaScript的起源 1<br>1.2 DOM 2<br>1.3 浏览器战争 3<br>1.3.1 DHTML 3<br>1.3.2 浏览器之间的冲突 3<br>1.4 制定标准 4<br>1.4.1 浏览器以外的考虑 4<br>1.4.2 浏览器战争的结局 5<br>1.4.3 崭新的起点 5<br>1.5 小结 6<br>第2章 JavaScript语法 8<br>2.1 准备工作 8<br>2.2 语法 10<br>2.2.1 语句 10<br>2.2.2 注释 10<br>2.2.3 变量 11<br>2.2.4 数据类型 14<br>2.2.5 数组 16<br>2.2.6 对象 18<br>2.3 操作 19<br>2.4 条件语句 21<br>2.4.1 比较操作符 22<br>2.4.2 逻辑操作符 23<br>2.5 循环语句 24<br>2.5.1 while循环 24<br>2.5.2 for循环 25<br>2.6 函数 26<br>2.7 对象 29<br>2.7.1 内建对象 30<br>2.7.2 宿主对象 31<br>2.8 小结 31<br>第3章 DOM 32<br>3.1 文档：DOM中的“D” 32<br>3.2 对象：DOM中的“O” 32<br>3.3 模型：DOM中的“M” 33<br>3.4 节点 35<br>3.4.1 元素节点 35<br>3.4.2 文本节点 35<br>3.4.3 属性节点 36<br>3.4.4 CSS 36<br>3.4.5 获取元素 38<br>3.4.6 盘点知识点 42<br>3.5 获取和设置属性 43<br>3.5.1 getAttribute 43<br>3.5.2 setAttribute 44<br>3.6 小结 45<br>第4章 案例研究：JavaScript图片库 46<br>4.1 标记 46<br>4.2 JavaScript 48<br>4.2.1 非DOM解决方案 49<br>4.2.2 最终的函数代码清单 50<br>4.3 应用这个JavaScript函数 50<br>4.4 对这个函数进行扩展 52<br>4.4.1 childNodes属性 53<br>4.4.2 nodeType属性 54<br>4.4.3 在标记里增加一段描述 54<br>4.4.4 用JavaScript改变这段描述 55<br>4.4.5 nodeValue属性 56<br>4.4.6 firstChild和lastChild属性 56<br>4.4.7 利用nodeValue属性刷新这段描述 57<br>4.5 小结 60<br>第5章 最佳实践 61<br>5.1 过去的错误 61<br>5.1.1 不要怪罪JavaScript 61<br>5.1.2 Flash的遭遇 62<br>5.1.3 质疑一切 63<br>5.2 平稳退化 63<br>5.2.1 “javascript:”伪协议 64<br>5.2.2 内嵌的事件处理函数 65<br>5.2.3 谁关心这个 65<br>5.3 向CSS学习 66<br>5.3.1 结构与样式的分离 66<br>5.3.2 渐进增强 67<br>5.4 分离JavaScript 68<br>5.5 向后兼容 70<br>5.5.1 对象检测 70<br>5.5.2 浏览器嗅探技术 71<br>5.6 性能考虑 72<br>5.6.1 尽量少访问DOM和尽量减少标记 72<br>5.6.2 合并和放置脚本 73<br>5.6.3 压缩脚本 73<br>5.7 小结 74<br>第6章 案例研究：图片库改进版 75<br>6.1 快速回顾 75<br>6.2 它支持平稳退化吗 76<br>6.3 它的JavaScript与HTML标记是分离的吗 77<br>6.3.1 添加事件处理函数 77<br>6.3.2 共享onload事件 82<br>6.4 不要做太多的假设 84<br>6.5 优化 86<br>6.6 键盘访问 88<br>6.7 把JavaScript与CSS结合起来 90<br>6.8 DOM Core和HTML-DOM 93<br>6.9 小结 94<br>第7章 动态创建标记 96<br>7.1 一些传统方法 96<br>7.1.1 document.write 96<br>7.1.2 innerHTML属性 98<br>7.2 DOM方法 101<br>7.2.1 createElement方法 101<br>7.2.2 appendChild方法 102<br>7.2.3 createTextNode方法 103<br>7.2.4 一个更复杂的组合 105<br>7.3 重回图片库 107<br>7.3.1 在已有元素前插入一个新元素 108<br>7.3.2 在现有方法后插入一个新元素 109<br>7.3.3 图片库二次改进版 111<br>7.4 Ajax 114<br>7.4.1 XMLHttpRequest对象 115<br>7.4.2 渐进增强与Ajax 119<br>7.4.3 Hijax 120<br>7.5 小结 121<br>第8章 充实文档的内容 122<br>8.1 不应该做什么 122<br>8.2 把“不可见”变成“可见” 123<br>8.3 内容 123<br>8.3.1 选用HTML、XHTML还是HTML5 124<br>8.3.2 CSS 126<br>8.3.3 JavaScript 127<br>8.4 显示“缩略语列表” 127<br>8.4.1 编写displayAbbreviations函数 128<br>8.4.2 创建标记 130<br>8.4.3 一个浏览器“地雷” 135<br>8.5 显示“文献来源链接表” 138<br>8.6 显示“快捷键清单” 143<br>8.7 检索和添加信息 146<br>8.8 小结 147<br>第9章 CSS-DOM 148<br>9.1 三位一体的网页 148<br>9.1.1 结构层 148<br>9.1.2 表示层 148<br>9.1.3 行为层 149<br>9.1.4 分离 150<br>9.2 style属性 150<br>9.2.1 获取样式 151<br>9.2.2 设置样式 156<br>9.3 何时该用DOM脚本设置样式 158<br>9.3.1 根据元素在节点树里的位置来设置样式 158<br>9.3.2 根据某种条件反复设置某种样式 161<br>9.3.3 响应事件 165<br>9.4 className属性 167<br>9.5 小结 171<br>第10章 用JavaScript实现动画效果 172<br>10.1 动画基础知识 172<br>10.1.1 位置 172<br>10.1.2 时间 175<br>10.1.3 时间递增量 175<br>10.1.4 抽象 178<br>10.2 实用的动画 184<br>10.2.1 提出问题 184<br>10.2.2 解决问题 186<br>10.2.3 CSS 187<br>10.2.4 JavaScript 189<br>10.2.5 变量作用域问题 192<br>10.2.6 改进动画效果 193<br>10.2.7 添加安全检查 196<br>10.2.8 生成HTML标记 198<br>10.3 小结 200<br>第11章 HTML5 201<br>11.1 HTML5简介 201<br>11.2 来自朋友的忠告 203<br>11.3 几个示例 204<br>11.3.1 Canvas 205<br>11.3.2 音频和视频 209<br>11.3.3 表单 215<br>11.4 HTML5还有其他特性吗 219<br>11.5 小结 219<br>第12章 综合示例 220<br>12.1 项目简介 220<br>12.1.1 原始资料 220<br>12.1.2 站点结构 220<br>12.1.3 页面结构 221<br>12.2 设计 222<br>12.3 CSS 223<br>12.3.1 颜色 225<br>12.3.2 布局 226<br>12.3.3 版式 228<br>12.4 标记 229<br>12.5 JavaScript 230<br>12.5.1 页面突出显示 231<br>12.5.2 JavaScript幻灯片 235<br>12.5.3 内部导航 239<br>12.5.4 JavaScript图片库 242<br>12.5.5 增强表格 245<br>12.5.6 增强表单 249<br>12.5.7 压缩代码 263<br>12.6 小结 264<br>附录 JavaScript库 265</p><h3 id="JavaScript-DOM编程艺术-（第2版）-PDF-下载地址"><a href="#JavaScript-DOM编程艺术-（第2版）-PDF-下载地址" class="headerlink" title="JavaScript DOM编程艺术 （第2版） PDF 下载地址:"></a>JavaScript DOM编程艺术 （第2版） PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/19armu_I_yZooTrr5e6fjMg?pwd=9shr">https://pan.baidu.com/s/19armu_I_yZooTrr5e6fjMg?pwd=9shr</a> </p><p>提取码: 9shr </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript从入门到精通（第2版） 》</title>
      <link href="/2023/10/07/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/10/07/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928154916.png" alt="《 JavaScript从入门到精通（第2版） 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《javaScript从入门到精通（第2版）》共分24章，包括初识JavaScript、JavaScript基础、流程控制、函数、JavaScript对象与数组、字符串与数值处理对象、正则表达式、程序调试与错误处理、事件处理、处理文档（document对象）、文档对象模型（DOM对象）、window窗口对象、级联样式表、表单和表单元素、页面打印、使用Cookie、图像处理、浏览器检测、嵌入式对象、JavaScript中的XML、JavaScript的安全、Ajax技术、jQuery技术、JavaScript Ajax jQuery网页开发等。书中的大多数知识点都结合具体实例进行介绍，涉及的程序代码给出了详细的注释，可以使读者轻松领会JavaScript语言程序开发的精髓，快速提高开发技能。</p><p>《javaScript从入门到精通（第2版）》适合作为软件开发入门者的自学用书，也适合作为高等院校相关专业的教学参考书，还可供开发人员查阅、参考。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1篇 基础知识<br>第1章 初识<br>第2章 基础<br>第3章 流程控制<br>第4章 函数<br>第5章 对象与数组<br>第6章 字符串与数值处理对象<br>第7章 正则表达式<br>第8章 程序调试与错误处理<br>第2篇 核心技术<br>第9章 事件处理<br>第10章 处理文档（document对象）<br>第11章 文档对象模型（DOM对象）<br>第12章 window窗口对象<br>第13章 级联样式表<br>第14章 表单和表单元素<br>第3篇 高级应用<br>第15章 页面打印<br>第16章 使用Cookie<br>第17章 图像处理<br>第18章 浏览器检测<br>第19章 嵌入式对象<br>第20章 中的XML<br>第21章 的安全<br>第22章 Ajax技术<br>第23章 jQuery技术<br>第4篇 项目实战<br>第24章 Ajax jQuery网页开发</p><h3 id="JavaScript从入门到精通（第2版）-PDF-下载地址"><a href="#JavaScript从入门到精通（第2版）-PDF-下载地址" class="headerlink" title="JavaScript从入门到精通（第2版） PDF 下载地址:"></a>JavaScript从入门到精通（第2版） PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1ZTQBWPx5dBkgbLgsnjLfmA?pwd=qimq">https://pan.baidu.com/s/1ZTQBWPx5dBkgbLgsnjLfmA?pwd=qimq</a> </p><p>提取码: qimq </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript入门经典(第4版) 》</title>
      <link href="/2023/10/07/JavaScript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8(%E7%AC%AC4%E7%89%88)/"/>
      <url>/2023/10/07/JavaScript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8(%E7%AC%AC4%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928162704.png" alt="《 JavaScript入门经典(第4版) 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScr1pt入门经典(第4版)》详细介绍了JavaScript编程。全书共分为24章，分别介绍了Web脚本编写和JavaScript语言的概念、JavaScript的基础知识、文档对象模型、JavaScript的高级功能、使用JavaScript创建多媒体应用程序、创建复杂脚本的技巧等知识。其中，每章内容均以前一章内容为基础。书中提供了简单直接的操作方法，读者能够从基础知识开始领会JavaScript编程的精髓。除了基本内容外，书中还提供了大量解决问题的说明、解决方案、提示信息等内容。另外在每一章的后面，还附加有实践练习、测试题和练习题，以便加深读者对基本概念的理解。</p><p>《JavaScr1pt入门经典(第4版)》适合对互联网应用开发感兴趣的初中级用户，也可作为大中专院校相关专业的教材。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>菲尔·巴拉德（Phil Ballard）是一位Web技术咨询师，他专注于Web站点的设计、搜索引擎的优化、服务器端脚本编程、客户端设计等,编有多本技术图书和在线教程。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 JavaScript 基础<br>第 1 章 JavaScript 简介<br>1.1 Web 脚本编程基础<br>1.1.1 服务器端与客户端编程<br>1.1.2 JavaScript 简介<br>1.1.3 JavaScript 起源<br>1.1.4 浏览器的竞争<br>1.1.5 <script>标签<br>1.1.6 DOM 简介<br>1.1.7 W3C 和 标准兼容<br>1.1.8 window 和 document 对象<br>1.1.9 对象表示法<br>1.1.10 与用户交互<br>1.1.11 document.write()<br>1.1.12 读取 document 对象的属性<br>1.2 小结<br>1.3 问答<br>1.4 作业<br>1.4.1 测验<br>1.4.2 答案<br>1.5 练习<br>第 2 章 创建简单的脚本<br>2.1 在 Web 页面里添加 JavaScript<br>2.2 编写 JavaScript 语句代码注释<br>2.3 变量<br>2.4 操作符<br>2.4.1 算术操作符<br>2.4.2 操作符优先级<br>2.4.3 对字符串使用操作符 “+”<br>2.5 捕获鼠标事件<br>2.5.1 onClick 事件处理器<br>2.5.2 onMouseOver 和 onMouseOut 事件处理器<br>2.6 小结<br>2.7 问答<br>2.8 作业<br>2.8.1 测验<br>2.8.2 答案<br>2.9 练习<br>第 3 章 使用函数<br>3.1 基本语法<br>3.2 调用函数<br>3.2.1 把 JavaScript 代码放置到页面的 <head> 区域<br>3.2.2 给函数传递参数<br>3.2.3 多参数<br>3.2.4 从函数返回值<br>3.2.5 匿名函数<br>3.3 小结<br>3.4 问答<br>3.5 作业<br>3.5.1 测验<br>3.5.2 答案<br>3.6 练习<br>第 4 章 函数的更多知识<br>4.1 变量作用域<br>4.1.1 使用 this 关键字<br>4.1.2 使用 let 和 const<br>4.1.3 用 const 关键字声明变量<br>4.2 箭头函数<br>4.3 设置默认参数<br>4.4 小结<br>4.5 问答<br>4.6 作业<br>4.6.1 测验<br>4.6.2 答案<br>4.7 练习<br>第 5 章 DOM 对象和 内置对象<br>5.1 与用户交互<br>5.1.1 alert()<br>5.1.3 prompt()<br>5.2 根据 id 选择元素 innerHTML 属性<br>5.3 访问浏览器历史记录<br>5.4 使用 location 对象<br>5.4.1 用 location 对象导航<br>5.4.2 刷新页面<br>5.4.3 获取浏览器信息： navigator 对象<br>5.5 日期和时间<br>5.5.1 创建具有当前日期和时间的 Date 对象<br>5.5.2 创建具有指定日期和时间的 Date 对象<br>5.5.3 设置和编辑日期与时间<br>5.5.4 利用 Math 对象简化运算<br>5.5.5 取整<br>5.5.6 获得最大值和 最小值<br>5.5.7 生成随机数<br>5.5.8 数学常数<br>5.5.9 关键字 with<br>5.6 小结<br>5.7 问答<br>5.8 作业<br>5.8.1 测验<br>5.8.2 答案<br>5.9 练习<br>第二部分 JavaScript 编程<br>第 6 章 数字和字符串<br>6.1 数值<br>6.1.1 整数<br>6.1.2 浮点数<br>6.1.3 十六进制数、二进制数和八进制数<br>6.2 全局方法<br>6.2.1 toString()<br>6.2.2 toFixed()<br>6.2.3 toExponential()<br>6.3 Number 对象<br>6.3.1 Number.isNaN()<br>6.3.2 Number.isInteger()<br>6.3.3 Number.parseFloat() 和 Number.parseInt()<br>6.3.4 无穷大<br>6.4 Number() 函数<br>6.5 布尔值<br>非操作符（！）<br>6.6 null（空）和 undefined（未定义）<br>6.7 小结<br>6.8 问答<br>6.9 作业<br>6.9.1 测验<br>6.9.2 答案<br>6.10 练习<br>第 7 章 操作字符串<br>7.1 字符串<br>7.1.1 length 属性<br>7.1.2 转义序列<br>7.1.3 字符串方法<br>7.2 模板字符串<br>7.3 小结<br>7.4 问答<br>7.5 作业<br>7.5.1 测验<br>7.5.2 答案<br>7.6 练习<br>第 8 章 数组<br>8.1 数组<br>8.1.1 创建新数组<br>8.1.2 初始化数组<br>8.1.3 数组的方法<br>8.2 如何遍历数组<br>8.2.1 使用 forEach()<br>8.2.2 使用 map()<br>8.2.3 使用 for-of 访问数组<br>8.3 三点表示法<br>8.3.1 组合多个数组<br>8.3.2 用参数的数组来调用函数<br>8.3.3 收集数据<br>8.4 小结<br>8.5 问答<br>8.6 作业<br>8.6.1 测验<br>8.6.2 答案<br>8.7 练习<br>第 9 章 用 JavaScript 处理事件<br>9.1 事件的类型<br>9.2 事件处理器<br>9.2.1 内联事件处理器<br>9.2.2 作为 DOM 对象的属性的事件处理器<br>9.2.3 使用 addEventListener()<br>9.2.4 添加多个监听器<br>9.3 event 对象<br>9.3.1 阻止默认行为<br>9.3.2 事件冒泡和捕获<br>9.3.3 关闭冒泡和捕获<br>9.4 小结<br>9.5 问答<br>9.6 作业<br>9.6.1 测验<br>9.6.2 答案<br>9.7 练习<br>第 10 章 程序控制<br>10.1 条件语句<br>10.1.1 if() 语句<br>10.1.2 比较操作符<br>10.1.3 测试相等性<br>10.1.4 if 进阶<br>10.1.5 测试多个条件<br>10.1.6 switch 语句<br>10.1.7 逻辑操作符<br>10.2 循环和控制结构<br>10.2.1 while<br>10.2.2 do...while<br>10.2.3 for<br>10.2.4 用 break 跳出循环<br>10.2.5 用 for...in 在对象集 里循环<br>10.3 设置和使用定时器<br>10.3.1 setTimeout()<br>10.3.2 setInterval()<br>10.4 小结<br>10.5 问答<br>10.6 作业<br>10.6.1 测验<br>10.6.2 答案<br>10.7 练习<br>第三部分 理解 JavaScript 对象<br>第 11 章 面向对象编程<br>11.1 什么是面向对象编程<br>11.2 创建对象<br>11.2.1 创建直接实例<br>11.2.2 使用关键字 this<br>11.2.3 匿名函数<br>11.2.4 使用构造函数<br>11.3 用 prototype 扩展和继承对象<br>11.3.1 扩展对象<br>11.3.2 继承对象<br>11.4 封装<br>11.5 小结<br>11.6 问答<br>11.7 作业<br>11.7.1 测验<br>11.7.2 答案<br>11.8 练习<br>第 12 章 对象进阶<br>12.1 类<br>12.1.1 使用 getter 和 setter<br>12.1.2 Symbol<br>12.2 对象继承<br>使用 extends 和 super<br>12.3 使用功能检测<br>12.4 小结<br>12.5 问答<br>12.6 作业<br>12.6.1 测验<br>12.6.2 答案<br>12.7 练习<br>第 13 章 DOM 脚本编程<br>13.1 DOM 节点<br>13.1.1 节点类型<br>13.1.2 使用 nodeValue<br>13.1.3 使用 nodeName<br>13.2 用 getElementsByTagName() 选择元素<br>13.3 读取元素的属性<br>13.4 Mozilla 的 DOM 查看器<br>13.4.1 创建新节点<br>13.4.2 操作子节点<br>13.4.3 编辑元素属性<br>13.4.4 动态加载 JavaScript 文件<br>13.5 小结<br>13.6 问答<br>13.7 作业<br>13.7.1 测验<br>13.7.2 答案<br>13.8 练习<br>第 14 章 JSON 简介<br>14.1 JSON 是什么<br>JSON 语法<br>14.2 访问 JSON 数据<br>14.2.2 使用直接浏览器 JSON 支持<br>14.2.3 使用 JSON.parse()<br>14.3 JSON 的数据序列化<br>使用 JSON.stringify()<br>14.4 JSON 数据类型<br>14.5 模拟关联数组<br>14.6 使用 JSON 创建对象<br>14.6.1 属性<br>14.6.2 方法<br>14.6.3 数组<br>14.6.4 对象<br>14.7 JSON 安全性<br>14.8 小结<br>14.9 问答<br>14.10 作业<br>14.10.1 测验<br>14.10.2 答案<br>14.11 练习<br>第四部分 用 JavaScript 操作 Web 界面<br>第 15 章 HTML 与 JavaScript 编程<br>15.1 HTML5 的新标签<br>15.2 一些重要的新元素<br>15.2.1 用 <video> 回放视频<br>15.2.2 用 canPlayType() 测试可用的格式<br>15.2.3 控制回放<br>15.2.4 用 <audio> 标签播放声音<br>15.2.5 用 <canvas> 在页面上 绘图<br>15.3 拖放<br>15.4 本地存储<br>15.5 操作本地文件<br>查看浏览器的支持情况<br>15.6 小结<br>15.7 问答<br>15.8 作业<br>15.8.1 测验<br>15.8.2 答案<br>15.9 练习<br>第 16 章 JavaScript 和 CSS<br>16.1 CSS 简介<br>16.1.1 从内容 分离样式<br>16.1.2 CSS 样式声明<br>16.1.3 在哪里保存样式声明<br>16.2 DOM 的 style 属性<br>16.3 用 className 访问类<br>16.4 DOM 的 styleSheets 对象<br>启用、禁用和切换样式表<br>16.5 小结<br>16.6 问答<br>16.7 作业<br>16.7.1 测验<br>16.7.2 答案<br>16.8 练习<br>第 17 章 CSS3 简介<br>17.1 特定厂商的属性和前缀<br>17.2 CSS3 边框<br>17.2.1 创建边框阴影<br>17.2.2 用 border- radius 属性实现圆角<br>17.3 CSS3 背景<br>17.3.1 background- size 属性<br>17.3.2 background- origin 属性<br>17.3.3 多背景图像<br>17.4 CSS3 渐变<br>17.4.1 线性渐变<br>17.4.2 放射渐变<br>17.5 CSS3 文本效果<br>17.5.1 文本阴影<br>17.5.2 单词换行<br>17.6 CSS3 过渡、变换和动画<br>17.7 在 JavaScript 中引用 CSS3 属性<br>17.7.1 将 CSS 属性名 转换到 JavaScript 中<br>17.7.2 DOM getComputedStyle() 方法<br>17.8 设置带有厂商前缀的 CSS3 属性<br>17.9 小结<br>17.10 问答<br>17.11 作业<br>17.11.1 测验题<br>17.11.2 答案<br>17.12 练习<br>第五部分与 JavaScript 工具相关的高级技术<br>第 18 章 读取和写入 cookie<br>18.1 什么是 cookie<br>cookie 的局限<br>18.2 使用 document.cookie 属性<br>数据的编码和解码<br>18.3 cookie 组成<br>18.4 编写 cookie<br>18.5 编写一个函数来写 cookie<br>18.6 读取 cookie<br>18.7 删除 cookie<br>18.8 在一个 cookie 里设置多个值<br>18.9 小结<br>18.10 问答<br>18.11 作业<br>18.11.1 测验<br>18.11.2 答案<br>18.12 练习<br>第 19 章用 正则表达式匹配模式<br>19.1 创建正则表达式<br>19.1.1 使用正则表达式字符串字 面值<br>19.1.2 使用 JavaScript 的 RegExp 对象<br>19.1.3 对正则 表达式使用字符串方法<br>19.2 小结<br>19.3 问答<br>19.4 作业<br>19.4.1 测验<br>19.4.2 答案<br>19.5 练习<br>第 20 章 理解并使用闭包<br>20.1 回顾作用域的相关知识<br>20.2 从一个函数返回另一个函数<br>20.3 实现闭包<br>20.3.1 传递参数<br>20.3.2 编辑一个闭包变量<br>20.3.3 闭包和对象<br>20.4 小结<br>20.5 问答<br>20.6 作业<br>20.6.1 测验<br>20.6.2 答案<br>20.7 练习<br>第 21 章 用模块组织代码<br>21.1 为何使用模块<br>21.1.1 模块使得代码更容易维护<br>21.1.2 模块帮助复用代码<br>21.1.3 模块有助于整齐的全局作用域<br>21.2 模块基础知识<br>21.2.1 如何包含一个 JavaScript 模块<br>21.2.2 nomodule 关键字<br>21.3 导出<br>21.3.1 一个简单的示例模块<br>21.3.2 如何在导出时重命名<br>21.3.3 具名的和默认的导出<br>21.4 导入<br>21.4.1 默认导入<br>21.4.2 如何在导入的过程中重命名<br>21.4.3 如何把一个模块导入为一个对象<br>21.5 小结<br>21.6 问答<br>21.7 作业<br>21.7.1 测验<br>21.7.2 答案<br>21.8 练习<br>第六部分 专业技能<br>第 22 章 良好的编程习惯<br>22.1 避免过度使用 JavaScript<br>22.2 编写易读和易维护的代码<br>22.2.1 明智地使用注释<br>22.2.2 使用适当的文件名称、属性名称和方法名称<br>22.2.3 尽量复用代码<br>22.2.4 不要假设<br>22.3 平稳退化<br>22.4 渐进增强<br>分离样式、内容和代码<br>22.5 代码分离的 JavaScript<br>22.5.1 脱离 HTML<br>22.5.2 仅把 JavaScript 作为性能增强手段<br>22.6 功能检测<br>22.7 妥善处理错误<br>使用 try 和 catch<br>22.8 小结<br>22.9 问答<br>22.10 作业<br>22.10.1 测验<br>22.10.2 答案<br>22.11 练习<br>第 23 章 调试代码<br>23.1 调试简介<br>23.1.1 错误类型<br>23.1.2 选择程序员的编辑器<br>23.1.3 用 alert() 进行简单调试<br>23.2 更高级的调试<br>23.2.1 控制台<br>23.2.2 分组消息<br>23.2.3 用断点停止代码执行<br>23.2.4 条件性断点<br>23.2.5 从代码中启动调试器<br>23.2.6 验证 JavaScript<br>23.3 小结<br>23.4 问答<br>23.5 作业<br>23.5.1 测验<br>23.5.2 答案<br>23.6 练习<br>第 24 章 继续深入学习<br>24.1 为什么要使用库<br>24.2 库能做什么<br>24.3 一些常见的库和框架<br>24.3.1 Prototype 框架<br>24.3.2 Dojo<br>24.3.3 React<br>24.3.4 Node.js<br>24.3.5 jQuery<br>24.4 jQuery 入门<br>24.4.1 在页面里引用 jQuery<br>24.4.2 jQuery 的 $(document).ready 处理器<br>24.4.3 选择页面元素<br>24.4.4 操作 HTML 内容<br>24.4.5 显示和隐藏元素<br>24.4.6 命令链<br>24.4.7 处理事件<br>24.5 The jQuery UI<br>jQuery UI 是什么<br>24.6 Ajax 简介<br>24.6.1 Ajax 入门<br>24.6.2 XMLHttpRequest 对象<br>24.6.3 创建 request 对象<br>24.6.4 方法和属性<br>24.6.5 与服务器通信<br>24.6.6 在服务器端发生了什么<br>24.6.7 处理服务器响应<br>24.6.8 还有更容易的方法，不 是吗？<br>24.7 用 jQuery 实现 Ajax<br>24.8 Node.js 简介<br>使用一种非阻塞的代码模式<br>24.9 小结<br>24.10 问答<br>24.11 作业<br>24.11.1 测验<br>24.11.2 答案<br>24.12 练习<br>附录 JavaScript 开发工具<br>编辑器<br>Notepad++<br>jEdit<br>SciTE<br>Geany<br>验证程序<br>W3C 验证服务<br>Web 设计组（WDG）<br>CodeBeautify JavaScript 验证器<br>验证和测试工具<br>JSLint<br>JSONLint<br>在线正则表达式测试器</p><h3 id="JavaScript入门经典-第4版-PDF-下载地址"><a href="#JavaScript入门经典-第4版-PDF-下载地址" class="headerlink" title="JavaScript入门经典(第4版) PDF 下载地址:"></a>JavaScript入门经典(第4版) PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1zDpe63RGl37GcH8dOMaahg?pwd=sfsj">https://pan.baidu.com/s/1zDpe63RGl37GcH8dOMaahg?pwd=sfsj</a> </p><p>提取码: sfsj </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript全程指南 》</title>
      <link href="/2023/10/07/JavaScript%E5%85%A8%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
      <url>/2023/10/07/JavaScript%E5%85%A8%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928162140.png" alt="《 JavaScript全程指南 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScript全程指南:基础知识、高级编程、特效实例、Ajax》主要是以JavaScript1.5结合Web2.0，深入浅出、循序渐进地介绍JavaScript的核心技术，同时还介绍了当前十分火热的Ajax技术。《JavaScript全程指南:基础知识、高级编程、特效实例、Ajax》分为4篇，共19章，内容涉及JavaScript的基础知识、JavaScript与浏览器的交互性、高级JavaScript技巧、XML和Web服务以及Ajax的相关技术，对网页设计中的各个方面都进行了详细介绍。</p><p>《JavaScript全程指南:基础知识、高级编程、特效实例、Ajax》适合于各个层次的人员阅读，JavaScript初学者、网页设计人员、网页开发人员，同时也可以作为高等院校相关专业的教材。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 JavaScript概述<br>1.1 HTML超文本标记<br>1.2 JavaScript语言<br>1.3 JavaScript与其他语言<br>1.4 第一个JavaScript脚本<br>1.5 小结<br>第2章 JavaScript语法基础<br>2.1 HTML和JavaScript<br>2.2 语法结构<br>2.3 JavaScript应用实例<br>2.4 小结<br>第3章 JavaScript编程基础<br>3.1 JavaScript变量<br>3.2 表达式<br>3.3 运算符<br>3.4 控制语句<br>3.5 函数<br>3.6 小结<br>第4章 JavaScript对象<br>4.1 面向对象语言的要求<br>4.2 对象应用<br>4.3 对象的废除<br>4.4 对象的类型<br>4.5 作用域<br>4.6 对象的原型和继承<br>4.7 小结<br>第5章 Window和Document对象<br>5.1 Window对象<br>5.2 窗口的属性和方法<br>5.3 Document对象<br>5.4 其他对象<br>5.5 小结<br>第6章 DOM（文档对象模型）<br>6.1 XML和DOM<br>6.2 高级DOM技术<br>6.3 小结<br>第7章 事件<br>7.1 事件流<br>7.2 事件处理函数&#x2F;监听函数<br>7.3 小结<br>第8章 JavaScript和XML<br>8.1 IE中的XML DOM支持<br>8.2 XPath支持<br>8.3 XSLT支持<br>8.4 小结<br>第9章 客户端和服务器端的通信<br>9.1 Cookie<br>9.2 HTTP请求<br>9.3 隐藏框架<br>9.4 小结<br>第10章 表单和表单元素<br>10.1 表单基础<br>10.2 form对象<br>10.3 表单按钮<br>10.4 文本框<br>10.5 列表框和组合框<br>10.6 创建自动提示文本框<br>10.7 小结<br>第11章 鼠标事件和文字特效<br>11.1 鼠标事件特效<br>11.2 文字特效<br>11.3 小结<br>第12章 图像处理<br>12.1 图片特效<br>12.2 模拟flash<br>12.3 小结<br>第13章 时间日期特效<br>13.1 文本样式显示<br>13.2 其他样式的时钟<br>13.3 小结<br>第14章 页面技巧和特效<br>14.1 页面技巧<br>14.2 页面特效<br>14.3 小结<br>第15章 导航菜单<br>15.1 下拉菜单<br>15.2 树型菜单<br>15.3 其他类型菜单<br>15.4 小结<br>第16章 其他特效实例<br>16.1 常用实例<br>16.2 游戏和测试<br>16.3 小结<br>第17章 Ajax技术基础<br>17.1 Ajax简介<br>17.2 Ajax的应用<br>17.3 传统的Web开发模式<br>17.4 基于Ajax的开发模式<br>17.5 Ajax的相关技术<br>17.6 小结<br>第18章 Ajax的工作流程<br>18.1 方法概述<br>18.2 XMLHttpRequest对象<br>18.3 发送请求<br>18.4 处理响应<br>18.5 基于Ajax的注册程序<br>18.6 基于Ajax的应用程序架构<br>18.7 小结<br>第19章 Ajax实例<br>19.1 等待提示<br>19.2 级联菜单<br>19.3 实现搜索提示<br>19.4 基于Ajax的分页<br>19.5 类似于Google的拖拽功能<br>19.6 浮动提示标签<br>19.7 文本操作全选框<br>19.8 基于Ajax的动态树型结构<br>19.9 小结</p><h3 id="JavaScript全程指南-PDF-下载地址"><a href="#JavaScript全程指南-PDF-下载地址" class="headerlink" title="JavaScript全程指南 PDF 下载地址:"></a>JavaScript全程指南 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1wpFTEeTYCPHDLOcI6yLvFw?pwd=d3jw">https://pan.baidu.com/s/1wpFTEeTYCPHDLOcI6yLvFw?pwd=d3jw</a> </p><p>提取码: d3jw </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript凌厉开发-ExtJS3详解与实践 》</title>
      <link href="/2023/10/07/JavaScript%E5%87%8C%E5%8E%89%E5%BC%80%E5%8F%91-ExtJS3%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/10/07/JavaScript%E5%87%8C%E5%8E%89%E5%BC%80%E5%8F%91-ExtJS3%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928160411.png" alt="《 JavaScript凌厉开发-ExtJS3详解与实践 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书详细介绍Ext JS框架体系结构，以及利用HTML&#x2F;CSS&#x2F;JavaScript进行前端设计的方法和技巧。作者为Ext中文站站长领衔的三个国内Ext JS先锋，在开发思维和开发经验上有着无可争议的功力。</p><p>本书包含的内容有Ext.Element.*、事件Observable、Ext组件+MVC原理、Grid&#x2F;Form&#x2F;Tree&#x2F;ComboBox、Ajax缓存Store等，并照顾JavaScript新手，穿插部分JavaScript基础知识。</p><p>本书附带的实例丰富，包括散布各知识点的单独可运行实例、大型UI控件、ASP.NET新闻发布器、Java DWR整合方案、最新通信协议Ext.Direct、Ajax仿资源管理器等。</p><p>本书附带光盘中的教学视频时长270分钟，包括从零开始学Ext、如何用Firebug调试、ext-base.js源码级讲解、实例操作演示和源码评点、可视化IDE编程、优化工具的使用等。并附带完整的Ext 3.1中文文档。</p><p>本书适合广大的Web开发人员阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>张鑫 JavaScript开源社区JS堂（jstang.cn）站长，Ext中文站（<a href="http://www.ajaxjs.com)站长,ext/">www.ajaxjs.com）站长，EXT</a> JS原作者JACK的中文博客参与维护人。热衷于Web前端开发，在Ajax和Web UI领域功力深厚，国内最早应用EXT JS进行实际项目开发的程序员，EXT热血高手，通过社区、博客、翻译文档等途径不遗余力的推广EXT JS。曾与友人合作编写过《AIR完整入门与开发实录》Ajax AIR的部分。</p><p>杨彦强，任职于方正集团，系统架构师，负责公司富客户端技术(包括Ext、OpenLaszlo、Flex)的调研与培训工作。多年来专注于行业软件开发、架构设计。擅长面向对象的分析设计、Java EE架构和Unix／Linux平台的编程技术。一直关注开源事业，并致力于富客户端技术的研究，基于Ext JS框架已开发多个大型商业项目，具有精湛的Ext JS框架开发功力</p><p>黄灯桥，2002年起致力于Web开发与应用研究，开源框架发烧友，活跃于各大开源社区，目前醉心于Ajax框架Ext的推广与研究工作，基于Ext开发的很多先锋教程广泛转载于各大技术社区，个人博客blog．csdn．net／tianxiaode深受广大技术爱好者推崇。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 开篇 1</p><p>1.1 网络开发浪潮 2</p><p>1.2 基于JavaScript的RIA开发观念 3</p><p>1.3 风靡世界的Ext 3</p><p>第2章 Ext起步 7</p><p>2.1 获取Ext的方法 8</p><p>2.2 Ext运行环境 8</p><p>2.3 如何兼容其他JavaScript库 9</p><p>2.4 如何学好Ext框架 11</p><p>第3章 Ext基础 13</p><p>3.1 构成界面的元素 14</p><p>3.1.1 获取页面元素 14</p><p>3.1.2 Ext.get()&#x2F;Ext.fly()区别 16</p><p>3.1.3 获取周边元素 17</p><p>3.1.4 元素的增&#x2F;删&#x2F;改&#x2F;查 18</p><p>3.2 元素的高级查询 22</p><p>3.2.1 DomQuery详解 22</p><p>3.2.2 Composite元素集合 25</p><p>3.2.3 CSS选择符详解 27</p><p>3.2.4 ID&#x2F;Class拾遗 30</p><p>.3.3 控制元素 30</p><p>3.3.1 页面显示方法 30</p><p>3.3.2 动画Fx集锦 32</p><p>3.3.3 元素小结 33</p><p>3.4 应用模板 34</p><p>3.4.1 Ext.Template 35</p><p>3.4.2 Ext.XTemplate 37</p><p>3.5 例子：制作一个对话框 39</p><p>3.5.1 afterRender事件 41</p><p>3.5.2 继承用法 43</p><p>第4章 Ext事件 45</p><p>4.1 浏览器事件浅析 46</p><p>4.1.1 内联式登记(inline) 46</p><p>4.1.2 传统式登记 47</p><p>4.1.3 IE式登记 47</p><p>4.1.4 DOM Level 2式登记 48</p><p>4.1.5 事件对象 50</p><p>4.2 事件与函数 50</p><p>4.2.1 变量的声明 50</p><p>4.2.2 嵌套的函数 51</p><p>4.2.3 Function.call()&#x2F;apply() 52</p><p>4.2.4 深入Event Handler 54</p><p>4.2.5 Ext的事件 59</p><p>4.3 高级事件及其控制 62</p><p>4.3.1 基础事件与高级组件事件 62</p><p>4.3.2 高级组件事件详解 64</p><p>4.3.3 键盘上的按键事件 69</p><p>4.4 例子：制作一个小Widget 71</p><p>4.4.1 定义UI&#x2F;CSS 72</p><p>4.4.2 继承Observable(重点) 74</p><p>4.4.3 配置项参数 76</p><p>第5章 创建图形界面 79</p><p>5.1 界面架构及原理 80</p><p>5.1.1 组件的生存周期 81</p><p>5.1.2 模板方法简介 87</p><p>5.1.3 对象模型之Component 92</p><p>5.1.4 对象模型之Container 92</p><p>5.1.5 对象模型之Panel 93</p><p>5.1.6 对象模型之Viewport 94</p><p>5.1.7 小结 95</p><p>5.2 组件的高级应用 95</p><p>5.2.1 组件的延时渲染 95</p><p>5.2.2 组件管理器 96</p><p>5.2.3 避免相同id的冲突 97</p><p>5.2.4 组件之间的通信 98</p><p>5.2.5 关于插件的应用 100</p><p>5.3 容器的布局 101</p><p>5.3.1 布局简介 101</p><p>5.3.2 使用AnchorLayout 104</p><p>5.3.3 使用FormLayout 106</p><p>5.3.4 使用ColumnLayout 107</p><p>5.3.5 调试ColumnLayout 113</p><p>5.4 拖放操作 115</p><p>5.4.1 入门：一个小游戏 115</p><p>5.4.2 简单的拖放 116</p><p>5.4.3 自定义拖放详解 118</p><p>5.4.4 群体式拖放模式 119</p><p>第6章 展示数据 123</p><p>6.1 如何产生组件读取的数据 124</p><p>6.1.1 org.json(Struts篇) 124</p><p>6.1.2 LitJSON(.NET篇) 128</p><p>6.2 表格组件Grid 135</p><p>6.2.1 Grid入门 135</p><p>6.2.2 Store结构 144</p><p>6.2.3 分页、查询、排序 149</p><p>6.2.4 列模型与单元格 155</p><p>6.2.5 多层表头 161</p><p>6.2.6 使用拖放行为 163</p><p>6.2.7 PropertyGrid扩展简介 169</p><p>6.2.8 使用DataView组件 171</p><p>6.3 表单组件Form 179</p><p>6.3.1 表单提交 179</p><p>6.3.2 表单验证及其控制 186</p><p>6.3.3 表单&#x2F;数据绑定 193</p><p>6.3.4　插件&#x2F;扩展两则 196</p><p>6.3.5 集成TinyMCE Editor</p><p>编辑器 198</p><p>6.4 列表组件ComboBox 201</p><p>6.4.1 基本使用方法 201</p><p>6.4.2 调整Combobox内的元素 206</p><p>6.4.3 实现Combobox的联动 211</p><p>6.4.4 TreeComboBox简介 214</p><p>6.5 树状组件Tree 216</p><p>6.5.1 Tree入门 216</p><p>6.5.2 如何定义数据源 221</p><p>6.5.3 改变节点图标 224</p><p>6.5.4 Tree的拖放 226</p><p>6.5.5 调试动态树 229</p><p>第7章 数据驱动 237</p><p>7.1 XML&#x2F;JSON数据格式比较 238</p><p>7.2 容器类MixedCollection 239</p><p>7.2.1 构造器以及属性 240</p><p>7.2.2 集合存储操作方法(一) 241</p><p>7.2.3 集合存储操作方法(二) 245</p><p>7.2.4 集合查询遍历方法 246</p><p>7.3 数据存储基本单元Record与</p><p>DataField 248</p><p>7.3.1 准备基础数据 248</p><p>7.3.2 DataField详解 250</p><p>7.3.3 Record详解(一) 250</p><p>7.3.4 Record详解(二) 252</p><p>7.4 数据存储Store 255</p><p>7.4.1 数据的载入 255</p><p>7.4.2 远程数据的载入 259</p><p>7.4.3 数据的添加 263</p><p>7.4.4 取得记录信息 269</p><p>7.4.5 排序 273</p><p>7.4.6 事务模式 274</p><p>7.4.7 查找 276</p><p>7.5 数据代理DataProxy 277</p><p>7.5.1 Ext.data.DataProxy 277</p><p>7.5.2 Ext.data.MemoryProxy 278</p><p>7.5.3 Ext.data.HttpProxy 279</p><p>7.5.4 Ext.data.ScriptTagProxy 280</p><p>7.6 数据读取器DataReader 282</p><p>7.6.1 Ext.data.DataReader 282</p><p>7.6.2 Ext.data.ArrayReader 282</p><p>7.6.3 Ext.data.JsonReader 284</p><p>7.6.4 Ext.data.XmlReader 286</p><p>7.7 Ext.ux.DWR + Spring 287</p><p>7.7.1 DwrProxy&#x2F;DwrReader 288</p><p>7.7.2 整合Spring的例子 289</p><p>7.7.3 Web服务端配置 289</p><p>7.7.4 服务层接口 291</p><p>7.8 RESTful的支持 293</p><p>7.9 Ext.Direct 293</p><p>7.9.1 通迅新方式：Ext.Direct 293</p><p>7.9.2 配置器 294</p><p>7.9.3 API供应器 296</p><p>7.9.4 路由器 298</p><p>7.9.5 例子 300</p><p>7.9.6 小结 301</p><p>第8章 JavaScript高级应用 303</p><p>8.1 JavaScript闭包详解 304</p><p>8.1.1 闭包的概念 304</p><p>8.1.2 闭包成员的生命周期 305</p><p>8.1.3 引用而不是复制 306</p><p>8.1.4 闭包应用场景 307</p><p>8.2 JavaScript的继承 308</p><p>8.2.1 大杂烩JavaScript 308</p><p>8.2.2 定义类别 309</p><p>8.2.3 加入方法 310</p><p>8.2.4 基于类的继承 311</p><p>8.3 修改页面皮肤 315</p><p>8.3.1 从Ext.BLANK_IMAGE_URL</p><p>说起 315</p><p>8.3.2 实时换肤功能 317</p><p>8.3.3 样式精粹：CSS Sprites 318</p><p>8.3.4 九宫格方位与baseCls 320</p><p>8.4 处理i18n 322</p><p>8.4.1 国际化与本地化 322</p><p>8.4.2 多语言的Ext 323</p><p>第9章 大型UI控件 327</p><p>9.1 Edk简介 328</p><p>9.1.1 项目起步 328</p><p>9.1.2 顶层源码概览 331</p><p>9.1.3 数据通信机制Ext.Direct 333</p><p>9.2 如何复用Ext组件 338</p><p>9.2.1 “1+2”之一 339</p><p>9.2.2 “1+2”之二 341</p><p>9.2.3 “1+2”之三 343</p><p>9.2.4 小结 347</p><p>9.3 Edk.grid.* 348</p><p>9.3.1 浅谈行为模式 348</p><p>9.3.2 如何分配Action 349</p><p>9.3.3 如何扩展该模式 351</p><p>9.4 Edk. tree.* 351</p><p>9.4.1 如何设计分类的Tree 351</p><p>9.4.2 如何添加特定的节点 353</p><p>9.4.3 如何使得TreeNode可编辑 354</p><p>9.5 Edk.formPanel.* 354</p><p>9.6 Edk.attachment.* 356</p><p>第10章 新闻管理系统 359</p><p>10.1 简介 360</p><p>10.1.1 项目需求 360</p><p>10.1.2 面向.NET的架构 360</p><p>10.1.3 系统需要使用的资源 360</p><p>10.1.4 准备数据库表 361</p><p>10.1.5 设置配置文件 363</p><p>10.2 页面实作 365</p><p>10.2.1 登录页(index.html) 365</p><p>10.2.2 主页面(index.aspx) 370</p><p>10.2.3 用户管理页面(users.aspx) 372</p><p>10.2.4 新闻管理页面(news.aspx) 379</p><p>10.2.5 剩余的服务端任务 390</p><h3 id="JavaScript凌厉开发-ExtJS3详解与实践-PDF-下载地址"><a href="#JavaScript凌厉开发-ExtJS3详解与实践-PDF-下载地址" class="headerlink" title="JavaScript凌厉开发-ExtJS3详解与实践 PDF 下载地址:"></a>JavaScript凌厉开发-ExtJS3详解与实践 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1CGhj8X9_aAJEBCE9GAuLuQ?pwd=5ewr">https://pan.baidu.com/s/1CGhj8X9_aAJEBCE9GAuLuQ?pwd=5ewr</a> </p><p>提取码: 5ewr </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript完全手册 》</title>
      <link href="/2023/10/07/JavaScript%E5%AE%8C%E5%85%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2023/10/07/JavaScript%E5%AE%8C%E5%85%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928163748.png" alt="《 JavaScript完全手册 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书全面而详细地介绍了JavaScript的基本概念、编程技巧和属性参考说明。使用本书，读者可以使用JavaScript创建动态、灵活的Web 页。不管是一位编程新手还是一位有经验的开发员，都可以找到自己要找的内容，从基础知识（比如语法）到高级知识（包括使用浏览插件进行交互、W3CDOM标准等）。使用本书，读者可以学会创建跨浏览器的脚本，包括表单确认、可视化效果、导航系统等。附录部分提供了可以快速</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>鲍威尔（Thomas A.Powell），美国加州大学圣地亚哥分校讲师，著H TML&amp;CSS：The Complete Reference和Web Design: The Complete Reference等多本书籍。Thomas是 Web开发代理PINT的创建者，也是ZingChart JavaScript图表库的设计者。 施奈德（Fritz Schneider），Google软件工程师，曾负责管理 社交搜索服务Aardvark以及组建Google的Firefox和安全浏览团队。Fritz参与撰写了How to Do Everything with Google一书。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 JavaScript介绍<br>第2章 JavaScript核心语言<br>第3章 数据类型与变量<br>第4章 运算符、表达式和语句<br>第5章 函数<br>第6章 对象<br>第7章 数组、日期、数学对象以及与类型相关的对象<br>第8章 正则表达式<br>第9章 JavaScript对象模型<br>第10章 标准文档对象模型<br>第11章 事件处理<br>第12章 窗口、框架和重叠<br>第13章 表单处理<br>第14章 用户界面元素<br>第15章 Ajax和远程JavaScript<br>第16章 浏览器管理<br>第17章 媒体管理<br>第18章 实践与发展趋势</p><h3 id="JavaScript完全手册-PDF-下载地址"><a href="#JavaScript完全手册-PDF-下载地址" class="headerlink" title="JavaScript完全手册 PDF 下载地址:"></a>JavaScript完全手册 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1_7WnhueMljB_K1iyVmDWzw?pwd=ewpf">https://pan.baidu.com/s/1_7WnhueMljB_K1iyVmDWzw?pwd=ewpf</a> </p><p>提取码: ewpf </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript实例自学手册-通过486个例子掌握Web开发捷径 》</title>
      <link href="/2023/10/07/JavaScript%E5%AE%9E%E4%BE%8B%E8%87%AA%E5%AD%A6%E6%89%8B%E5%86%8C-%E9%80%9A%E8%BF%87486%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%8E%8C%E6%8F%A1Web%E5%BC%80%E5%8F%91%E6%8D%B7%E5%BE%84/"/>
      <url>/2023/10/07/JavaScript%E5%AE%9E%E4%BE%8B%E8%87%AA%E5%AD%A6%E6%89%8B%E5%86%8C-%E9%80%9A%E8%BF%87486%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%8E%8C%E6%8F%A1Web%E5%BC%80%E5%8F%91%E6%8D%B7%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928163103.png" alt="《 JavaScript实例自学手册-通过486个例子掌握Web开发捷径 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书适用于初、中级Web开发人员，也是高级开发人员的查询宝典。对于JavaScript入门级读者来说，学习这些实例，可以更快地提高JavaScript的开发水平。对于中级Web开发人员而言，掌握这些实例后，可以开发出更加安全、快速、完善的Web2.0网站。<br>本书提供了Web2.0时代所必须掌握的一些技巧实例，是一本学习网络开发技术的随身手册。<br>本书涵盖了网络开发涉及的所有方向，从页面、文本、窗口、鼠标、日期时间等基本应用，到图像、滚动条、进度条、网络验证、文件处理等深入应用，包括最流行的异步传输、Property框架、Ajax和DOM等高级技术。全书共分23章，包括486个常用JavaScript实例。每个实例都提供了代码分析及效果演示，可以帮助读者轻松掌握JavaScript的开发技巧，并从中找到网站开发的乐趣。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>笔者经过多年的网络开发经验，精心挑选了500个常用的JavaScript案例。这些案例从基础到应用，从老版本的页面交互，到最新流行的AJAX，处处体现了JavaScript在网络开发方面的必要性。<br>本书所有的案例都提供实例描述和代码详解，并演示了这些实例的运行效果。读者通过学习这些实例，可以掌握JavaScript开发的技巧，也可以学习到网络客户端快速响应的方法，提高网站与用户之间的交互，掌握Web 2.0时代的关键技术。<br>本书在介绍JavaScript的时候，并没有局限于一些基本的对象和理论知识，而是从实际应用入手，介绍JavaScript在Web开发中必需的知识和技巧。不管网站后台使用的什么开发语言（PHP、ASP、ASP.NET、JAVA等），都必须掌握客户端的JavaScript开发语言，因为用其可以大大提高网站的交互能力，提高页面的响应速度。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 页面特效. 1<br>第2章 按钮特效 22<br>第3章 字符串文本和输入框特效 41<br>第4章 鼠标特效 103<br>第5章 层和框架的特效 128<br>第6章 下拉列表特效 144<br>第7章 键盘操作和状态栏特效 162<br>第8章 链接特效 178<br>第9章 表格特效 195<br>第10章 单选按钮和复选框 248<br>第11章 颜色处理和菜单特效 269<br>第12章 窗口特效与弹出式警告 306<br>第13章 日期和时间特效 328<br>第14章 数字、数组和统计函数特效 380<br>第15章 图片的特效 412<br>第16章 页面数据的验证 464<br>第17章 进度条、滚动条的特效处理 482<br>第18章 在线考题案例 503<br>第19章 文件处理和打印的技巧 513<br>第20章 调用操作系统的应用 540<br>第21章 流行技术dom和userdata的应用技巧 560<br>第22章 流行应用：ajax和property的技巧 575<br>第23章 其他技巧及特效 599</p><h3 id="JavaScript实例自学手册-通过486个例子掌握Web开发捷径-PDF-下载地址"><a href="#JavaScript实例自学手册-通过486个例子掌握Web开发捷径-PDF-下载地址" class="headerlink" title="JavaScript实例自学手册-通过486个例子掌握Web开发捷径 PDF 下载地址:"></a>JavaScript实例自学手册-通过486个例子掌握Web开发捷径 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1VI4LV57mAt1Q7fg2ZaRIxw?pwd=y4ag">https://pan.baidu.com/s/1VI4LV57mAt1Q7fg2ZaRIxw?pwd=y4ag</a> </p><p>提取码: y4ag </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript实战手册 》</title>
      <link href="/2023/10/07/JavaScript%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/"/>
      <url>/2023/10/07/JavaScript%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928163344.png" alt="《 JavaScript实战手册 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>在《JavaScript实战手册》中，畅销书作者David McFarland教你如何以高级的方式使用JavaScript，即便你只有很少或者没有编程经验。一旦掌握了这种语言的结构和术语，你将学习如何使用高级的JavaScript工具来快速为站点添加有用的交互，而不是一切从头开始编写脚本。和其他的Missing Manuals图书不同，《JavaScript实战手册》清楚、精炼，手把手地讲解。</p><p>现代Web站点需要发布的东西远不仅仅是文本。访问者期待智能化的表单、导航标签页、弹出式帮助屏幕，以及交互式的照片集。《JavaScript实战手册》介绍用漂亮的样式发布这些元素所需的所有JavaScript知识，即便你不是程序设计高手，也可以轻松地阅读和学习《JavaScript实战手册》。</p><p>《JavaScript实战手册》中的重要内容包括：</p><p>直接从构建结构良好的JavaScript程序开始，这些程序操作HTML和CSS Web页面。</p><p>定制代码——《JavaScript实战手册》按部就班的教程允许只添加Web页面需要的功能。</p><p>通过学习《JavaScript实战手册》中的生动在线示例，你可以开发自己的Web站点的解决方案。</p><p>避免常见的错误，明确在此过程中怎么做。</p><p>通过jQurey库预先编写好的大量代码来节约时间和精力。</p><p>使用简单的Ajax编程，集成来自Web服务器或Google Maps的数据。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>David Sawyer McFarland是Sawyer McFarland Media公司的总裁，这是位于Oregon的Portland的一家Web开发和培训公司。他从1995年开始开发Web站点，那时候他设计了自己的第一个Web站点，这是通信专业的一个在线杂志。他曾经是位于伯克利的加利福尼亚大学和伯克利多媒体研究中心的网站管理员，并且负责Macworld.com的一次完全的CSS驱动的重新设计。</p><p>除了构建Web站点，David也是一名作家、培训讲师和老师。他在加利福尼亚大学伯克利新闻研究所、电子艺术中心、艺术大学研究院、新媒体非印刷中心，以及波兰国家大学教授Web设计。他为Practical Web Design、MX Developer’s Journal、Macworld杂志和CreativePro.com撰写关于Web设计的文章。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>目录<br>The Missing Credits…………………………………………1<br>前言……………………………………………………………… 5<br>第一部分：JavaScript 入门<br>第1章 编写第一个JavaScript 程序……………………… 23<br>1.1 编程简介…………………………………………………………………………………..24<br>1.2 如何把JavaScript 添加到页面……………………………………………………….27<br>1.3 第一个JavaScript 程序…………………………………………………………………31<br>1.4 把文本写到Web 页面上……………………………………………………………….34<br>1.5附加外部JavaScript 文件……………………………………………………………..35<br>1.6追踪错误…………………………………………………………………………………..37<br>第2章 JavaScript 的语法…………………………………. 42<br>2.1 语句…………………………………………………………………………………………42<br>2.2 内置函数…………………………………………………………………………………..43<br>2.3 数据类型…………………………………………………………………………………..43<br>2.4 变量…………………………………………………………………………………………46<br>2.5 操作数据类型和变量………………………………………………………………….51<br>2.6 教程：使用变量创建消息……………………………………………………………56<br>2.7 教程：请求信息………………………………………………………………………..58<br>2.8 数组…………………………………………………………………………………………60<br>2.9 教程：编写使用数组的页面………………………………………………………..68<br>2.10 对象的简单介绍……………………………………………………………………….71<br>2.11 注释……………………………………………………………………………………….73<br>第3章 为程序添加逻辑和控制…………………………… 77<br>2.1 使程序智能地响应……………………………………………………………………..77<br>2.2 教程：使用条件语句………………………………………………………………….89<br>2.3 使用循环处理重复性任务……………………………………………………………93<br>2.4 函数：把有用的代码转换为可复用的命令………………………………….100<br>2.5 教程：一个简单测验………………………………………………………………..109<br>第二部分：jQuery 入门<br>第4章 jQuery 简介………………………………………… 117<br>4.1 JavaScript 库简介……………………………………………………………………..117<br>4.2 获取jQuery ……………………………………………………………………………..119<br>4.3 把jQuery 添加到页面…………………………………………………………………121<br>4.4 修改Web 页面：概览…………………………………………………………………124<br>4.5 理解文档对象模型……………………………………………………………………127<br>4.6 再谈选择页面元素……………………………………………………………………128<br>4.7 向页面添加内容………………………………………………………………………138<br>4.8 设置和读取标签属性………………………………………………………………..141<br>4.9 读取、设置和删除HTML 属性……………………………………………………147<br>4.10 操作选择中的每个元素…………………………………………………………..148<br>4.11 自动提取引用………………………………………………………………………..151<br>第5章 动作&#x2F;响应：让页面通过事件动起来…………. 157<br>5.1 事件……………………………………………………………………………………….157<br>5.2 以jQuery 的方式使用事件………………………………………………………….162<br>5.3 教程：事件简介………………………………………………………………………164<br>5.4 更多的jQuery 事件概念……………………………………………………………..169<br>5.5 高级事件管理………………………………………………………………………….176<br>5.6 教程：一页的FAQ ……………………………………………………………………179<br>第6章 动画和效果………………………………………… 184<br>6.1 jQuery 效果……………………………………………………………………………..184<br>6.2 教程：登录滑块………………………………………………………………………189<br>6.3 动画……………………………………………………………………………………….191<br>6.4 在效果完成后执行一个操作………………………………………………………195<br>6.5 教程：动画的仪表盘………………………………………………………………..198<br>第三部分：构建网页功能<br>第7章 改进图像…………………………………………… 207<br>7.1 交换图像…………………………………………………………………………………207<br>7.2 教程：添加翻滚图像………………………………………………………………..212<br>7.3 教程：带有效果的照片集………………………………………………………….216<br>7.4 使用jQuery lightBox 的高级照片集……………………………………………..222<br>7.5 教程：FancyBox 照片集…………………………………………………………….231<br>第8章 改进导航…………………………………………… 235<br>8.1 一些链接基础知识……………………………………………………………………235<br>8.2 在新窗口中打开外部链接………………………………………………………….238<br>8.3 创建新窗口……………………………………………………………………………..241<br>8.4 在页面上的一个窗口中打开页面……………………………………………….245<br>8.5 基本的动画的导航栏………………………………………………………………..249<br>第9章 扩展Web 表单…………………………………….. 257<br>9.1 理解表单…………………………………………………………………………………257<br>9.2 为表单添加智能………………………………………………………………………268<br>9.3 教程：基本表单扩展………………………………………………………………..272<br>9.4 表单验证…………………………………………………………………………………278<br>9.5 验证教程…………………………………………………………………………………291<br>第10 章 扩展界面…………………………………………. 302<br>10.1 把信息组织到标签页面板………………………………………………………..302<br>10.2 为站点添加一个内容幻灯片…………………………………………………….313<br>10.3 确定页面元素的大小和位置…………………………………………………….320<br>10.4 添加工具提示………………………………………………………………………..327<br>第四部分：Ajax 与Web 服务器通信<br>第11 章 初识Ajax………………………………………….. 343<br>11.1 Ajax………………………………………………………………………………………344<br>11.2 Ajax 基础知识…………………………………………………………………………345<br>11.3 Ajax 的jQuery 方式…………………………………………………………………..351<br>11.4 JSON…………………………………………………………………………………….373<br>第12 章 Flickr 和Google Maps…………………………. 380<br>12.1 JSONP 简介……………………………………………………………………………380<br>12.2 给站点添加一个Flickr Feed ……………………………………………………..381<br>12.3 教程：给站点添加Flickr 图像…………………………………………………..386<br>12.4 向站点添加Google 地图…………………………………………………………..390<br>第五部分：提示、技巧和除错<br>第13 章 让jQuery 发挥最大的作用…………………….. 407<br>13.1 有用的jQuery 提示和信息………………………………………………………..407<br>13.2 使用jQuery 文档……………………………………………………………………..411<br>13.3 遍历DOM ……………………………………………………………………………..417<br>13.4 用于操作HTML 的更多函数…………………………………………………….421<br>13.5 高级事件处理………………………………………………………………………..425<br>第14 章 深入JavaScript …………………………………. 428<br>14.1 操作字符串……………………………………………………………………………428<br>14.2 在字符串中查找模式………………………………………………………………433<br>14.3 操作数字……………………………………………………………………………….447<br>14.4 日期和时间……………………………………………………………………………453<br>14.5 综合应用……………………………………………………………………………….459<br>14.6 编写更高效的JavaScript ………………………………………………………….462<br>14.7 创建快速载入的JavaScript……………………………………………………….468<br>第15 章 除错和调试………………………………………. 470<br>15.1 常见JavaScript 编程错误………………………………………………………….470<br>15.2 使用Firebug 调试…………………………………………………………………….481<br>15.3 调试教程……………………………………………………………………………….492<br>附录 JavaScript 资源…………………………………….. 499</p><h3 id="JavaScript实战手册-PDF-下载地址"><a href="#JavaScript实战手册-PDF-下载地址" class="headerlink" title="JavaScript实战手册 PDF 下载地址:"></a>JavaScript实战手册 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/16Sd0WxRwzzSmKanJSovRiQ?pwd=3k2a">https://pan.baidu.com/s/16Sd0WxRwzzSmKanJSovRiQ?pwd=3k2a</a> </p><p>提取码: 3k2a </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript快速开发工具箱 》</title>
      <link href="/2023/10/07/JavaScript%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
      <url>/2023/10/07/JavaScript%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928155531.png" alt="《 JavaScript快速开发工具箱 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScript快速开发工具箱:轻松解决JavaScript日常编程问题的100个插件工具》通透讲解100个现成的JavaScript插件，引导您使用这些利器得心应手地创建动态Web内容。《JavaScript快速开发工具箱:轻松解决JavaScript日常编程问题的100个插件工具》开篇讲解JavaScript、CSS和DOM，此后每章都列举一个完整示例，指导您将特定效果快速应用于网页。使用这些插件，您只需调用一个函数就能完成诸多复杂任务，从而收到事半功倍的神奇效果。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 充分利用插件 1<br>1.1 下载并安装Web浏览器 1<br>1.2 选择程序编辑器 2<br>1.3 管理Ajax 3<br>1.4 早期版本的Microsoft Internet<br>Explorer 5<br>1.5 配套网站 7<br>1.6 包含全部插件 8<br>1.7 包含单个插件 9<br>1.8 包含JavaScript文件的位置 9<br>1.9 优选代码部分 9<br>1.10 错误修正和报告 10<br>1.11 等待网页加载完毕 10<br>1.12 小结 11<br>第2章 JavaScript、CSS和DOM 13<br>2.1 文档对象模型 14<br>2.2 级联样式表 16<br>2.3 在JavaScript中访问样式 18<br>2.4 JavaScript与分号 20<br>2.5 小结 20<br>第3章 核心插件 21<br>3.1 插件1：O() 21<br>3.1.1 关于此插件 21<br>3.1.2 变量、数组和函数 22<br>3.1.3 工作原理 22<br>3.1.4 使用方法 27<br>3.1.5 插件代码 28<br>3.2 插件2：S() 28<br>3.2.1 关于此插件 29<br>3.2.2 变量、数组和函数 29<br>3.2.3 工作原理 30<br>3.2.4 使用方法 31<br>3.2.5 插件代码 32<br>3.3 插件3：Initialize() 32<br>3.3.1 关于此插件 33<br>3.3.2 变量、数组和函数 33<br>3.3.3 工作原理 33<br>3.3.4 使用方法 35<br>3.3.5 插件代码 36<br>3.4 插件4：CaptureMouse() 37<br>3.4.1 关于此插件 37<br>3.4.2 变量、数组和函数 37<br>3.4.3 工作原理 38<br>3.4.4 使用方法 38<br>3.4.5 插件代码 39<br>3.5 插件5：CaptureKeyboard() 40<br>3.5.1 关于此插件 40<br>3.5.2 变量、数组和函数 40<br>3.5.3 工作原理 40<br>3.5.4 使用方法 41<br>3.5.5 插件代码 42<br>3.6 插件6：FromKeyCode() 42<br>3.6.1 关于此插件 42<br>3.6.2 变量、数组和函数 43<br>3.6.3 工作原理 43<br>3.6.4 使用方法 43<br>3.6.5 插件代码 43<br>3.7 插件7：GetLastKey() 44<br>3.7.1 关于此插件 44<br>3.7.2 变量、数组和函数 45<br>3.7.3 工作原理 45<br>3.7.4 使用方法 45<br>3.7.5 插件代码 46<br>3.8 插件8：PreventAction() 46<br>3.8.1 关于此插件 47<br>3.8.2 变量、数组和函数 47<br>3.8.3 工作原理 47<br>3.8.4 使用方法 47<br>3.8.5 插件代码 48<br>3.9 插件9：NoPx()和Px() 49<br>3.9.1 关于此插件 50<br>3.9.2 变量、数组和函数 50<br>3.9.3 工作原理 50<br>3.9.4 使用方法 50<br>3.9.5 插件代码 51<br>3.10 插件10：X()和Y() 51<br>3.10.1 关于此插件 52<br>3.10.2 变量、数组和函数 52<br>3.10.3 工作原理 52<br>3.10.4 使用方法 52<br>3.10.5 插件代码 53<br>3.11 插件11：W()和H() 53<br>3.11.1 关于此插件 53<br>3.11.2 变量、数组和函数 54<br>3.11.3 工作原理 54<br>3.11.4 使用方法 55<br>3.11.5 插件代码 55<br>3.12 插件12：Html() 56<br>3.12.1 关于此插件 56<br>3.12.2 变量、数组和函数 57<br>3.12.3 工作原理 57<br>3.12.4 使用方法 57<br>3.12.5 插件代码 58<br>3.13 插件13：SaveState() 58<br>3.13.1 关于此插件 58<br>3.13.2 变量、数组和函数 58<br>3.13.3 工作原理 59<br>3.13.4 使用方法 59<br>3.13.5 插件代码 60<br>3.14 插件14：RestoreState() 60<br>3.14.1 关于此插件 60<br>3.14.2 变量、数组和函数 60<br>3.14.3 工作原理 61<br>3.14.4 使用方法 61<br>3.14.5 插件代码 62<br>3.15 插件15：InsVars() 62<br>3.15.1 关于此插件 63<br>3.15.2 变量、数组和函数 63<br>3.15.3 工作原理 63<br>3.15.4 使用方法 63<br>3.15.5 插件代码 64<br>3.16 插件16：StrRepeat() 64<br>3.16.1 关于此插件 64<br>3.16.2 变量、数组和函数 64<br>3.16.3 工作原理 65<br>3.16.4 使用方法 65<br>3.16.5 插件代码 65<br>3.17 插件17：HexDec() 65<br>3.17.1 关于此插件 66<br>3.17.2 变量、数组和函数 66<br>3.17.3 工作原理 66<br>3.17.4 使用方法 66<br>3.17.5 插件代码 66<br>3.18 插件18：DecHex() 66<br>3.18.1 关于此插件 67<br>3.18.2 变量、数组和函数 67<br>3.18.3 工作原理 67<br>3.18.4 使用方法 68<br>3.18.5 插件代码 68<br>第4章 位置和大小 69<br>4.1 插件19：ResizeWidth() 69<br>4.1.1 关于此插件 69<br>4.1.2 变量、数组和函数 70<br>4.1.3 工作原理 70<br>4.1.4 使用方法 70<br>4.1.5 插件代码 71<br>4.2 插件20：ResizeHeight() 71<br>4.2.1 关于此插件 71<br>4.2.2 变量、数组和函数 71<br>4.2.3 工作原理 72<br>4.2.4 使用方法 72<br>4.2.5 插件代码 72<br>4.3 插件21：Resize() 73<br>4.3.1 关于此插件 73<br>4.3.2 变量、数组和函数 73<br>4.3.3 工作原理 73<br>4.3.4 使用方法 73<br>4.3.5 插件代码 74<br>4.4 插件22：Position() 74<br>4.4.1 关于此插件 75<br>4.4.2 变量、数组和函数 75<br>4.4.3 工作原理 75<br>4.4.4 使用方法 75<br>4.4.5 插件代码 76<br>4.5 插件23：GoTo() 76<br>4.5.1 关于此插件 76<br>4.5.2 变量、数组和函数 77<br>4.5.3 工作原理 77<br>4.5.4 使用方法 77<br>4.5.5 插件代码 77<br>4.6 插件24：Locate() 78<br>4.6.1 关于此插件 78<br>4.6.2 变量、数组和函数 78<br>4.6.3 工作原理 78<br>4.6.4 使用方法 78<br>4.6.5 插件代码 79<br>4.7 插件25：GetWindowWidth() 79<br>4.7.1 关于此插件 80<br>4.7.2 变量、数组和函数 80<br>4.7.3 工作原理 80<br>4.7.4 使用方法 80<br>4.7.5 插件代码 81<br>4.8 插件26：GetWindowHeight() 81<br>4.8.1 关于此插件 81<br>4.8.2 变量、数组和函数 81<br>4.8.3 工作原理 82<br>4.8.4 使用方法 82<br>4.8.5 插件代码 82<br>4.9 插件27：GoToEdge() 82<br>4.9.1 关于此插件 83<br>4.9.2 变量、数组和函数 83<br>4.9.3 工作原理 83<br>4.9.4 使用方法 84<br>4.9.5 插件代码 85<br>4.10 插件28：CenterX() 86<br>4.10.1 关于此插件 86<br>4.10.2 变量、数组和函数 86<br>4.10.3 工作原理 86<br>4.10.4 使用方法 87<br>4.10.5 插件代码 87<br>4.11 插件29：CenterY() 88<br>4.11.1 关于此插件 88<br>4.11.2 变量、数组和函数 88<br>4.11.3 工作原理 88<br>4.11.4 使用方法 89<br>4.11.5 插件代码 89<br>4.12 插件30：Center() 89<br>4.12.1 关于此插件 90<br>4.12.2 变量、数组和函数 90<br>4.12.3 工作原理 90<br>4.12.4 使用方法 90<br>4.12.5 插件代码 91<br>第5章 可视化 93<br>5.1 插件31：Invisible() 93<br>5.1.1 关于此插件 94<br>5.1.2 变量、数组和函数 94<br>5.1.3 工作原理 94<br>5.1.4 使用方法 94<br>5.1.5 插件代码 95<br>5.2 插件32：Visible() 95<br>5.2.1 关于此插件 95<br>5.2.2 变量、数组和函数 96<br>5.2.3 工作原理 96<br>5.2.4 使用方法 96<br>5.2.5 插件代码 96<br>5.3 插件33：VisibilityToggle() 96<br>5.3.1 关于此插件 97<br>5.3.2 变量、数组和函数 97<br>5.3.3 工作原理 97<br>5.3.4 使用方法 98<br>5.3.5 插件代码 98<br>5.4 插件34：Opacity() 99<br>5.4.1 关于此插件 99<br>5.4.2 变量、数组和函数 99<br>5.4.3 工作原理 100<br>5.4.4 使用方法 100<br>5.4.5 插件代码 101<br>5.5 插件35：Fade() 101<br>5.5.1 关于此插件 101<br>5.5.2 变量、数组和函数 102<br>5.5.3 工作原理 102<br>5.5.4 使用方法 107<br>5.5.5 插件代码 108<br>5.6 插件36：FadeOut() 109<br>5.6.1 关于此插件 110<br>5.6.2 变量、数组和函数 110<br>5.6.3 工作原理 110<br>5.6.4 使用方法 110<br>5.6.5 插件代码 111<br>5.7 插件37：FadeIn() 111<br>5.7.1 关于此插件 111<br>5.7.2 变量、数组和函数 112<br>5.7.3 工作原理 112<br>5.7.4 使用方法 112<br>5.7.5 插件代码 112<br>5.8 插件38：FadeToggle() 113<br>5.8.1 关于此插件 113<br>5.8.2 变量、数组和函数 113<br>5.8.3 工作原理 113<br>5.8.4 使用方法 114<br>5.8.5 插件代码 114<br>5.9 插件39：FadeBetween() 115<br>5.9.1 关于此插件 115<br>5.9.2 变量、数组和函数 115<br>5.9.3 工作原理 115<br>5.9.4 使用方法 115<br>5.9.5 插件代码 116<br>5.10 插件40：Hide() 116<br>5.10.1 关于此插件 117<br>5.10.2 变量、数组和函数 117<br>5.10.3 工作原理 117<br>5.10.4 使用方法 117<br>5.10.5 插件代码 118<br>5.11 插件41：Show() 118<br>5.11.1 关于此插件 119<br>5.11.2 变量、数组和函数 119<br>5.11.3 工作原理 119<br>5.11.4 使用方法 119<br>5.11.5 插件代码 121<br>5.12 插件42：HideToggle() 121<br>5.12.1 关于此插件 121<br>5.12.2 变量、数组和函数 122<br>5.12.3 工作原理 122<br>5.12.4 使用方法 122<br>5.12.5 插件代码 123<br>第6章 移动和动画 125<br>6.1 插件43：Slide() 125<br>6.1.1 关于此插件 125<br>6.1.2 变量、数组和函数 126<br>6.1.3 工作原理 126<br>6.1.4 使用方法 130<br>6.1.5 插件代码 131<br>6.2 插件44：SlideBetween() 132<br>6.2.1 关于此插件 132<br>6.2.2 变量、数组和函数 132<br>6.2.3 工作原理 133<br>6.2.4 使用方法 134<br>6.2.5 插件代码 136<br>6.3 插件45：Deflate() 136<br>6.3.1 关于此插件 137<br>6.3.2 变量、数组和函数 137<br>6.3.3 工作原理 138<br>6.3.4 使用方法 140<br>6.3.5 插件代码 141<br>6.4 插件46：Reflate() 142<br>6.4.1 关于此插件 143<br>6.4.2 变量、数组和函数 143<br>6.4.3 工作原理 143<br>6.4.4 使用方法 144<br>6.4.5 插件代码 145<br>6.5 插件47：DeflateToggle() 146<br>6.5.1 关于此插件 146<br>6.5.2 变量、数组和函数 146<br>6.5.3 工作原理 147<br>6.5.4 使用方法 147<br>6.5.5 插件代码 148<br>6.6 插件48：DeflateBetween() 148<br>6.6.1 关于此插件 149<br>6.6.2 变量、数组和函数 149<br>6.6.3 工作原理 149<br>6.6.4 使用方法 149<br>6.6.5 插件代码 150<br>6.7 插件49：Zoom() 151<br>6.7.1 关于此插件 151<br>6.7.2 变量、数组和函数 152<br>6.7.3 工作原理 153<br>6.7.4 使用方法 158<br>6.7.5 插件代码 160<br>6.8 插件50：ZoomDown() 162<br>6.8.1 关于此插件 162<br>6.8.2 变量、数组和函数 162<br>6.8.3 工作原理 163<br>6.8.4 使用方法 163<br>6.8.5 插件代码 164<br>6.9 插件51：ZoomRestore() 165<br>6.9.1 关于此插件 165<br>6.9.2 变量、数组和函数 166<br>6.9.3 工作原理 166<br>6.9.4 使用方法 167<br>6.9.5 插件代码 167<br>6.10 插件52：ZoomToggle() 168<br>6.10.1 关于此插件 168<br>6.10.2 变量、数组和函数 169<br>6.10.3 工作原理 169<br>6.10.4 使用方法 169<br>6.10.5 插件代码 170<br>第7章 链接和交互 173<br>7.1 插件53： Chain()、NextInChain()<br>和CallBack() 173<br>7.1.1 关于此插件 174<br>7.1.2 变量、数组和函数 174<br>7.1.3 工作原理 175<br>7.1.4 使用方法 177<br>7.1.5 插件代码 179<br>7.2 插件54：Repeat() 180<br>7.2.1 关于此插件 180<br>7.2.2 变量、数组和函数 181<br>7.2.3 工作原理 181<br>7.2.4 使用方法 181<br>7.2.5 插件代码 182<br>7.3 插件55：While() 182<br>7.3.1 关于此插件 182<br>7.3.2 变量、数组和函数 183<br>7.3.3 工作原理 183<br>7.3.4 使用方法 185<br>7.3.5 插件代码 187<br>7.4 插件56：Pause() 187<br>7.4.1 关于此插件 187<br>7.4.2 变量、数组和函数 188<br>7.4.3 工作原理 188<br>7.4.4 使用方法 188<br>7.4.5 插件代码 189<br>7.5 插件57：WaitKey() 189<br>7.5.1 关于此插件 190<br>7.5.2 变量、数组和函数 190<br>7.5.3 工作原理 190<br>7.5.4 使用方法 190<br>7.5.5 插件代码 192<br>7.6 插件58：Flip() 192<br>7.6.1 关于此插件 193<br>7.6.2 变量、数组和函数 193<br>7.6.3 工作原理 194<br>7.6.4 使用方法 195<br>7.6.5 插件代码 196<br>7.7 插件59：HoverSlide() 197<br>7.7.1 关于此插件 198<br>7.7.2 变量、数组和函数 198<br>7.7.3 工作原理 199<br>7.7.4 使用方法 202<br>7.7.5 插件代码 204<br>第8章 菜单和导航 207<br>8.1 插件60：HoverSlideMenu() 207<br>8.1.1 关于此插件 208<br>8.1.2 变量、数组和函数 208<br>8.1.3 工作原理 208<br>8.1.4 使用方法 210<br>8.1.5 插件代码 211<br>8.2 插件61：PopDown() 212<br>8.2.1 关于此插件 212<br>8.2.2 变量、数组和函数 213<br>8.2.3 工作原理 213<br>8.2.4 使用方法 213<br>8.2.5 插件代码 214<br>8.3 插件62：PopUp() 215<br>8.3.1 关于此插件 215<br>8.3.2 变量、数组和函数 216<br>8.3.3 工作原理 216<br>8.3.4 使用方法 217<br>8.3.5 插件代码 217<br>8.4 插件63：PopToggle() 218<br>8.4.1 关于此插件 218<br>8.4.2 变量、数组和函数 219<br>8.4.3 工作原理 219<br>8.4.4 使用方法 219<br>8.4.5 插件代码 220<br>8.5 插件64：FoldingMenu() 221<br>8.5.1 关于此插件 221<br>8.5.2 变量、数组和函数 222<br>8.5.3 工作原理 222<br>8.5.4 使用方法 224<br>8.5.5 插件代码 226<br>8.6 插件65：ContextMenu() 227<br>8.6.1 关于此插件 227<br>8.6.2 变量、数组和函数 228<br>8.6.3 工作原理 228<br>8.6.4 使用方法 230<br>8.6.5 插件代码 231<br>8.7 插件66：DockBar() 232<br>8.7.1 关于此插件 232<br>8.7.2 变量、数组和函数 233<br>8.7.3 工作原理 233<br>8.7.4 使用方法 235<br>8.7.5 插件代码 236<br>8.8 插件67：RollOver() 237<br>8.8.1 关于此插件 238<br>8.8.2 变量、数组和函数 238<br>8.8.3 工作原理 238<br>8.8.4 使用方法 240<br>8.8.5 插件代码 241<br>8.9 插件68：Breadcrumbs() 242<br>8.9.1 关于此插件 242<br>8.9.2 变量、数组和函数 242<br>8.9.3 工作原理 242<br>8.9.4 使用方法 243<br>8.9.5 插件代码 244<br>8.10 插件69：BrowserWindow() 244<br>8.10.1 关于此插件 245<br>8.10.2 变量、数组和函数 246<br>8.10.3 工作原理 247<br>8.10.4 使用方法 249<br>8.10.5 插件代码 251<br>第9章 文本效果 253<br>9.1 插件70：TextScroll() 253<br>9.1.1 关于此插件 253<br>9.1.2 变量、数组和函数 254<br>9.1.3 工作原理 254<br>9.1.4 使用方法 256<br>9.1.5 插件代码 256<br>9.2 插件71：TextType() 257<br>9.2.1 关于此插件 257<br>9.2.2 变量、数组和函数 257<br>9.2.3 工作原理 258<br>9.2.4 使用方法 259<br>9.2.5 插件代码 260<br>9.3 插件72：MatrixToText() 261<br>9.3.1 关于此插件 261<br>9.3.2 变量、数组和函数 261<br>9.3.3 工作原理 262<br>9.3.4 使用方法 264<br>9.3.5 插件代码 264<br>9.4 插件73：TextToMatrix() 265<br>9.4.1 关于此插件 266<br>9.4.2 变量、数组和函数 266<br>9.4.3 工作原理 266<br>9.4.4 使用方法 266<br>9.4.5 插件代码 267<br>9.5 插件74：ColorFade() 268<br>9.5.1 关于此插件 268<br>9.5.2 变量、数组和函数 269<br>9.5.3 工作原理 269<br>9.5.4 使用方法 272<br>9.5.5 插件代码 273<br>9.6 插件75：FlyIn() 274<br>9.6.1 关于此插件 274<br>9.6.2 变量、数组和函数 275<br>9.6.3 工作原理 275<br>9.6.4 使用方法 276<br>9.6.5 插件代码 278<br>9.7 插件76：TextRipple() 278<br>9.7.1 关于此插件 279<br>9.7.2 变量、数组和函数 279<br>9.7.3 工作原理 280<br>9.7.4 使用方法 282<br>9.7.5 插件代码 283<br>第10章 声音和视觉效果 285<br>10.1 插件77：Lightbox() 285<br>10.1.1 关于此插件 286<br>10.1.2 变量、数组和函数 286<br>10.1.3 工作原理 287<br>10.1.4 使用方法 288<br>10.1.5 插件代码 289<br>10.2 插件78：Slideshow() 290<br>10.2.1 关于此插件 291<br>10.2.2 变量、数组和函数 291<br>10.2.3 工作原理 291<br>10.2.4 使用方法 294<br>10.2.5 插件代码 295<br>10.3 插件79：Billboard() 296<br>10.3.1 关于此插件 296<br>10.3.2 变量、数组和函数 297<br>10.3.3 工作原理 297<br>10.3.4 使用方法 300<br>10.3.5 插件代码 301<br>10.4 插件80：GoogleChart() 302<br>10.4.1 关于此插件 303<br>10.4.2 变量、数组和函数 304<br>10.4.3 工作原理 304<br>10.4.4 使用方法 305<br>10.4.5 插件代码 306<br>10.5 插件81：PlaySound() 307<br>10.5.1 关于此插件 307<br>10.5.2 变量、数组和函数 307<br>10.5.3 工作原理 308<br>10.5.4 使用方法 308<br>10.5.5 插件代码 309<br>10.6 插件82：EmbedYouTube() 309<br>10.6.1 关于此插件 310<br>10.6.2 变量、数组和函数 310<br>10.6.3 工作原理 310<br>10.6.4 使用方法 310<br>10.6.5 插件代码 311<br>10.7 插件83：PulsateOn-<br>Mouseover() 312<br>10.7.1 关于此插件 312<br>10.7.2 变量、数组和函数 312<br>10.7.3 工作原理 313<br>10.7.4 使用方法 315<br>10.7.5 插件代码 315<br>第11章 cookie、Ajax和安全性 317<br>11.1 插件84：ProcessCookie() 317<br>11.1.1 关于此插件 318<br>11.1.2 变量、数组和函数 318<br>11.1.3 工作原理 318<br>11.1.4 使用方法 320<br>11.1.5 插件代码 321<br>11.2 插件85：CreateAjaxObject() 322<br>11.2.1 关于此插件 322<br>11.2.2 变量、数组和函数 323<br>11.2.3 工作原理 323<br>11.2.4 使用方法 324<br>11.2.5 插件代码 325<br>11.3 插件86：GetAjaxRequest() 326<br>11.3.1 关于此插件 326<br>11.3.2 变量、数组和函数 326<br>11.3.3 工作原理 327<br>11.3.4 使用方法 327<br>11.3.5 插件代码 328<br>11.4 插件87：PostAjax-<br>Request() 328<br>11.4.1 关于此插件 329<br>11.4.2 变量、数组和函数 329<br>11.4.3 工作原理 329<br>11.4.4 使用方法 330<br>11.4.5 插件代码 331<br>11.5 插件88：FrameBust() 331<br>11.5.1 关于此插件 332<br>11.5.2 变量、数组和函数 332<br>11.5.3 工作原理 332<br>11.5.4 使用方法 333<br>11.5.5 插件代码 333<br>11.6 插件89：ProtectEmail() 333<br>11.6.1 关于此插件 334<br>11.6.2 变量、数组和函数 334<br>11.6.3 工作原理 334<br>11.6.4 使用方法 334<br>11.6.5 插件代码 335<br>第12章 表单和验证 337<br>12.1 插件90：FieldPrompt() 337<br>12.1.1 关于此插件 338<br>12.1.2 变量、数组和函数 338<br>12.1.3 工作原理 338<br>12.1.4 使用方法 339<br>12.1.5 插件代码 340<br>12.2 插件91：ResizeTextarea() 340<br>12.2.1 关于此插件 341<br>12.2.2 变量、数组和函数 342<br>12.2.3 工作原理 342<br>12.2.4 使用方法 343<br>12.2.5 插件代码 343<br>12.3 插件92：ValidateEmail() 344<br>12.3.1 关于此插件 344<br>12.3.2 变量、数组和函数 344<br>12.3.3 工作原理 345<br>12.3.4 使用方法 346<br>12.3.5 插件代码 346<br>12.4 插件93：Validate-<br>Password() 346<br>12.4.1 关于此插件 347<br>12.4.2 变量、数组和函数 347<br>12.4.3 工作原理 347<br>12.4.4 使用方法 348<br>12.4.5 插件代码 348<br>12.5 插件94：CleanupString() 349<br>12.5.1 关于此插件 350<br>12.5.2 变量、数组和函数 350<br>12.5.3 工作原理 350<br>12.5.4 使用方法 350<br>12.5.5 插件代码 351<br>12.6 插件95：ValidateCredit-<br>Card() 351<br>12.6.1 关于此插件 352<br>12.6.2 变量、数组和函数 352<br>12.6.3 工作原理 352<br>12.6.4 使用方法 353<br>12.6.5 插件代码 354<br>第13章 常见问题解决方案 357<br>13.1 插件96：Rolling-<br>Copyright() 357<br>13.1.1 关于此插件 357<br>13.1.2 变量、数组和函数 358<br>13.1.3 工作原理 358<br>13.1.4 使用方法 358<br>13.1.5 插件代码 358<br>13.2 插件97：Alert() 359<br>13.2.1 关于此插件 360<br>13.2.2 变量、数组和函数 360<br>13.2.3 工作原理 361<br>13.2.4 使用方法 362<br>13.2.5 插件代码 363<br>13.3 插件98：ReplaceAlert() 364<br>13.3.1 关于此插件 365<br>13.3.2 变量、数组和函数 365<br>13.3.3 工作原理 365<br>13.3.4 使用方法 365<br>13.3.5 插件代码 366<br>13.4 插件99：ToolTip() 366<br>13.4.1 关于此插件 366<br>13.4.2 变量、数组和函数 367<br>13.4.3 工作原理 368<br>13.4.4 使用方法 369<br>13.4.5 插件代码 370<br>13.5 插件100：CursorTrail() 371<br>13.5.1 关于此插件 372<br>13.5.2 变量、数组和函数 372<br>13.5.3 工作原理 373<br>13.5.4 使用方法 375<br>13.5.5 插件代码 375<br>13.6 插件101：TouchEable() 376<br>13.6.1 关于此插件 377<br>13.6.2 变量、数组和函数 377<br>13.6.3 工作原理 378<br>13.6.4 使用方法 380<br>13.6.5 插件代码 381</p><h3 id="JavaScript快速开发工具箱-PDF-下载地址"><a href="#JavaScript快速开发工具箱-PDF-下载地址" class="headerlink" title="JavaScript快速开发工具箱 PDF 下载地址:"></a>JavaScript快速开发工具箱 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1tgTim7b1rFursxWKf-ax8A?pwd=mpik">https://pan.baidu.com/s/1tgTim7b1rFursxWKf-ax8A?pwd=mpik</a> </p><p>提取码: mpik </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript权威指南(第5版) 》</title>
      <link href="/2023/10/07/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%AC%AC5%E7%89%88)/"/>
      <url>/2023/10/07/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%AC%AC5%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928161830.png" alt="《 JavaScript权威指南(第5版) 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScript权威指南(影印版)(第5版)》已经经过全面地修订和扩展，涵盖了构建当今Web2.0应用程序所需的JavaScript技术。《JavaScript权威指南(影印版)(第5版)》不仅是一本实例驱动的程序员指南，同时也是一本可以摆在桌边随时查阅的参考手册，它以全新的章节阐述了有效使用Javascript脚本所需要知道的一切，包括：</p><p>脚本化的HTTP和Ajax；XML处理；使用标记的客户端图形；JavaScript的命名空间——编写复杂程序时所必不可少的；嵌入到Java应用程序中的类、闭包、持久层、Flash和JavaScript第一部分详细阐述了JavaScript语言的核心内容。如果你是JavaScript新手，它将教授你这门语言；如果你已经是一个JavaScript程序员，第一部分将能磨练你的技艺并加深你对这门语言的理解。第二部分阐述了在特定浏览器提供的脚本环境下，如何使用JavaScript进行DOM编程。同时运用许多精巧的实例，广泛且深入地阐明了JavaScript如何应用于客户端程序：；为HTML文档生成表格内容；展示DHTML的活力；自动化表单验证；绘制动态饼状统计图；创建可拖曳的HTML元素；为Web应用程序定义键盘快捷键；创建有Ajax特性的工具提示；在Ajax应用中使用XPath和XSLT加载XML文档对象；以及更多第三部分全面介绍了JavaScript语言的核心。讲述了在JavaScript1.5和ECMAScriptversion3中定义的每一个类、对象、构造器、方法、函数、属性和常量。第四部分是关于客户端JavaScript的详细参考，涵盖了遗留的Web浏览器API、标准DOM2API以及新兴的标准,例如XMLHttpRequest对象和标记。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>David Flanagan是一名程序员，也是一名作家，它的个人网站是<a href="http://davidflanagan.com.他在o'reilly出版的其他畅销书还包括《javascript/">http://davidflanagan.com。他在O&#39;Reilly出版的其他畅销书还包括《JavaScript</a> Pocket Reference》、《The Ruby Programming Language》，以及《Java in a Nutshell》。David毕业于麻生理工学院，获得计算机科学与工程学位。他和妻子和孩子一起生活在西雅图和温哥华之间的美国太平洋西北海岸。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言 1<br>第1章 JavaScript概述 5<br>1.1 JavaScript语言核心 8<br>1.2 客户端JavaScript 12<br>第一部分 JavaScript 语言核心<br>第2章 词法结构 25<br>2.1 字符集 25<br>2.2 注释 27<br>2.3 直接量 27<br>2.4 标识符和保留字 28<br>2.5 可选的分号 30<br>第3章 类型、值和变量 32<br>3.1 数字 34<br>3.2 文本 38<br>3.3 布尔值 43<br>3.4 null和undefined 44<br>3.5 全局对象 45<br>3.6 包装对象 46<br>3.7 不可变的原始值和可变的对象引用 47<br>3.8 类型转换 48<br>3.9 变量声明 55<br>3.10 变量作用域 56<br>第4章 表达式和运算符 60<br>4.1 原始表达式 60<br>4.2 对象和数组的初始化表达式 61<br>4.3 函数定义表达式 62<br>4.4 属性访问表达式 63<br>4.5 调用表达式 64<br>4.6 对象创建表达式 64<br>4.7 运算符概述 65<br>4.8 算术表达式 69<br>4.9 关系表达式 74<br>4.10 逻辑表达式 79<br>4.11 赋值表达式 81<br>4.12 表达式计算 83<br>4.13 其他运算符 86<br>第5章 语句 91<br>5.1 表达式语句 92<br>5.2 复合语句和空语句 92<br>5.3 声明语句 94<br>5.4 条件语句 96<br>5.5 循环 101<br>5.6 跳转 106<br>5.7 其他语句类型 113<br>5.8 JavaScript语句小结 116<br>第6章 对象 118<br>6.1 创建对象 120<br>6.2 属性的查询和设置 123<br>6.3 删除属性 127<br>6.4 检测属性 128<br>6.5 枚举属性 130<br>6.6 属性getter和setter 132<br>6.7 属性的特性 134<br>6.8 对象的三个属性 138<br>6.9 序列化对象 141<br>6.10 对象方法 142<br>第7章 数组 144<br>7.1 创建数组 144<br>7.2 数组元素的读和写 145<br>7.3 稀疏数组 147<br>7.4 数组长度 148<br>7.5 数组元素的添加和删除 149<br>7.6 数组遍历 149<br>7.7 多维数组 151<br>7.8 数组方法 152<br>7.9 ECMAScript 5中的数组方法 156<br>7.10 数组类型 160<br>7.11 类数组对象 161<br>7.12 作为数组的字符串 163<br>第8章 函数 165<br>8.1 函数定义 166<br>8.2 函数调用 168<br>8.3 函数的实参和形参 173<br>8.4 作为值的函数 178<br>8.5 作为命名空间的函数 181<br>8.6 闭包 182<br>8.7 函数属性、方法和构造函数 188<br>8.8 函数式编程 194<br>第9章 类和模块 201<br>9.1 类和原型 202<br>9.2 类和构造函数 203<br>9.3 JavaScript中Java式的类继承 207<br>9.4 类的扩充 210<br>9.5 类和类型 212<br>9.6 JavaScript中的面向对象技术 217<br>9.7 子类 230<br>9.8 ECMAScript 5 中的类 239<br>9.9 模块 248<br>第10章 正则表达式的模式匹配 253<br>10.1 正则表达式的定义 253<br>10.2 用于模式匹配的String方法 261<br>10.3 RegExp对象 263<br>第11章 JavaScript的子集和扩展 267<br>11.1 JavaScript的子集 268<br>11.2 常量和局部变量 271<br>11.3 解构赋值 274<br>11.4 迭代 276<br>11.5 函数简写 285<br>11.6 多Catch 从句 285<br>11.7 E4X: ECMAScript for XML 286<br>第12章 服务器端JavaScript 290<br>12.1 用Rhino脚本化Java 291<br>12.2 用Node实现异步I&#x2F;O 297<br>第二部分 客户端JavaScript<br>第13章 Web浏览器中的JavaScript 309<br>13.1 客户端JavaScript 309<br>13.2 在HTML里嵌入JavaScript 313<br>13.3 JavaScript程序的执行 319<br>13.4 兼容性和互用性 326<br>13.5 可访问性 333<br>13.6 安全性 334<br>13.7 客户端框架 339<br>第14章 Window对象 341<br>14.1 计时器 342<br>14.2 浏览器定位和导航 343<br>14.3 浏览历史 345<br>14.4 浏览器和屏幕信息 346<br>14.5 对话框 348<br>14.6 错误处理 351<br>14.7 作为Window对象属性的文档元素 351<br>14.8 多窗口和窗体 353<br>第15章 脚本化文档 361<br>15.1 DOM概览 362<br>15.2 选取文档元素 364<br>15.3 文档结构和遍历 371<br>15.4 属性 375<br>15.5 元素的内容 378<br>15.6 创建、插入和删除节点 382<br>15.7 例子：生成目录表 387<br>15.8 文档和元素的几何形状和滚动 389<br>15.9 HTML表单 396<br>15.10 其他文档特性 404<br>第16章 脚本化CSS 410<br>16.1 CSS概览 411<br>16.2 重要的CSS属性 416<br>16.3 脚本化内联样式 427<br>16.4 查询计算出的样式 431<br>16.5 脚本化CSS类 433<br>16.6 脚本化样式表 435<br>第17章 事件处理 440<br>17.1 事件类型 442<br>17.2 注册事件处理程序 451<br>17.3 事件处理程序的调用 454<br>17.4 文档加载事件 459<br>17.5 鼠标事件 461<br>17.6 鼠标滚轮事件 465<br>17.7 拖放事件 468<br>17.8 文本事件 475<br>17.9 键盘事件 478<br>第18章 脚本化HTTP 484<br>18.1 使用XMLHttpRequest 487<br>18.2 借助 script 发送HTTP请求：JSONP 505<br>18.3 基于服务器端推送事件的Comet技术 508<br>第19章 jQuery类库 514<br>19.1 jQuery基础 515<br>19.2 jQuery的getter和setter 522<br>19.3 修改文档结构 528<br>19.4 用jQuery处理事件 531<br>19.5 动画效果 542<br>19.6 jQuery中的Ajax 550<br>19.7 工具函数 563<br>19.8 jQuery选择器和选取方法 566<br>19.9 jQuery的插件扩展 574<br>19.10 jQuery UI类库 577<br>第20章 客户端存储 579<br>20.1 localStorage和sessionStorage 581<br>20.2 cookie 586<br>20.3 利用IE userData来持久化数据 592<br>20.4 应用程序存储和离线Web应用 594<br>第21章 多媒体和图形编程 606<br>21.1 脚本化图片 606<br>21.2 脚本化音频和视频 608<br>21.3 SVG：可伸缩的矢量图形 615<br>21.4 canvas 中的图形 623<br>第22章 HTML5 API 658<br>22.1 地理位置 659<br>22.2 历史记录管理 662<br>22.3 跨域消息传递 668<br>22.4 Web Workers 671<br>22.5 类型化数组和ArrayBuffer 678<br>22.6 Blob 682<br>22.7 文件系统API 691<br>22.8 客户端数据库 696<br>22.9 Web套接字 704<br>第三部分 JavaScript核心参考<br>JavaScript核心参考 711<br>第四部分 客户端JavaScript参考<br>客户端JavaScript参考 847</p><h3 id="JavaScript权威指南-第5版-PDF-下载地址"><a href="#JavaScript权威指南-第5版-PDF-下载地址" class="headerlink" title="JavaScript权威指南(第5版) PDF 下载地址:"></a>JavaScript权威指南(第5版) PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1U3or9h0Agsb4ZSbPHStDKA?pwd=x9rm">https://pan.baidu.com/s/1U3or9h0Agsb4ZSbPHStDKA?pwd=x9rm</a> </p><p>提取码: x9rm </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript模式 》</title>
      <link href="/2023/10/07/JavaScript%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/07/JavaScript%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928161125.png" alt="《 JavaScript模式 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScript模式》包含了实现每个讨论的模式的实践建议，并附有数个可以立即上手的范例。同时还可以学到一些反模式，一些常见的编程方式，这些编程方式引发的问题比解决的还多。它不是一本入门级的书，而是适用于希望将自身的Javascript技巧提高到一个新层次的专业的开发人员和程序员。全书共八章节，内容包括简介、基本技巧、字面量和构造函数、函数、对象创建模式、代码复用模式等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Stoyan Stefanov，是Yahoo的Web开发员、YUI的合作者、演讲师和博客博主。他还是多本O‘Reilly书籍的作者、贡献者和技术评审。Stoyan是smush.it图像优化工具的创建者和YSlow 2.0（一种Yahoo的性能优化工具）的体系架构师。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>第1章 简介<br>模式<br>JavaScript：基本概念<br>ECMAScript 5<br>JSLint<br>Console<br>第2章 基本技巧<br>编写可维护的代码<br>尽量少用全局变量<br>for循环<br>for-in循环<br>不要增加内置的原型<br>switch模式<br>避免使用隐式类型转换<br>使用parseInt()的数值约定<br>编码约定<br>命名约定<br>编写注释<br>编写API文档<br>编写可读性强的代码<br>同行互查<br>在正式发布时精简代码<br>运行JSLint<br>小结<br>第3章 字面量和构造函数<br>对象字面量<br>自定义构造函数<br>强制使用new的模式<br>数组字面量<br>JSON<br>正则表达式字面量<br>基本值类型包装器<br>错误对象<br>小结<br>第4章 函数<br>背景<br>回调模式<br>返回函数<br>自定义函数<br>即时函数<br>即时对象初始化<br>初始化时分支<br>函数属性——备忘模式<br>配置对象<br>Curry<br>小结<br>第5章 对象创建模式<br>命名空间模式<br>声明依赖关系<br>私有属性和方法<br>模块模式<br>沙箱模式<br>静态成员<br>对象常量<br>链模式<br>method()方法<br>小结<br>第6章 代码复用模式<br>传统与现代继承模式的比较<br>使用类式继承时的预期结果<br>类式继承模式#1——默认模式<br>类式继承模式#2——借用构造函数<br>类式继承模式#3——借用和设置原型<br>类式继承模式#4——共享原型<br>类式继承模式#5——临时构造函数<br>Klass<br>原型继承<br>通过复制属性实现继承<br>借用方法<br>小结<br>第7章 设计模式<br>单体模式<br>工厂模式<br>迭代器模式<br>装饰者模式<br>策略模式<br>外观模式<br>代理模式<br>中介者模式<br>观察者模式<br>小结<br>第8章 DOM和浏览器模式<br>关注分离<br>DOM脚本<br>事件<br>长期运行脚本<br>远程脚本<br>配置JavaScript<br>载入策略<br>小结</p><h3 id="JavaScript模式-PDF-下载地址"><a href="#JavaScript模式-PDF-下载地址" class="headerlink" title="JavaScript模式 PDF 下载地址:"></a>JavaScript模式 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1a65KI40QAxwZ_L87jW6s6g?pwd=ur74">https://pan.baidu.com/s/1a65KI40QAxwZ_L87jW6s6g?pwd=ur74</a> </p><p>提取码: ur74 </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript王者归来 》</title>
      <link href="/2023/10/07/JavaScript%E7%8E%8B%E8%80%85%E5%BD%92%E6%9D%A5/"/>
      <url>/2023/10/07/JavaScript%E7%8E%8B%E8%80%85%E5%BD%92%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cBSFrdLfcg2OwEMK3.png" alt="《 JavaScript王者归来 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>你手中的这本《JavaScript王者归来》不仅是一本传播知识的书，更是一本求道的书。<br>JavaScript王者归来分为五个部分循序渐进地与读者讨论了JavaScript的方方面面，从简单的语言基础到丰富的实际应用再到深入剖析语言本质的高级话题，字里行间包含着作者多年工作中对JavaScript实践乃至程序设计思想的深入思考和总结。<br>本书揭开了JavaScript的面纱，绕过误解和虚幻的表象，引领你探索程序王国的奥妙。它既是一本为初学者准备的入门级教程，又是一本探寻程序设计思想本源的“魔法典籍”，也是一本Web开发工程师们需要的案头参考书。<br>本书是你进入脚本王国的一把钥匙，引导你领略脚本魔法的神奇魅力。它还是一本着眼于未来改变互联网的启蒙读物，在它的引领下，你将在互联网的世界里获得你所希望得到的知识、智慧、成就和快乐。                               </p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>吴亮，（网名月影），早年曾在微软亚洲研究院做过访问学生、在金蝶软件有限公司先后担任过核心开发工程师、设计师和项目经理，现任百度电子商务事业部Web开发项目经理。多年来致力于JavaScript技术和Web标准的推广，活跃于国内极有影响力的JavaScript专业网站——无忧脚本</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 概论<br>　第1章 从零开始<br>　　1.1 为什么选择JavaScript?　　　　<br>　　　1.1.1 用户的偏好–B&#x2F;S模式　　　　<br>　　　1.1.2 在什么情况下用JavaScript　　　　<br>　　　1.1.3 对JavaScript的一些误解　　　　<br>　　　　1.1.3.1 JavaScript和Java的关系　　　　<br>　　　　1.1.3.2 披着C外衣的Lisp　　　　<br>　　　　1.1.3.3 关于JavaScript的思维定势　　　　<br>　　　　1.1.3.4 JavaScript是为业余爱好者设计的？　　　　<br>　　　　1.1.3.5 JavaScript是面向对象的吗　　　　<br>　　　　1.1.3.6 其他误解　　　　<br>　　　1.1.4 警惕！脚本诱惑　　　　<br>　　　1.1.5 隐藏在简单表象下的复杂度　　　　<br>　　　1.1.6 令人迷惑的选择–锦上添花还是雪中送炭　　　　 第一部分 概论<br>　第1章 从零开始<br>　　1.1 为什么选择JavaScript?　　　　<br>　　　1.1.1 用户的偏好–B&#x2F;S模式　　　　<br>　　　1.1.2 在什么情况下用JavaScript　　　　<br>　　　1.1.3 对JavaScript的一些误解　　　　<br>　　　　1.1.3.1 JavaScript和Java的关系　　　　<br>　　　　1.1.3.2 披着C外衣的Lisp　　　　<br>　　　　1.1.3.3 关于JavaScript的思维定势　　　　<br>　　　　1.1.3.4 JavaScript是为业余爱好者设计的？　　　　<br>　　　　1.1.3.5 JavaScript是面向对象的吗　　　　<br>　　　　1.1.3.6 其他误解　　　　<br>　　　1.1.4 警惕！脚本诱惑　　　　<br>　　　1.1.5 隐藏在简单表象下的复杂度　　　　<br>　　　1.1.6 令人迷惑的选择–锦上添花还是雪中送炭　　　　<br>　　　1.1.7 回到问题上来　　　　<br>　　1.2 JavaScript的应用范围　　　　<br>　　　1.2.1 客户端的JavaScript　　　　<br>　　　1.2.2 服务器端的JavaScript　　　　<br>　　　1.2.3 其他环境中的JavaScript　　　　<br>　　1.3 JavaScript的版本　　　　<br>　　　1.3.1 浏览器中的JavaScript版本　　　　<br>　　　1.3.2 其他版本　　　　<br>　　1.4 一些值得留意的特性　　　　<br>　　　1.4.1 小把戏–神奇的魔法代码　　　　<br>　　　1.4.2 为客户端服务–经典Hello World！的另一种JavaScript实现　　　　<br>　　　1.4.3 数据交互–JavaScript的一项强大功能　　　　<br>　　　1.4.4 JavaScript表面上的禁忌及如何突破这些禁忌　　　　<br>　 1.5 安全性和执行效率　　　　<br>　　　1.5.1 数据安全–永远的敏感话题　　　　<br>　　　1.5.2 实战！攻击与防范　　　　<br>　　　1.5.3 不容马虎–时刻关注性能　　　　<br>　　1.6 一个例子–JavaScript编写的计算器　　　　<br>　　　1.6.1 从需求分析开始–什么是计算器？　　　　<br>　　　1.6.2 系统设计–如何实现计算器？　　　　<br>　　　1.6.3 系统实现–计算器的最终实现　　　　<br>　　　1.6.4 持续改进–迭代的软件开发过程　　　　<br>　　1.7 学习和使用JavaScript的几点建议　　　　<br>　　　1.7.1 像程序员一样地思考–程序员的四个境界　　　　<br>　　　1.7.2 吝惜你的代码　　　　<br>　　　1.7.3 学会在环境中调试　　　　<br>　　　1.7.4 警惕那些小缺陷　　　　<br>　　　1.7.5 思考先于实践–不要轻易动手写代码　　　　<br>　　　1.7.6 时刻回头–圣贤也无法完全预知未来　　　　<br>　　1.8 关于本书的其余部分　　　　<br>　第2章 浏览器中的JavaScript<br>　　2.1 嵌入网页的可执行内容　　　　<br>　　　2.1.1 在什么地方装载JavaScript代码　　　　<br>　　　2.1.2 关于代码的Script标签　　　　<br>　　　2.1.3 我的代码什么时候被执行–不同执行期的JavaScript代码　　　　<br>　　　2.1.4 拿来主义–引入外部的JavaScript文件　　　　<br>　　2.2 赏心悦目的特效　　　　<br>　　　2.2.1 生命在于运动–DHTML的效果　　　　<br>　　　2.2.2 换一种风格–CSS的力量　　　　<br>　　　2.2.3 用JavaScript操作DOM–一个可拖动窗口的例子　　　　<br>　　2.3 使用JavaScript来与用户交互　　　　<br>　　　2.3.1 创建一个弹出式帮助和进度条　　　　<br>　　　2.3.2 填错了哦　　　　<br>　　2.4 绕开脚本陷阱　　　　<br>　　　2.4.1 现实并不总是完美的　　　　<br>　　　2.4.2 不能完全相信你所见到的　　　　<br>　　2.5 总结　　　　<br>　第3章 开发环境和调试方法<br>　　3.1 我能用什么来编写脚本–适合编写JavaScript的文本编辑器　　　　<br>　　3.2 来自浏览器的支持　　　　<br>　　　3.2.1 主流浏览器　　　　<br>　　　3.2.2 非主流浏览器　　　　<br>　　3.3 集成开发环境　　　　<br>　　　3.3.1 什么是集成开发环境　　　　<br>　　　3.3.2 我需要集成开发环境吗　　　　<br>　　　3.3.3 适合JavaScript的集成开发环境　　　　<br>　　3.4 调试工具–提升开发效率的利器　　　　<br>　　　3.4.1 什么是调试　　　　<br>　　　3.4.2 原始的调试方法–利用输出语句、“反射”机制和调试对象来进行调试　　　　<br>　　　3.4.3 适合JavaScript的调试工具　　　　<br>　　3.5 定位代码和调用堆栈　　　　<br>　　　3.5.1 Step by Step–单步和断点　　　　<br>　　　3.5.2 监视内存　　　　<br>　　　3.5.3 追踪问题的源头–查看调用堆栈　　　　<br>　　　3.5.4 遇到麻烦了–为什么我跟踪不到代码　　　　<br>　 3.6 浏览器捕获异常　　　　<br>　　　3.6.1 异常处理机制–一个try&#x2F;catch&#x2F;finally模式的例子　　　　<br>　　　3.6.2 异常的种类　　　　<br>　　　3.6.3 应该在什么时候“吃掉”异常　　　　<br>　　3.7 总结　　　　<br>第二部分 JavaScript核心<br>　第4章 语言结构<br>　　4.1 JavaScript的基本文法　　　　<br>　　　4.1.1 字符集　　　　<br>　　　4.1.2 大小写敏感　　　　<br>　　　4.1.3 分隔符　　　　<br>　　　4.1.4 词、句子和段落　　　　<br>　　　4.1.5 分号　　　　<br>　　　4.1.6 标记　　　　<br>　　　4.1.7 注释　　　　<br>　　　4.1.8 保留字　　　　<br>　　4.2 常量和变量　　　　<br>　　　4.2.1 常量和变量　　　　<br>　　　4.2.2 变量的标识符　　　　<br>　　　4.2.3 变量的类型　　　　<br>　　　4.2.4 变量的声明　　　　<br>　　　4.2.5 变量的作用域　　　　<br>　　4.3 表达式和运算符　　　　<br>　　　4.3.1 表达式　　　　<br>　　　4.3.2 运算符概述　　　　<br>　　　4.3.3 算术运算符　　　　<br>　　　4.3.4 关系运算符　　　　<br>　　　4.3.5 逻辑运算符　　　　<br>　　　4.3.6 位运算符　　　　<br>　　　4.3.7 赋值运算符　　　　<br>　　　4.3.8 其他运算符　　　　<br>　　　　4.3.8.1 条件运算符　　　　<br>　　　　4.3.8.2 逗号运算符　　　　<br>　　　　4.3.8.3 对象运算符　　　　<br>　　　　4.3.8.4 类型运算符　　　　<br>　　　　4.3.8.5 void运算符　　　　<br>　　　　4.3.8.6 函数调用运算符　　　　<br>　　4.4 控制语句　　　　<br>　　　4.4.1 表达式语句　　　　<br>　　　4.4.2 语句块　　　　<br>　　　4.4.3 条件语句　　　　<br>　　　4.4.4 循环语句　　　　<br>　　　4.4.5 跳转语句　　　　<br>　　　4.4.6 异常处理语句　　　　<br>　　　4.4.7 其他语句　　　　<br>　　　　4.4.7.1 var语句　　　　<br>　　　　4.4.7.2 function语句　　　　<br>　　　　4.4.7.3 with语句　　　　<br>　　　　4.4.7.4 空语句　　　　<br>　　4.5 总结　　　　<br>　第5章 数据类型<br>　　5.1 基本数据类型　　　　<br>　　　5.1.1 数值　　　　<br>　　　5.1.2 字符串–一个字符串相关操作的例子　　　　<br>　　　5.1.3 布尔型　　　　<br>　　5.2 数组和对象　　　　<br>　　　5.2.1 数组　　　　<br>　　　5.2.2 对象–一个构造函数的例子　　　　<br>　　5.3 函数类型–一个函数和闭包的例子　　　　<br>　　5.4 神奇的null和undefined　　　　<br>　　　5.4.1 null　　　　<br>　　　5.4.2 undefined–独一无二的类型　　　　<br>　　5.5 正则表达式　　　　<br>　　　5.5.1 正则表达式常量　　　　<br>　　　5.5.2 正则表达式对象　　　　<br>　　5.6 值类型和引用类型　　　　<br>　　　5.6.1 什么是值和值的引用　　　　<br>　　　5.6.2 使用值和使用引用　　　　<br>　　　5.6.3 值与引用的相互转换：装箱和拆箱　　　　<br>　　5.7 类型识别与类型转换　　　　<br>　　　5.7.1 运行时类型识别–两个运行的类型识别的例子　　　　<br>　　　5.7.2 类型的自动转换及其例子　　　　<br>　　　5.7.3 强制类型转换及其例子　　　　<br>　　　5.7.4 高级用法–一个自定义类型转换的例子　　　　<br>　　5.8 警惕数值陷阱　　　　<br>　　　5.8.1 困惑–浮点数的精度问题　　　　<br>　　　5.8.2 误差的修正及其例子　　　　<br>　　5.9 总结　　　　<br>　第6章 函数<br>　　6.1 函数定义和函数调用　　　　<br>　　　6.1.1 函数的定义　　　　<br>　　　　6.1.1.1 声明式函数定义与函数表达式及其例子　　　　<br>　　　　6.1.1.2 JavaScript函数的奥妙——魔法代码　　　　<br>　　　6.1.2 函数的调用　　　　<br>　　6.2 函数的参数　　　　<br>　　　6.2.1 形参与实参　　　　<br>　　　6.2.2 Arguments对象　　　　<br>　　　　6.2.2.1 一个使用Arguments对象检测形参的例子　　　　<br>　　　　6.2.2.2 一个使用Arguments对象接收任意个数参数的例子　　　　<br>　　　　6.2.2.3 一个使用Arguments对象模拟函数重载的例子　　　　<br>　　　6.2.3 参数类型匹配–一个利用arguments实现函数重载机制的例子　　　　<br>　　6.3 函数的调用者和所有者　　　　<br>　　　6.3.1 函数的调用者　　　　<br>　　　6.3.2 函数的所有者–一个为函数指定所有者的例子　　　　<br>　　　6.3.3 动态调用–外来的所有者　　　　<br>　　6.4 函数常量和闭包　　　　<br>　　　6.4.1 匿名的函数　　　　<br>　　　6.4.2 函数引用　　　　<br>　　　6.4.3 函数参数和函数返回值及其例子　　　　<br>　　　6.4.4 高级用法–闭包作为局部域与延迟求值　　　　<br>　　6.5 高级抽象–Function类型和函数模版　　　　<br>　　　6.5.1 动态创建函数–一个利用Function实现Lambda算子的例子　　　　<br>　　　6.5.2 模式–函数工厂及其实例　　　　<br>　　6.6 总结　　　　<br>　第7章 对象<br>　　7.1 什么是对象　　　　<br>　　7.2 对象的属性和方法　　　　<br>　　　7.2.1 对象的内置属性　　　　<br>　　　7.2.2 为对象添加和删除属性　　　　<br>　　　7.2.3 反射机制–枚举对象属性　　　　<br>　　7.3 对象的构造　　　　<br>　　　7.3.1 构造函数–一个双精度浮点数封装类的例子　　　　<br>　　　7.3.2 缺省构造和拷贝构造　　　　<br>　　　7.3.3 对象常量　　　　<br>　　7.4 对象的销毁和存储单元的回收　　　　<br>　　7.5 JavaScript的内置对象　　　　<br>　　　7.5.1 Math对象　　　　<br>　　　7.5.2 Date对象–创建一个简单的日历　　　　<br>　　　7.5.3 Error对象　　　　<br>　　　7.5.4 其他内置对象　　　　<br>　　　7.5.5 特殊的对象–全局对象与调用对象　　　　<br>　　7.6 总结　　　　<br>　第8章 集合<br>　　8.1 数组和数组元素　　　　<br>　　　8.1.1 数组的构造　　　　<br>　　　8.1.2 数组常量　　　　<br>　　　8.1.3 数组元素　　　　<br>　　8.2 数组对象和方法　　　　<br>　　　8.2.1 查找元素　　　　<br>　　　8.2.2 添加和删除元素　　　　<br>　　　8.2.3 集合操作及其范例　　　　<br>　　　　8.2.3.1 join()方法　　　　<br>　　　　8.2.3.2 reverse()方法　　　　<br>　　　　8.2.3.3 sort()方法　　　　<br>　　　　8.2.3.4 concat()方法　　　　<br>　　　　8.2.3.5 slice()方法　　　　<br>　　　　8.2.3.6 splice()方法　　　　<br>　　　　8.2.3.7 toSgring()方法和toLocaleString()方法　　　　<br>　　8.3 哈希表　　　　<br>　　　8.3.1 什么是哈希表　　　　<br>　　　8.3.2 哈希表的构造　　　　<br>　　　8.3.3 实现一个简单的HashTable类型　　　　<br>　　8.4 高级用法–集合操作和闭包　　　　<br>　　8.5 总结　　　　<br>　第9章 字符串<br>　　9.1 字符串的构造　　　　<br>　　　9.1.1 字符串常量　　　　<br>　　　9.1.2 转义序列　　　　<br>　　　9.1.3 字符串构造函数　　　　<br>　　9.2 字符串的使用　　　　<br>　　　9.2.1 比较字符串　　　　<br>　　　9.2.2 抽取和检索子串　　　　<br>　　　9.2.3 连接拆分字符串　　　　<br>　　　9.2.4 字符串的模式匹配–一个字符串格式校验的例子　　　　<br>　　　9.2.5 其他方法　　　　<br>　　9.3 字符串与字符数组　　　　<br>　　9.4 字符串与文本处理–JavaScript棋谱阅读器（一）　　　　<br>　　　9.4.1 需求分析–什么是棋谱和棋谱阅读器　　　　<br>　　　9.4.2 系统设计–棋谱和棋盘数据的字符串描述　　　　<br>　　　9.4.3 系统实现–解析和处理棋谱　　　　<br>　　　9.4.4 完整的棋谱阅读器　　　　<br>　　9.5 总结　　　　<br>　第10章 正则表达式<br>　　10.1 什么是正则表达式　　　　<br>　　　10.1.1 正则表达式的概念　　　　<br>　　　10.1.2 JavaScript中的正则表达式　　　　<br>　　10.2 正则表达式的规则　　　　<br>　　　10.2.1 直接量字符　　　　<br>　　　10.2.2 字符类和布尔操作　　　　<br>　　　10.2.3 重复　　　　<br>　　　10.2.4 选择、分组和引用　　　　<br>　　　10.2.5 指定匹配的位置　　　　<br>　　　10.2.6 标志——高级模式匹配的规则　　　　<br>　　10.3 模式匹配　　　　<br>　　　10.3.1 用于模式匹配的String方法及其例子　　　　<br>　　　10.3.2 用于模式匹配的RegExp方法　　　　<br>　　　　10.3.2.1 一个使用exec()方法从身份证号码获取生日的例子　　　　<br>　　　　10.3.2.2 一个使用test()方法遍历字符串的例子　　　　<br>　　10.4 关于正则表达式包装对象　　　　<br>　　　10.4.1 RegExp对象——利用正则表达式实现全文检索　　　　<br>　　　10.4.2 RegExp的实例属性　　　　<br>　　10.5 强大的正则表达式　　　　<br>　　　10.5.1 分析正则表达式的局部　　　　<br>　　　10.5.2 一个例子–强大的在线编辑器　　　　<br>　　　10.5.3 构造新的文法–一个在JSVM中实现JSVM2解析器的例子　　　　<br>　　10.6 高级用法　　　　<br>　　10.7 用正则表达式处理文本　　　　<br>　　　10.7.1 创建一个计价公式编辑器　　　　<br>　　　　10.7.1.1 需求分析–什么是计价公式编辑器　　　　<br>　　　　10.7.1.2 系统实现–计价公式编辑器的实现　　　　<br>　　　10.7.2 创建一个同步滚动歌词播放器　　　　<br>　　　　10.7.2.1 需求分析–什么是同步滚动歌词播放器　　　　<br>　　　　10.7.2.2 系统设计与实现–处理LRC歌词　　　　<br>　　10.8 总结　　　　<br>第三部分 浏览器与DOM<br>　第11章 浏览器对象<br>　　11.1 Window对象–最基本的浏览器对象　　　　<br>　　　11.1.1 Window对象概览　　　　<br>　　　11.1.2 Window对象的生命周期　　　　<br>　　　11.1.3 Window对象的属性和方法　　　　<br>　　　11.1.4 一个多窗口应用的例子　　　　<br>　　11.2 Document对象–浏览器窗口文档内容的代表　　　　<br>　　　11.2.1 Document对象概览　　　　<br>　　　11.2.2 动态生成的文档　　　　<br>　　　11.2.3 Document对象的基本信息　　　　<br>　　　11.2.4 Document对象的外观属性　　　　<br>　　　11.2.5 Document子对象接口　　　　<br>　　　　11.2.5.1 一个遍历Anchors对象的例子　　　　<br>　　　　11.2.5.2 一个颠倒图片的例子　　　　<br>　　11.3 对话框和状态栏　　　　<br>　　　11.3.1 创建一个简单对话框　　　　<br>　　　11.3.2 其他类型的对话框　　　　<br>　　　　11.3.2.1 模拟对话框–创建一个窗口对话框及一个对话框阻塞进行的例子　　　　<br>　　　　11.3.2.2 showModalDialog和showModelessDialog–非W3C或ECMAScrip标准　　　　<br>　　　11.3.3 状态栏　　　　<br>　　11.4 框架–上层的Window对象　　　　<br>　　　11.4.1 多框架应用　　　　<br>　　　11.4.2 框架之间的关系　　　　<br>　　　11.4.3 框架的命名　　　　<br>　　　11.4.4 子框架中的JavaScript　　　　<br>　　　11.4.5 框架的应用–多页签显示　　　　<br>　　　　11.4.5.1 什么是页签　　　　<br>　　　　11.4.5.2 页签的实现–创建一个包含页签的页面　　　　<br>　　11.5 表单和表单对象　　　　<br>　　　11.5.1 Form对象及其范例　　　　<br>　　　11.5.2 定义表单元素　　　　<br>　　　11.5.3 客户端表单校验及其例子　　　　<br>　　　11.5.4 创建一款通用的客户端表单校验组件　　　　<br>　　11.6 其他内置对象　　　　<br>　　　11.6.1 Navigator对象–浏览器总体信息的代表　　　　<br>　　　11.6.2 Screen对象–提供显示器分辨率和可用颜色数量信息　　　　<br>　　　11.6.3 Location对象–当前窗口中显示文档的URL的代表　　　　<br>　　　11.6.4 History对象–一个有趣的对象　　　　<br>　　11.7 总结　　　　<br>　第12章 文档对象模型<br>　　12.1 什么是DOM　　　　<br>　　　12.1.1 把文档表示为树　　　　<br>　　　12.1.2 树的节点　　　　<br>　　　12.1.3 DOM对象的通用属性和方法　　　　<br>　　　12.1.4 HTML结构和DOM对象的关系–用JavaScript通过DOM来操作HTML文档　　　　<br>　　12.2 DOM与浏览器实现　　　　<br>　　　12.2.1 关于DOM HTML API　　　　<br>　　　12.2.2 DOM的级别和特性　　　　<br>　　　12.2.3 DOM的一致性　　　　<br>　　　12.2.4 差异性–浏览器的DOM方言　　　　<br>　　12.3 一组“盒子”–DOM元素　　　　<br>　　　12.3.1 嵌套的“盒子”　　　　<br>　　　12.3.2 “盒子”和“盒子”内容的分类　　　　<br>　　12.4 创建和删除节点　　　　<br>　　　12.4.1 构造全新的节点　　　　<br>　　　12.4.2 平面展开–通过文档元素直接创建　　　　<br>　　　12.4.3 回收空间–删除不用的节点　　　　<br>　　12.5 访问和操纵DOM节点　　　　<br>　　　12.5.1 打开每一个盒子–遍历节点　　　　<br>　　　12.5.2 弄清层级关系–父子与兄弟　　　　<br>　　　12.5.3 如何搜索特定节点　　　　<br>　　　12.5.4 克隆节点–一个使用cloneNode()复制表格的例子　　　　<br>　　　12.5.5 移动节点及其范例　　　　<br>　　　12.5.6 关于添加新行和排序的小技巧　　　　<br>　　12.6 读写数据–添加、修改和删除属性　　　　<br>　　12.7 外观与行为　　　　<br>　　　12.7.1 DOM样式属性　　　　<br>　　　12.7.2 控制DOM元素的显示与隐藏　　　　<br>　　　12.7.3 改变颜色和大小–一个简单有趣的例子　　　　<br>　　　12.7.4 改变位置–创建一个绕圆圈旋转的文字　　　　<br>　　　12.7.5 编辑控制及其范例　　　　<br>　　　12.7.6 改变样式及其范例　　　　<br>　　　12.7.7 改变行为　　　　<br>　　12.8 XML DOM　　　　<br>　　　12.8.1 什么是XML DOM　　　　<br>　　　12.8.2 如何使用XML DOM–一个利用XML实现多级关联下拉选择框的例子　　　　<br>　　12.9 总结　　　　<br>　第13章 事件处理<br>　　13.1 什么是事件　　　　<br>　　　13.1.1 消息与事件响应　　　　<br>　　　13.1.2 浏览器的事件驱动机制　　　　<br>　　13.2 基本事件处理　　　　<br>　　　13.2.1 事件和事件类型　　　　<br>　　　13.2.2 事件的绑定　　　　<br>　　　13.2.3 直接调用事件处理函数　　　　<br>　　　13.2.4 事件处理函数的返回值　　　　<br>　　　13.2.5 带参数的事件响应及其例子　　　　<br>　　　13.2.6 “this”关键字　　　　<br>　　13.3 标准事件模型　　　　<br>　　　13.3.1 起泡和捕捉–浏览器的事件传播　　　　<br>　　　13.3.2 事件处理函数的注册　　　　<br>　　　13.3.3 把对象注册为事件处理程序　　　　<br>　　　13.3.4 事件模块和事件类型　　　　<br>　　　13.3.5 关于Event接口　　　　<br>　　　　13.3.5.1 Event接口的属性和方法　　　　<br>　　　　13.3.5.2 UIEvent接口的属性　　　　<br>　　　　13.3.5.3 MouseEvent接口的属性　　　　<br>　　　　13.3.5.4 MutationEvent接口　　　　<br>　　　13.3.6 混合事件模型　　　　<br>　　　13.3.7 合成事件　　　　<br>　　13.4 浏览器的事件处理模型实现　　　　<br>　　　13.4.1 Internet Explorer事件模型　　　　<br>　　　　13.4.1.1 关于IE事件注册　　　　<br>　　　　13.4.1.2 IE Event对象的属性　　　　<br>　　　　13.4.1.3 IE中的事件起泡　　　　<br>　　　13.4.2 Netscape 4事件模型　　　　<br>　　　　13.4.2.1 Netscape 4中的事件捕捉及其范例　　　　<br>　　　　13.4.2.2 Netscape 4 Event对象的属性　　　　<br>　　13.5 回调与用户自定义事件　　　　<br>　　　13.5.1 事件处理模式–一个实现简单事件处理模式的例子　　　　<br>　　　13.5.2 用户事件接口的定义　　　　<br>　　　13.5.3 事件代理和事件注册–一个实现标准事件接口的例子　　　　<br>　　　13.5.4 标准模式–事件分派和接收　　　　<br>　　13.6 一个例子–增强数据表格　　　　<br>　　　13.6.1 什么是增强数据表格　　　　<br>　　　13.6.2 一个采用两重table嵌套方式固定表头的例子　　　　<br>　　　13.6.3 可变列宽的实现　　　　<br>　　　13.6.4 标记行–呈现有别于其他行的背景色　　　　<br>　　　13.6.5 小技巧–将代码添加到样式表　　　　<br>　　13.7 总结　　　　<br>　第14章 级联样式表<br>　　14.1 什么是级联样式表　　　　<br>　　　14.1.1 CSS样式和样式表　　　　<br>　　　14.1.2 CSS的标准化　　　　<br>　　　14.1.3 浏览器支持的CSS　　　　<br>　　14.2 JavaScript与CSS　　　　<br>　　　14.2.1 CSS和DOM的关系　　　　<br>　　　14.2.2 CSS和IE的关系　　　　<br>　　　14.2.3 浏览器的CSS兼容性　　　　<br>　　14.3 控制CSS改变页面风格　　　　<br>　　　14.3.1 实现结构与表现的分离及其范例　　　　<br>　　　14.3.2 使用JwaScript和CSS实现页面多种风格的实时替换　　　　<br>　　14.4 总结　　　　<br>　第15章 数据存储的脚本化<br>　　15.1 什么是cookie　　　　<br>　　　15.1.1 浏览器和客户端cookie　　　　<br>　　　15.1.2 cookie的属性　　　　<br>　　15.2 cookie的客户端存取　　　　<br>　　　15.2.1 cookie的存储　　　　<br>　　　15.2.2 cookie的读取　　　　<br>　　15.3 cookie的限制　　　　<br>　　15.4 cookie示例–让问候更加温暖　　　　<br>　　15.5 cookie对象的封装　　　　<br>　　15.6 什么是userData　　　　<br>　　　15.6.1 浏览器和客户端userData　　　　<br>　　　15.6.2 userData的声明　　　　<br>　　　15.6.3 userData的属性和方法　　　　<br>　　15.7 userData的客户端存取　　　　<br>　　　15.7.1 userData的存储和读取　　　　<br>　　　15.7.2 userData的安全性　　　　<br>　　15.8 userData的限制　　　　<br>　　15.9 userData与cookie的对比　　　　<br>　　15.10 userData示例–一个利用userData实现客户端保存表单数据的例子　　　　<br>　　15.11 总结　　　　<br>第四部分 数据交互<br>　第16章 同步和异步<br>　　16.1 什么是同步和异步　　　　<br>　　16.2 超时设定和时间间隔　　　　<br>　　16.3 定时器使用–侦听与拦截　　　　<br>　　　16.3.1 标准模式–监视器及其范例　　　　<br>　　　16.3.2 使用定时器时应当注意的问题　　　　<br>　　16.4 一个例子–漂亮的Web时钟　　　　<br>　　　16.4.1 什么是Web时钟？　　　　<br>　　　16.4.2 最简单的Web时钟　　　　<br>　　　16.4.3 Web时钟的设计　　　　<br>　　　16.4.4 完整的Web时钟源代码　　　　<br>　　16.5 总结　　　　<br>　第17章 XML DOM和XML HTTP<br>　　17.1 什么是XML DOM对象　　　　<br>　　　17.1.1 XML DOM简介　　　　<br>　　　17.1.2 浏览器支持的XML DOM接口　　　　<br>　　　　17.1.2.1 XML DOM标准接口　　　　<br>　　　　17.1.2.2 IE的XML DOM组件　　　　<br>　　　　17.1.2.3 操作XML文档–一个使用MSXML操作XML文档的例子　　　　<br>　　17.2 XML DOM的版本兼容性–XML DOM的跨浏览器应用　　　　<br>　　17.3 XML DOM的错误处理　　　　<br>　　　17.3.1 处理错误信息的ParseError对象　　　　<br>　　　17.3.2 包含错误信息的文档　　　　<br>　　17.4 XML DOM操作XML文档　　　　<br>　　　17.4.1 访问节点　　　　<br>　　　17.4.2 创建新节点　　　　<br>　　　17.4.3 移动和修改节点及其范例　　　　<br>　　　17.4.4 读写节点属性和读写数据　　　　<br>　　　17.4.5 保存文档　　　　<br>　　17.5 一个例子–JavaScript棋谱阅读器（二）　　　　<br>　　　17.5.1 用XML描述棋谱　　　　<br>　　　17.5.2 将XML棋谱转换为SGF棋谱　　　　<br>　　17.6 什么是XML HTTP对象　　　　<br>　　　17.6.1 XML HTTP对象简介　　　　<br>　　　17.6.2 浏览器支持的XML HTTP对象　　　　<br>　　17.7 通过XML HTTP发送请求　　　　<br>　　　17.7.1 建立连接　　　　<br>　　　17.7.2 发送请求　　　　<br>　　17.8 读取和设定HTTP头　　　　<br>　　　17.8.1 什么是HTTP头　　　　<br>　　　17.8.2 读取和设定HTTP头　　　　<br>　　17.9 服务器应答　　　　<br>　　　17.9.1 同步和异步应答及其例子　　　　<br>　　　17.9.2 包含应答文本内容的ResponseText 和ResponseXML　　　　<br>　　17.10 总结　　　　<br>　第18章 Ajax简介<br>　　18.1 什么是Ajax　　　　<br>　　　18.1.1 Ajax并不神秘　　　　<br>　　　18.1.2 Ajax的应用场景　　　　<br>　　　18.1.3 Ajax的竞争对手–其他替代技术　　　　<br>　　18.2 Ajax初探–我的第一个Ajax程序　　　　<br>　　　18.2.1 从常规应用开始–一个简单的实时聊天室　　　　<br>　　　18.2.2 讨厌的页面刷新　　　　<br>　　　18.2.3 无刷新解决方案–改进的聊天室　　　　<br>　　　18.2.4 异步工作–迟滞感的解决方案　　　　<br>　　18.3 Ajax原理剖析　　　　<br>　　　18.3.1 XML HTTP实时通信及一个简单封装了AjaxProxy对象的例子　　　　<br>　　　18.3.2 数据动态显示–Ajax改善交互体验的重要特点　　　　<br>　　　18.3.3 发挥XML的能力　　　　<br>　　　18.3.4 用JavaScript绑定一切　　　　<br>　　　18.3.5 应用背后的标准　　　　<br>　　18.4 Ajax范例–实时聊天工具　　　　<br>　　　18.4.1 什么是实时聊天工具　　　　<br>　　　18.4.2 需求分析–实时聊天功能的实现要点　　　　<br>　　　18.4.3 系统实现–实时聊天功能的实现　　　　<br>　　　18.4.4 小结　　　　<br>　　18.5 总结　　　　<br>　第19章 标准和兼容性<br>　　19.1 标准化组织　　　　<br>　　　19.1.1 W3C和DOM标准　　　　<br>　　　19.1.2 ECMA和JavaScript标准　　　　<br>　　　19.1.3 互联网标准　　　　<br>　　19.2 平台和浏览器的兼容性　　　　<br>　　　19.2.1 最小公分母法　　　　<br>　　　19.2.2 防御性编码　　　　<br>　　　19.2.3 客户端探测器　　　　<br>　　　19.2.4 特性检测　　　　<br>　　　19.2.5 实现标准　　　　<br>　　　19.2.6 适度停止运行　　　　<br>　　19.3 语言版本的兼容性　　　　<br>　　　19.3.1 language属性　　　　<br>　　　19.3.2 版本测试　　　　<br>　　19.4 如何实现跨浏览器应用　　　　<br>　　　19.4.1 取舍–划定支持范围　　　　<br>　　　19.4.2 基础模块设计–独立兼容性检测　　　　<br>　　　19.4.3 划分运行级别　　　　<br>　　　19.4.4 给出正确的信息–不要让你的代码保持沉默　　　　<br>　　　19.4.5 充分的应用测试–“兼容性魔鬼”总会趁你不注意时“踢你的狗”　　　　<br>　　　19.4.6 靠近标准和就近原则　　　　<br>　19.5 展望未来　　　　<br>　 19.6 总结　　　　<br>　第20章 信息安全<br>　　20.1 用户的隐私信息　　　　<br>　　20.2 禁止和受限制的操作　　　　<br>　　　20.2.1 受限制的属性　　　　<br>　　　20.2.2 受限制的操作　　　　<br>　　　20.2.3 脚本安全级别　　　　<br>　　　20.2.4 脚本调试　　　　<br>　　20.3 警惕幕后的攻击者　　　　<br>　　　20.3.1 攻击的手段　　　　<br>　　　20.3.2 隐匿的数据流　　　　<br>　　　20.3.3 页面伪装　　　　<br>　　　20.3.4 发现蛛丝马迹　　　　<br>　　　20.3.5 防范的手段　　　　<br>　　　　20.3.5.1 传输数据的加密　　　　<br>　　　　20.3.5.2 对用户隐藏源代码　　　　<br>　　20.4 同源策略　　　　<br>　　　20.4.1 什么是同源策略　　　　<br>　　　20.4.2 同源策略的利弊　　　　<br>　　　20.4.3 突破同源策略　　　　<br>　　20.5 安全区和签名脚本　　　　<br>　　　20.5.1 可配置的安全策略方案　　　　<br>　　　20.5.2 Internet Explorer的安全区　　　　<br>　　　20.5.3 Netscape的签名脚本　　　　<br>　　20.6 代码本身的安全–加密和混淆　　　　<br>　　　20.6.1 为什么要加密和混淆　　　　<br>　　　20.6.2 客户端的加密技术及其例子　　　　<br>　　　20.6.3 代码混淆原理　　　　<br>　　　20.6.4 JavaScript代码混淆工具–一个代码混淆算法的例子　　　　<br>　　　20.6.5 加密和混淆的结合使用　　　　<br>　　20.7 总结　　　　<br>第五部分 超越JavaScript<br>　第21章 面向对象<br>　　21.1 什么面向对象　　　　<br>　　　21.1.1 类和对象　　　　<br>　　　21.1.2 公有和私有–属性的封装　　　　<br>　　　21.1.3 属性和方法的类型　　　　<br>　　21.2 神奇的prototype　　　　<br>　　　21.2.1 什么是prototype　　　　<br>　　　21.2.2 prototype的使用技巧　　　　<br>　　　　21.2.2.1 给原型对象添加属性　　　　<br>　　　　21.2.2.2 带默认值的Point对象　　　　<br>　　　　21.2.2.3 delete操作将对象属性恢复为默认值　　　　<br>　　　　21.2.2.4 使用prototype巧设getter　　　　<br>　　　　21.2.2.5 delete操作恢复原型属性的可见性　　　　<br>　　　　21.2.2.6 使用prototype创建大量副本　　　　<br>　　　　21.2.2.7 使用prototype定义静态方法　　　　<br>　　　21.2.3 prototype的实质及其范例　　　　<br>　　　21.2.4 prototype的价值与局限性　　　　<br>　　21.3 继承与多态　　　　<br>　　　21.3.1 什么是继承　　　　<br>　　　21.3.2 实现继承的方法　　　　<br>　　　　21.3.2.1 构造继承法及其例子　　　　<br>　　　　21.3.2.2 原型继承法及其例子　　　　<br>　　　　21.3.2.3 实例继承法及其例子　　　　<br>　　　　21.3.2.4 拷贝继承法及其例子　　　　<br>　　　　21.3.2.5 几种继承法的比较　　　　<br>　　　　21.3.2.6 混合继承法及其例子　　　　<br>　　　21.3.3 单继承与多重继承　　　　<br>　　　21.3.4 接口及其实现　　　　<br>　　　21.3.5 多态及其实现　　　　<br>　　21.4 构造与析构　　　　<br>　　　21.4.1 构造函数　　　　<br>　　　21.4.2 多重构造　　　　<br>　　　21.4.3 析构　　　　<br>　　21.5 疑团！“this”迷宫　　　　<br>　　　21.5.1 无数个陷阱–令人困扰的“this”谜团　　　　<br>　　　　21.5.1.1 this代词的运用　　　　<br>　　　　21.5.1.2 this“陷阱”　　　　<br>　　　　21.5.1.3 this代词的异步问题　　　　<br>　　　21.5.2 偷梁换柱–不好的使用习惯　　　　<br>　　　21.5.3 异步调用–谁动了我的“this”　　　　<br>　　　21.5.4 揭开真相–JavaScript的“this”本质　　　　<br>　　　21.5.5 困难不再–利用闭包修正“this”引用　　　　<br>　　21.6 包装对象　　　　<br>　　　21.6.1 区分值和引用　　　　<br>　　　21.6.2 装箱与拆箱　　　　<br>　　21.7 元类，类的模板　　　　<br>　　　21.7.1 什么是元类　　　　<br>　　　21.7.2 元类–构造类的类　　　　<br>　　　21.7.3 为什么要用元类　　　　<br>　　　21.7.4 类工厂　　　　<br>　　　　21.7.4.1 什么是类工厂　　　　<br>　　　　21.7.4.2 为什么要建立类工厂　　　　<br>　　21.8 谁才是造物主　　　　<br>　　　21.8.1 万物适用的准则　　　　<br>　　　21.8.2 抽象的极致–一个抽象模式的例子　　　　<br>　　　21.8.3 返璞归真，同源架构　　　　<br>　　21.9 总结　　　　<br>　第22章 闭包与函数式编程<br>　　22.1 动态语言与闭包　　　　<br>　　　22.1.1 动态语言　　　　<br>　　　22.1.2 语法域和执行域　　　　<br>　　　22.1.3 JavaScript的闭包–一个体现闭包本质的例子　　　　<br>　　22.2 闭包的特点与形式　　　　<br>　　　22.2.1 闭包的内在–自治的领域　　　　<br>　　　22.2.2 访问外部环境–一个用闭包改变外部环境的例子　　　　<br>　　　22.2.3 闭包和面向对象　　　　<br>　　　22.2.4 其他形式的闭包　　　　<br>　　22.3 不适合使用闭包的场合　　　　<br>　　22.4 函数式编程　　　　<br>　　　22.4.1 什么是函数式编程　　　　<br>　　　　22.4.1.1 函数是第一型　　　　<br>　　　　22.4.1.2 闭包与函数式编程　　　　<br>　　　　22.4.1.3 科里化（Currying）–一个有趣的概念　　　　<br>　　　　22.4.1.4 延迟求值和延续–一个Fibonacci无穷数列的例子　　　　<br>　　　22.4.2 函数式编程、公式化与数学模型–一个抛物线方程的例子　　　　<br>　　　22.4.3 函数式编程的优点　　　　<br>　　　　22.4.3.1 单元测试方面的优点　　　　<br>　　　　22.4.3.2 调试方面的优点　　　　<br>　　　　22.4.3.3 并行方面的优点　　　　<br>　　　　22.4.3.4 代码热部署方面的优点　　　　<br>　　　　22.4.3.5 机器辅助的推理和优化　　　　<br>　　　22.4.4 函数式编程的缺点　　　　<br>　　　　22.4.4.1 闭包的副作用　　　　<br>　　　　22.4.4.2 递归的形式　　　　<br>　　　　22.4.4.3 延迟求值的副作用　　　　<br>　　22.5 闭包与面向对象　　　　<br>　　　22.5.1 私有域　　　　<br>　　　22.5.2 名字空间管理　　　　<br>　　　22.5.3 友元–一个非常有趣的概念　　　　<br>　　22.6 Python风格的JavaScript代码　　　　<br>　　　22.6.1 最简约代码　　　　<br>　　　22.6.2 轻量级重用　　　　<br>　　　　22.6.2.1 JSON　　　　<br>　　　　22.6.2.2 Functional　　　　<br>　　　　22.6.2.3 迭代函数–一个Array迭代函数的例子　　　　<br>　　　22.6.3 模块管理及其范例　　　　<br>　　22.7 总结　　　　<br>　第23章 模块级管理<br>　　23.1 模块化管理　　　　<br>　　　23.1.1 模块化–代码的重用　　　　<br>　　　23.1.2 JavaScript的模块管理　　　　<br>　　23.2 开放封闭原则和面向接口　　　　<br>　　　23.2.1 开放封闭原则　　　　<br>　　　23.2.2 面向接口　　　　<br>　　23.3 名字空间管理　　　　<br>　　　23.3.1 什么是名字空间　　　　<br>　　　23.3.2 为什么要用名字空间　　　　<br>　　　23.3.3 JavaScript的名字空间管理　　　　<br>　　23.4 调用依赖　　　　<br>　　　23.4.1 模块的依赖性　　　　<br>　　　23.4.2 模块依赖的管理　　　　<br>　　23.5 用代码管理代码　　　　<br>　　　23.5.1 运行时环境的管理　　　　<br>　　　23.5.2 托管代码–一个简单的托管代码“容器”　　　　<br>　　　23.5.3 一个完整的代码管理容器　　　　<br>　　23.6 总结　　　　<br>　第24章 动态构建<br>　　24.1 让代码去写代码　　　　<br>　　　24.1.1 脚本的动态解析　　　　<br>　　　24.1.2 语法扩展–创造属于自己的语言　　　　<br>　　24.2 “发明”语法　　　　<br>　　　24.2.1 正则表达式和语法解析及例子　　　　<br>　　　24.2.2 一个简单的语法解析器实现　　　　<br>　　　　24.2.2.1 什么是JavaScript 2.0语法　　　　<br>　　　　24.2.2.2 JavaScript 2.0语法的部分关键特性实现　　　　<br>　　24.3 实现自己的方言–LispScript　　　　<br>　　　24.3.1 从JavaScript到Lisp　　　　<br>　　　24.3.2 最初的工作–一般JavaScript代码　　　　<br>　　　24.3.3 公理，表达式　　　　<br>　　　24.3.4 函数式编程的七条基本公设　　　　<br>　　　　24.3.4.1 “引用”公设　　　　<br>　　　　24.3.4.2 “原子”公设　　　　<br>　　　　24.3.4.3 “等值”公设　　　　<br>　　　　24.3.4.4 “表头”公设　　　　<br>　　　　24.3.4.5 “余表”公设　　　　<br>　　　　24.3.4.6 “和表”公设　　　　<br>　　　　24.3.4.7 “条件”公设　　　　<br>　　　24.3.5 函数文法　　　　<br>　　　24.3.6 使用LispScript定义新函数　　　　<br>　　　24.3.7 一个惊喜–_eval　　　　<br>　　　24.3.8 其他的扩展　　　　<br>　　　24.3.9 小结　　　　<br>　　　24.3.10 运行环境和代码容器——看看“新发明”的LispScript的实际表现　　　　<br>24.4 总结　　　　<br>　第25章 执行效率<br>　　25.1 为什么要讨论执行效率　　　　<br>　　　25.1.1 来自客户的抱怨–JavaScript能有多慢　　　　<br>　　　25.1.2 代码慢下来是谁的错　　　　<br>　　25.2 封闭的代价　　　　<br>　　　25.2.1 过度封装的性能问题　　　　<br>　　　25.2.2 信息隐藏的利弊　　　　<br>　　　25.2.3 构造对象的开销　　　　<br>　　25.3 盒子里的流火　　　　<br>　　　25.3.1 DOM的内存开销　　　　<br>　　　25.3.2 浏览器的内存管理　　　　<br>　　　25.3.3 看清一个事实–内存泄漏的存在　　　　<br>　　　25.3.4 注意–及时关闭你的“盒子”　　　　<br>　　　25.3.5 一些误会的澄清　　　　<br>　　　　25.3.5.1 脚本动态创建DOM导致内存泄漏　　　　<br>　　　　25.3.5.2 闭包导致内存泄漏　　　　<br>　　25.4 动态–魔鬼与天使　　　　<br>　　　25.4.1 动态解析的性能分析–一个动态特性的效率测试　　　　<br>　　　25.4.2 开发效率与执行效率–永远的困难选择　　　　<br>　　　25.4.3 优美与适用–学会经受魔鬼的诱惑　　　　<br>　　　25.4.4 扮演客户眼中的天使　　　　<br>　　25.5 让代码轻舞飞扬　　　　<br>　　　25.5.1 简单就是美–为代码瘦身　　　　<br>　　　25.5.2 最完美的运用是不用　　　　<br>　　　25.5.3 高度抽象是为了简化问题　　　　<br>　　　25.5.4 逻辑和表达同样重要　　　　<br>　　　25.5.5 保持代码的严谨　　　　<br>　　　25.5.6 漂亮的书写风格–让阅读者心情愉快　　　　<br>　　25.6 总结　　　　<br>　第26章 应用框架<br>　　26.1 应用框架概览　　　　<br>　　　26.1.1 什么是应用框架　　　　<br>　　　26.1.2 应用框架的组成部分　　　　<br>　　　　26.1.2.1 类库　　　　<br>　　　　26.1.2.2 核心模块　　　　<br>　　　　26.1.2.3 环境配置　　　　<br>　　　　26.1.2.4 使用手册　　　　<br>　　26.2 为什么要设计应用框架　　　　<br>　　　26.2.1 应用框架的适用范围　　　　<br>　　　26.2.2 应用框架的利弊　　　　<br>　　26.3 如何设计应用框架　　　　<br>　　　26.3.1 把握设计的目标　　　　<br>　　　26.3.2 应用框架的设计准则　　　　<br>　　　26.3.3 什么样的应用框架才是成熟的应用框架　　　　<br>　　　26.3.4 应用框架的设计方法　　　　<br>　　　26.3.5 实战！设计一个简单的应用框架　　　　<br>　　　　26.3.5.1 自描述　　　　<br>　　　　26.3.5.2 基础接口和语义型代码　　　　<br>　　　　26.3.5.3 核心对象的原型扩展　　　　<br>　　　　26.3.5.4 简单方法　　　　<br>　　　　26.3.5.5 名字空间　　　　<br>　　　　26.3.5.6 支持标准和跨浏览器　　　　<br>　　　　26.3.5.7 事件模型–Silverna的事件模型　　　　<br>　　　　26.3.5.8 应用模式　　　　<br>　　　　26.3.5.9 提供Ajax组件　　　　<br>　　　　26.3.5.10 内存管理和其他　　　　<br>　　26.4 框架的实际应用–在Silverna 2.0框架上开发的Widgets　　　　<br>　　26.5 已存在的应用框架　　　　<br>　　　26.5.1 Prototype　　　　<br>　　　26.5.2 JQuery　　　　<br>　　　26.5.3 Dojo　　　　<br>　　　26.5.4 JSVM　　　　<br>　　　26.5.5 其他框架　　　　<br>　　　　26.5.5.1 Bindows（成立于2003年）　　　　<br>　　　　26.5.5.2 BackBase （成立于2003年）　　　　<br>　　　　26.5.5.3 DOJO （开发中，成立于2004年9月）　　　　<br>　　　　26.5.5.4 Open Rico（开发中，成立于2005年5月，基于早期的一个proprietary框架）　　　　<br>　　　　26.5.5.5 qooxdoo （开发中，成立于2005年5月）　　　　<br>　　　　26.5.5.6 Tibet （开发中，创建于2005年6月）　　　　<br>　　　　26.5.5.7 AJFORM （创建于2005年6月）　　　　<br>　　26.6 总结</p><h3 id="JavaScript王者归来-PDF-下载地址"><a href="#JavaScript王者归来-PDF-下载地址" class="headerlink" title="JavaScript王者归来 PDF 下载地址:"></a>JavaScript王者归来 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1f6yFAG-T_LVD-nmQorarhw?pwd=zfu2">https://pan.baidu.com/s/1f6yFAG-T_LVD-nmQorarhw?pwd=zfu2</a> </p><p>提取码: zfu2 </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript网页编程从入门到精通 》</title>
      <link href="/2023/10/07/JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
      <url>/2023/10/07/JavaScript%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231007100335.png" alt="《 JavaScript网页编程从入门到精通 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScript网页编程从入门到精通》紧跟技术发展的步伐，全面覆盖JavaScript的最新应用。《JavaScript网页编程从入门到精通》共3篇。第1篇是JavaScript语言的基础知识，详细介绍了有关JavaScript的基本技术要点。第2篇是JavaScript的实战提高。和第1篇一起，全面覆盖了传统JavaScript的所有应用层面。每一个知识点都包含详细的应用案例。这两篇合在一起，形成了“从入门到精通”的学习过程。第3篇是《JavaScript网页编程从入门到精通》的一个重点。JavaScript的最新应用就是Ajax，Ajax带动了Web 2.0的发展。如今对于一个开发人员来说，将无可避免地要运用Ajax技术。《JavaScript网页编程从入门到精通》经过前两篇的不断提升，在第3篇中把JavaScript的知识再提升一个层次。<br>在《JavaScript网页编程从入门到精通》中，我们除了讲解JavaScript的语言知识外，还特别安排了大量篇幅介绍目前流行的JavaScript开发工具。最后，作者给出9个特效实例，详细地展示JavaScript经典应用的开发过程。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>杨凡，资深Web技术专家，有10余年开发经验，是国内较早专业从事Web开发的一线技术人员和培训讲师。一直致力于对HTML5、JavaScript、CSS3、jQuery、jQUery Mobile等Web开发技术的研究和实践，在HTML页面的优化与用户体验的研究，以及页面框架搭建、数据流向分析、页面静态优化等方面都拥有丰富的实践经验。他还是微软技术方面的专家，精通C#、ASP．NET和SQL Server等技术。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 JavaScript概述<br>1.1 JavaScript发展历史<br>1.1.1 第一个网页脚本语言<br>1.1.2 Netscape发明了JavaScript<br>1.1.3 三足鼎立<br>1.1.4 ECMAScript诞生<br>1.2 JavaScript版本<br>1.3 ECMAScript概述<br>1.3.1 ECMAScript和JavaScript的关系<br>1.3.2 ECMAScript发展历史<br>1.4 JavaScript实现<br>1.4.1 JavaScript核心<br>1.4.2 文档对象模型<br>1.4.3 浏览器对象模型<br>1.5 JavaScript开发工具<br>1.5.1 JavaScript编辑器<br>1.5.2 JavaScript测试和调试<br>第2章 在网页中使用JavaScript<br>视频讲解：51分钟<br>2.1 使用<script>标签<br>2.1.1 编写第一个JavaScript程序<br>2.1.2 脚本位置<br>2.1.3 延迟执行脚本<br>2.1.4 异步响应脚本<br>2.1.5 在XHTML中使用JavaScript脚本<br>2.1.6 兼容不支持JavaScript的浏览器<br>2.2 比较嵌入代码与链接脚本<br>2.3 使用<noscript>标签<br>2.4 JavaScript执行顺序<br>2.4.1 正常执行顺序<br>2.4.2 预编译提前<br>2.4.3 代码块的执行顺序<br>2.4.4 事件响应顺序<br>2.4.5 动态输出脚本字符串<br>2.5 浏览器与JavaSc [1]<br>2.5.1浏览器内核<br>2.5.2浏览器错误报告<br>2.6JavaScript错误处理<br>2.6.1使用try-catch<br>2.6.2使用finally<br>2.6.3错误类型<br>2.6.4抛出错误<br>2.6.5案例：设计抛出错误时机<br>2.6.6错误事件<br>2.6.7错误类型<br>2.6.8案例：记录错误<br>2.7JavaScript代码调试<br>2.7.1使用控制台<br>2.7.2显示错误信息<br>2.7.3抛出错误<br>2.7.4IE错误<br>第3章JavaScript基本语法<br>视频讲解：36分钟<br>3.1词法基础<br>3.1.1字符编码<br>3.1.2大小写敏感<br>3.1.3标识符<br>3.1.4直接量<br>3.1.5关键字和保留字<br>3.1.6分隔符<br>3.1.7注释<br>3.1.8转义序列<br>3.2句法基础<br>3.2.1认识词、句和段<br>3.2.2分号<br>3.2.3大括号<br>第4章数据、类型和变量<br>视频讲解：109分钟<br>4.1JavaScript数据类型概述<br>4.1.1JavaScript数据类型的特点<br>4.1.2JavaScript的基本数据类型<br>4.1.3值类型和引用类型<br>4.2值类型数据<br>4.2.1数值<br>4.2.2字符串<br>4.2.3布尔值<br>4.2.4Null<br>4.2.5Undefined<br>4.3引用型数据<br>4.3.1数组<br>4.3.2对象<br>4.3.3函数<br>4.4数据类型检测<br>4.4.1使用typeof<br>4.4.2使用constructor<br>4.4.3案例：在框架窗口检测数组类型<br>4.4.4案例：设计完善的数据类型检测工具<br>4.5数据类型转换<br>4.5.1值类型转换<br>4.5.2引用型转换<br>4.5.3转换为字符串<br>4.5.4案例：转换数字模式<br>4.5.5案例：设置数字转换为字符串的小数位数<br>4.5.6转换为数字<br>4.5.7转换为布尔值<br>4.5.8案例：装箱和拆箱<br>4.5.9案例：强制转换<br>4.6使用变量<br>4.6.1声明变量<br>4.6.2变量的作用域<br>4.6.3变量的作用域链<br>4.6.4变量回收<br>4.6.5案例：变量污染<br>4.7案例实战<br>4.7.1代码题<br>4.7.2编程题<br>第5章运算符和表达式<br>视频讲解：113分钟<br>5.1运算符和表达式概述<br>5.1.1认识运算符<br>5.1.2使用运算符<br>5.1.3认识表达式<br>5.1.4案例：优化表达式<br>5.2位运算符<br>5.2.1位运算概述<br>5.2.2逻辑位运算<br>5.2.3移位运算<br>5.3算术运算符<br>5.3.1加法运算<br>5.3.2减法运算<br>5.3.3乘法运算<br>5.3.4除法运算<br>5.3.5余数运算<br>5.3.6取反运算<br>5.3.7递增和递减<br>5.4逻辑运算符<br>5.4.1逻辑与运算符<br>5.4.2逻辑或运算符<br>5.4.3逻辑非运算符<br>5.4.4案例：逻辑运算训练<br>5.5关系运算符<br>5.5.1大小比较<br>5.5.2案例：包含检测<br>5.5.3案例：等值检测<br>5.6赋值运算符<br>5.7对象操作运算符<br>5.7.1new运算符<br>5.7.2delete运算符<br>5.7.3中括号和点号运算符<br>5.7.4小括号运算符<br>5.8其他运算符<br>5.8.1条件运算符<br>5.8.2逗号运算符<br>5.8.3void运算符<br>5.8.4typeof运算符<br>5.9案例实战<br>5.9.1表达式计算<br>5.9.2表达式描述<br>5.9.3编程题<br>第6章语句和结构<br>视频讲解：122分钟<br>6.1语句概述<br>6.2简单语句<br>6.2.1表达式语句<br>6.2.2复合语句<br>6.2.3声明语句<br>6.2.4空语句<br>6.3分支结构<br>6.3.1if语句<br>6.3.2条件嵌套<br>6.3.3案例：优化条件结构<br>6.3.4案例：条件误用<br>6.3.5switch语句<br>6.3.6default从句<br>6.3.7案例：比较if和switch<br>6.3.8案例：优化分支结构<br>6.4循环结构<br>6.4.1while语句<br>6.4.2do/while语句<br>6.4.3for语句<br>6.4.4for/in语句<br>6.4.5案例：使用for/in<br>6.4.6案例：比较while和for<br>6.4.7案例：优化循环结构<br>6.5结构跳转<br>6.5.1标签语句<br>6.5.2break语句<br>6.5.3continue语句<br>6.6异常处理<br>6.6.1异常概述<br>6.6.2throw语句<br>6.6.3try/catch/finally语句<br>6.6.4案例：改变作用域链<br>6.7函数结构<br>6.7.1function语句<br>6.7.2return语句<br>6.8with语句<br>6.9案例实战<br>6.9.1编程题<br>6.9.2提升条件检测性能<br>6.9.3提升循环迭代性能<br>6.9.4设计杨辉三角<br>第7章操作字符串<br>视频讲解：93分钟<br>7.1定义字符串<br>7.1.1字符串直接量<br>7.1.2构造字符串<br>7.1.3使用字符编码<br>7.2使用字符串<br>7.2.1案例：计算字符串长度<br>7.2.2案例：连接字符串 [2]<br>7.2.3案例：查找字符串<br>7.2.4案例：截取子字符串<br>7.2.5案例：编辑字符串<br>7.2.6案例：灵活使用replace()方法<br>7.2.7案例：比较字符串<br>7.2.8案例：把字符串转换为数组<br>7.2.9案例：字符串的类型和值<br>7.2.10案例：格式化字符串<br>7.3案例实战<br>7.3.1修剪字符串<br>7.3.2检测特殊字符<br>7.3.3优化字符串连接<br>7.4加密和解密<br>7.4.1JavaScript编码和解码<br>7.4.2案例：Unicode编码<br>7.4.3案例：Unicode解码<br>7.4.4综合实战：自定义加密和解密方法<br>第8章使用正则表达式<br>视频讲解：102分钟<br>8.1认识正则表达式<br>8.2定义正则表达式<br>8.2.1构造正则表达式<br>8.2.2正则表达式直接量<br>8.3字符匹配<br>8.3.1认识普通字符和元字符<br>8.3.2字符直接量<br>8.3.3简单字符类<br>8.3.4反义字符类<br>8.3.5字符范围类<br>8.3.6预定义字符类<br>8.4重复匹配<br>8.4.1简单重复性匹配<br>8.4.2贪婪匹配<br>8.4.3惰性匹配<br>8.4.4支配匹配<br>8.5高级匹配<br>8.5.1分组<br>8.5.2案例：分组应用<br>8.5.3引用<br>8.5.4案例：非引用型分组<br>8.5.5选择<br>8.5.6声明<br>8.5.7边界<br>8.5.8锚记<br>8.5.9标志<br>8.6使用RegExp对象<br>8.6.1实例属性<br>8.6.2静态属性<br>8.6.3案例应用<br>8.7综合案例：设计表单验证<br>第9章操作数组<br>视频讲解：134分钟<br>9.1定义数组<br>9.1.1构造数组<br>9.1.2数组直接量<br>9.2使用数组<br>9.2.1存取数组元素<br>9.2.2数组长度<br>9.2.3案例：比较对象与数组<br>9.2.4案例：定义多维数组<br>9.3数组的应用<br>9.3.1案例：检索数组<br>9.3.2案例：添删元素<br>9.3.3案例：操作子数组<br>9.3.4案例：数组排序<br>9.3.5案例：使用数组排序函数<br>9.3.6案例：数组与字符串转换<br>9.4案例实战<br>9.4.1快速交换<br>9.4.2数组下标<br>9.4.3扩展数组方法<br>9.4.4设计迭代器<br>9.4.5使用迭代器<br>9.4.6使用数组维度<br>9.5综合实践：排序算法设计<br>9.5.1插入排序<br>9.5.2二分插入排序<br>9.5.3选择排序<br>9.5.4冒泡排序<br>9.5.5快速排序<br>9.5.6计数排序<br>第10章使用对象<br>视频讲解：79分钟<br>10.1认识对象<br>10.2对象分类<br>10.2.1原生对象<br>10.2.2宿主对象<br>10.3对象基本操作<br>10.3.1创建对象<br>10.3.2引用对象<br>10.3.3销毁对象<br>10.4属性基本操作<br>10.4.1定义属性<br>10.4.2访问属性<br>10.4.3赋值和删除属性<br>10.4.4对象方法<br>10.5原生对象类型<br>10.5.1构造对象<br>10.5.2实例对象<br>10.5.3原型对象<br>10.6使用构造器<br>10.7使用对象基本方法<br>10.7.1案例：重写toString<br>10.7.2案例：重写valueOf<br>10.7.3案例：检测私有属性<br>10.7.4案例：检测枚举属性<br>10.7.5案例：检测原型对象<br>10.8使用原生对象<br>10.8.1Global对象<br>10.8.2Math对象<br>10.8.3Date对象<br>10.9综合案例：设计计算器<br>第11章使用函数<br>视频讲解：117分钟<br>11.1认识函数<br>11.1.1函数是代码块<br>11.1.2函数是数据<br>11.1.3函数是对象<br>11.2定义函数<br>11.2.1构造函数<br>11.2.2函数直接量<br>11.2.3定义嵌套函数<br>11.3案例：优化函数定义<br>11.3.1函数作用域<br>11.3.2解析机制<br>11.3.3兼容性和灵活性<br>11.4使用函数<br>11.4.1函数返回值<br>11.4.2调用函数<br>11.4.3函数生命周期<br>11.4.4函数作用域<br>11.5使用参数<br>11.5.1认识形参和实参<br>11.5.2使用Arguments对象<br>11.5.3使用callee回调函数<br>11.5.4案例实战<br>11.6使用Function对象<br>11.6.1获取函数形参个数<br>11.6.2自定义属性<br>11.6.3案例：使用call()和apply()<br>11.7函数解析机制<br>11.7.1词法作用域与执行作用域<br>11.7.2执行上下文和作用域链<br>11.7.3调用对象<br>11.8函数中的this<br>11.8.1案例：认识this<br>11.8.2案例：使用this<br>11.8.3案例：this安全策略<br>11.8.4案例：this应用<br>11.9案例实战<br>11.9.1函数调用模式<br>11.9.2扩展函数方法<br>11.9.3绑定函数<br>11.9.4链式语法<br>11.9.5函数节流<br>11.9.6使用Arguments模拟重载<br>第12章函数式编程<br>视频讲解：116分钟<br>12.1函数式编程概述<br>12.1.1函数是第一型<br>12.1.2函数是运算元<br>12.1.3函数是数据闭包<br>12.2表达式运算<br>12.2.1连续运算<br>12.2.2把命令转换为表达式<br>12.2.3表达式中的函数<br>12.3递归运算<br>12.3.1认识递归<br>12.3.2案例：Hanoi（汉诺）塔算法<br>12.3.3案例：尾递归算法<br>12.3.4案例：Fibonacci（斐波那契）数列<br>12.3.5递归算法的优化<br>12.4闭包函数<br>12.4.1认识闭包函数<br>12.4.2使用闭包<br>12.4.3闭包标识系统<br>12.4.4闭包作用域和生命周期<br>12.4.5案例：比较函数调用和引用<br>12.4.6案例：比较闭包函数和函数实例<br>12.4.7案例：比较闭包函数和调用对象<br>12.4.8案例：保护闭包数据的独立性<br>12.4.9案例：定义构造函数闭包<br>12.4.10案例：闭包存储器<br>12.4.11案例：事件处理中闭包应用<br>12.4.12综合案例：设计折叠面板<br>12.4.13案例：在循环体和异步回调中慎重使用闭包<br>12.5案例实战<br>12.5.1惰性求值<br>12.5.2记忆<br>12.5.3套用<br>12.5.4模块化<br>12.5.5柯里化<br>12.5.6高阶函数<br>第13章面向对象编程<br>视频讲解：109分钟<br>13.1认识类<br>13.2定义类<br>13.2.1案例：工厂模式<br>13.2.2案例：构造函数模式<br>13.2.3案例：原型模式<br>13.2.4案例：构造函数原型模式<br>13.2.5案例：动态原型模式<br>13.3接口<br>13.3.1认识接口<br>13.3.2定义接口<br>13.3.3使用建议<br>13.4原型模型<br>13.4.1认识prototype<br>13.4.2定义原型<br>13.4.3案例：原型属性和本地属性<br>13.4.4案例：应用原型<br>13.4.5认识原型域和原型域链<br>13.4.6原型副作用<br>13.5继承<br>13.5.1认识JavaScript继承机制<br>13.5.2原型继承<br>13.5.3类继承<br>13.5.4案例：封装类继承模式<br>13.5.5实例继承<br>13.5.6复制继承<br>13.5.7克隆继承<br>13.5.8混合继承<br>13.5.9多重继承<br>13.5.10掺元类<br>13.6封装<br>13.6.1被动封装<br>13.6.2主动封装<br>13.6.3静态方法<br>13.7多态<br>13.7.1案例：方法重载和覆盖<br>13.7.2案例：类的多态<br>13.8构造和析构<br>13.8.1案例：构造函数<br>13.8.2案例：析构函数<br>13.9案例实战<br>13.9.1惰性实例化<br>13.9.2安全构造对象<br>13.9.3设计超类和子类<br>13.9.4设计元类<br>13.9.5分支函数<br>13.9.6惰性载入函数<br>第14章BOM<br>视频讲解：43分钟<br>14.1认识BOM<br>14.2使用Window对象<br>14.2.1全局作用域<br>14.2.2Window对象生命周期<br>14.2.3人机交互接口<br>14.2.4案例：控制弹出窗口<br>14.2.5案例：框架集通信<br>14.3使用Navigator对象<br>14.3.1了解浏览器检测方法<br>14.3.2案例：检测浏览器类型和版本<br>14.3.3案例：检测客户端操作系统<br>14.4使用Location和History对象<br>14.4.1案例：使用Location对象<br>14.4.2使用History对象<br>14.5使用Screen对象<br>14.5.1案例：使用Screen对象控制窗口大小<br>14.5.2案例：使用Window对象控制窗口大小<br>14.6使用Document对象<br>14.6.1认识Document<br>14.6.2使用0级文档模型操作文档<br>14.6.3案例：动态生成文档 [2]<br>第15章DOM<br>视频讲解：116分钟<br>15.1认识DOM<br>15.2使用节点<br>15.2.1节点类型<br>15.2.2节点名称和值<br>15.2.3节点关系<br>15.2.4案例：访问节点<br>15.2.5案例：操作节点<br>15.3使用文档节点<br>15.3.1访问文档子节点<br>15.3.2访问文档信息<br>15.3.3访问文档元素<br>15.3.4使用HTML5Document<br>15.4使用元素节点<br>15.4.1访问元素<br>15.4.2案例：遍历元素<br>15.4.3创建元素<br>15.4.4案例：复制节点<br>15.4.5案例：插入节点<br>15.4.6案例：删除节点<br>15.4.7案例：替换节点<br>15.5使用文本节点<br>15.5.1访问文本节点<br>15.5.2创建文本节点<br>15.5.3操作文本节点<br>15.5.4读取HTML字符串<br>15.5.5案例：插入HTML字符串<br>15.5.6案例：替换HTML字符串<br>15.5.7案例：插入文本<br>15.6使用文档片段节点<br>15.7使用属性节点<br>15.7.1访问属性节点<br>15.7.2案例：读取属性值<br>15.7.3案例：设置属性值<br>15.7.4案例：删除属性<br>15.7.5案例：使用类选择器<br>15.7.6自定义属性<br>15.8使用范围<br>15.8.1创建范围<br>15.8.2案例：选择范围<br>15.8.3案例：设置范围<br>15.8.4案例：操作范围内容<br>15.8.5案例：插入范围内容<br>15.9使用CSS选择器<br>第16章事件处理<br>视频讲解：93分钟<br>16.1事件概述<br>16.1.1事件模型分类<br>16.1.2事件流<br>16.1.3事件类型<br>16.2基本事件模型<br>16.2.1基本事件类型<br>16.2.2绑定事件<br>16.2.3事件处理函数的返回值<br>16.2.4事件处理函数的参数<br>16.2.5事件处理函数中的this<br>16.3标准事件模型<br>16.3.1事件传播<br>16.3.2注册事件<br>16.3.3注销事件<br>16.3.4事件类型<br>16.3.5Event对象<br>16.4IE事件模型<br>16.4.1注册和销毁事件<br>16.4.2Event对象<br>16.5鼠标事件开发<br>16.5.1鼠标点击<br>16.5.2案例：鼠标移动<br>16.5.3案例：鼠标经过<br>16.5.4案例：鼠标来源<br>16.5.5案例：鼠标定位<br>16.5.6鼠标按键<br>16.6键盘事件开发<br>16.6.1认识键盘事件的属性<br>16.6.2键盘事件响应顺序<br>16.7页面事件开发<br>16.7.1页面初始化<br>16.7.2结构初始化<br>16.7.3页面卸载<br>16.7.4窗口重置<br>16.7.5页面滚动<br>16.7.6错误处理<br>16.8UI事件开发<br>16.9表单事件开发<br>16.9.1选择文本<br>16.9.2监测值变化<br>16.9.3提交表单<br>16.9.4重置表单<br>16.10案例实战：自定义事件<br>16.10.1设计弹出对话框<br>16.10.2设计遮罩层<br>16.10.3定义事件雏形<br>16.10.4设计事件触发模型<br>16.10.5应用事件模型<br>第17章脚本化CSS<br>视频讲解：117分钟<br>17.1脚本化CSS概述<br>17.1.1认识CSS脚本属性<br>17.1.2CSS样式模型概述<br>17.2操作行内样式<br>17.2.1CSS脚本属性名规范<br>17.2.2使用style对象<br>17.3操作样式表<br>17.3.1使用styleSheets对象<br>17.3.2访问样式表中的样式<br>17.3.3读取样式的选择符<br>17.3.4编辑样式<br>17.3.5添加样式<br>17.3.6访问显示样式<br>17.4控制大小<br>17.4.1案例：从样式表中读取宽度和高度<br>17.4.2案例：把样式属性值转换为实际值<br>17.4.3案例：使用offsetWidth和offsetHeight<br>17.4.4案例：复杂环境下的元素尺寸<br>17.4.5案例：可视区域尺寸<br>17.4.6案例：浏览器窗口尺寸<br>17.5位移和定位<br>17.5.1案例：获取窗口位置<br>17.5.2案例：获取相对包含框的位置<br>17.5.3案例：获取定位包含框的位置<br>17.5.4案例：设置元素的偏移位置<br>17.5.5案例：设置元素的相对位置<br>17.5.6案例：获取鼠标指针的页面位置<br>17.5.7案例：获取鼠标指针在元素内的位置<br>17.5.8案例：获取页面滚动条的位置<br>17.5.9案例：设置页面滚动条的位置<br>17.6显示和隐藏<br>17.6.1案例：可见性<br>17.6.2案例：透明度<br>17.7设计动画<br>17.7.1定时器<br>17.7.2案例：滑动<br>17.7.3案例：渐隐渐显<br>第18章HTML5动画设计<br>视频讲解：84分钟<br>18.1HTML5canvas概述<br>18.1.1在页面中添加canvas元素<br>18.1.2Canvas如何绘制图形<br>18.1.3认识Canvas坐标<br>18.1.4何时不用Canvas<br>18.1.5如果浏览器不支持Canvas<br>18.1.6检测浏览器支持<br>18.2绘制基本图形<br>18.2.1绘制直线<br>18.2.2绘制矩形<br>18.2.3绘制圆形<br>18.2.4绘制三角形<br>18.2.5清空画布<br>18.3绘制曲线<br>18.3.1绘制二次方贝塞尔曲线<br>18.3.2绘制三次方贝塞尔曲线<br>18.4变换图形<br>18.4.1保存与恢复Canvas状态<br>18.4.2移动坐标空间<br>18.4.3旋转坐标空间<br>18.4.4缩放图形<br>18.4.5矩阵变换<br>18.5组合和裁切图形<br>18.5.1组合图形<br>18.5.2裁切路径<br>18.6定义颜色和样式<br>18.6.1应用线型<br>18.6.2绘制线性渐变<br>18.6.3绘制径向渐变<br>18.6.4绘制图案<br>18.6.5设置图形的透明度<br>18.6.6创建阴影<br>18.7绘制文字<br>18.7.1绘制填充文字<br>18.7.2设置文字属性<br>18.7.3绘制轮廓文字<br>18.7.4测量文字宽度<br>18.8嵌入图像<br>18.8.1向Canvas中引入图像<br>18.8.2改变图像大小<br>18.8.3创建图像切片 [2]<br>第19章Web存储<br>视频讲解：69分钟<br>19.1Cookie概述<br>19.1.1认识Cookie<br>19.1.2Cookie字符串<br>19.2存取Cookie<br>19.2.1写入Cookie<br>19.2.2设置Cookie有效期<br>19.2.3设置Cookie的域和路径<br>19.2.4设置Cookie安全传输<br>19.2.5案例：完善写入Cookie方法<br>19.2.6读取Cookie信息<br>19.2.7修改和删除Cookie信息<br>19.2.8Cookie的局限性及其突破<br>19.3综合案例：Cookie应用<br>19.3.1封装Cookie<br>19.3.2打字游戏<br>19.4WebStorage概述<br>19.4.1Cookie存储机制的优缺点<br>19.4.2为什么要用WebStorage<br>19.4.3WebStorage的优势和缺点<br>19.4.4浏览器支持概述<br>19.5使用WebStorage<br>19.5.1检查浏览器的支持性<br>19.5.2设置和获取数据<br>19.5.3防止数据泄露<br>19.5.4WebStorage其他用法<br>19.5.5WebStorage事件监测<br>19.5.6案例1：设计网页皮肤<br>19.5.7案例2：跟踪localStorage数据<br>19.5.8案例3：设计计数器<br>19.5.9综合案例：Web应用项目实时跟踪<br>19.6WebSQL数据库<br>19.6.1WebSQL数据库概述<br>19.6.2使用WebSQL数据库<br>19.6.3实例1：创建简单的本地数据库<br>19.6.4实例2：批量存储本地数据<br>19.6.5综合案例：WebStorage和WebSQL混合开发<br>第20章JavaScript通信<br>视频讲解：69分钟<br>20.1HTTP概述<br>20.2使用隐藏框架<br>20.2.1认识隐藏框架<br>20.2.2案例：使用隐藏框架<br>设计异步交互<br>20.2.3使用iframe<br>20.3使用JSONP<br>20.3.1认识<script>标签<br>20.3.2案例：脚本化script元素<br>20.3.3案例：传递参数<br>20.3.4案例：设计响应类型<br>20.4使用Ajax<br>20.4.1认识XMLHttpRequest<br>20.4.2定义XMLHttpRequest对象<br>20.4.3建立XMLHttpRequest连接<br>20.5发送请求<br>20.5.1发送GET请求<br>20.5.2发送POST请求<br>20.5.3案例：把数据转换为串行字符串<br>20.6异步监测<br>20.6.1跟踪状态<br>20.6.2中止请求<br>20.7获取响应<br>20.7.1XML<br>20.7.2HTML<br>20.7.3JavaScript<br>20.7.4JSON<br>20.7.5Text<br>20.7.6获取头部消息<br>20.8案例实战<br>20.8.1封装异步交互<br>20.8.2设计动态响应的Tab面板<br>20.8.3使用灯标<br>第21章XML<br>视频讲解：26分钟<br>21.1XML概述<br>21.2XML文档对象模型<br>21.2.1认识XMLDOM<br>21.2.2读取XML<br>21.3在IE中操作XML<br>21.3.1创建XMLDOM对象<br>21.3.2加载XML数据<br>21.3.3错误处理<br>21.4使用DOM2操作XML<br>21.4.1创建XMLDOM对象<br>21.4.2加载XML数据<br>21.4.3读取XML数据<br>21.5使用XPath<br>21.5.1熟悉XPath基本语法<br>21.5.2IE中的XPath<br>21.5.3DOM3中的XPath<br>21.6案例实战<br>21.6.1在网页中显示XML数据<br>21.6.2异步加载XML数据<br>第22章JSON<br>22.1JSON概述<br>22.2比较JSON与XML<br>22.3JSON语法<br>22.3.1简单值<br>22.3.2对象<br>22.3.3数组<br>22.4JSON解析和序列化<br>22.5案例：优化JSON数据<br>第23章ECMAScript5<br>视频讲解：74分钟<br>23.1ECMAScript5概述<br>23.2浏览器支持<br>23.3严格模式<br>23.3.1启用严格模式<br>23.3.2严格模式的执行限制<br>23.4JSON<br>23.4.1案例：解析JSON<br>23.4.2案例：序列化JSON<br>23.5Object<br>23.5.1创建对象<br>23.5.2定义属性<br>23.5.3访问属性<br>23.5.4配置属性的特性<br>23.5.5检测属性的特性<br>23.6Array<br>23.6.1定位<br>23.6.2迭代<br>23.6.3汇总<br>23.7Function和String<br>第24章ECMAScript6<br>24.1ECMAScript6概述<br>24.1.1兼容性<br>24.1.2使用ECMAScript6<br>24.2变量<br>24.2.1let命令<br>24.2.2const命令<br>24.2.3数组解构赋值<br>24.2.4对象解构赋值<br>24.2.5案例：解构应用<br>24.3字符和字符串<br>24.3.1字符<br>24.3.2字符串<br>24.3.3模板字符串<br>24.4数值<br>24.4.1进制表示<br>24.4.2Number方法<br>24.4.3Math方法<br>24.5数组<br>24.5.1转换<br>24.5.2实例<br>24.5.3推导<br>24.5.4监听<br>24.6对象<br>24.6.1新增方法<br>24.6.2原型方法<br>24.6.3增强语法<br>24.6.4属性名表达式<br>24.6.5符号数据<br>24.6.6代理防护层<br>24.6.7监听<br>24.7函数<br>24.7.1默认值<br>24.7.2rest参数<br>24.7.3扩展运算符<br>24.7.4箭头函数<br>24.8数据结构<br>24.8.1Set<br>24.8.2WeakSet<br>24.8.3Map<br>24.8.4WeakMap<br>24.9循环遍历<br>24.9.1遍历器<br>24.9.2for/of循环<br>24.10状态机<br>24.10.1使用Generator函数<br>24.10.2next()方法<br>24.10.3异步操作<br>24.10.4forof循环<br>24.10.5throw方法<br>24.10.6yield*语句<br>24.11预处理<br>24.11.1基本用法<br>24.11.2then()方法<br>24.11.3catch()方法<br>24.11.4all()和race()方法<br>24.11.5resolve()和reject()方法<br>24.11.6async函数<br>24.12类和模块<br>24.12.1类<br>24.12.2模块<br>第25章移动定位<br>25.1位置信息概述<br>25.1.1为什么要学习Geolocation<br>25.1.2位置信息表示方式<br>25.1.3位置信息来源<br>25.1.4IP定位<br>25.1.5GPS定位<br>25.1.6Wi-Fi定位<br>25.1.7手机定位<br>25.1.8自定义定位<br>25.2使用GeolocationAPI<br>25.2.1检查浏览器支持性<br>25.2.2获取当前地理位置<br>25.2.3监视位置信息<br>25.2.4停止获取位置信息<br>25.2.5隐私保护<br>25.2.6处理位置信息<br>25.2.7使用position对象<br>25.3案例实战<br>25.3.1使用Google地图<br>25.3.2跟踪行走速度<br>第26章多线程处理<br>视频讲解：25分钟<br>26.1WebWorkers概述<br>26.1.1认识WebWorkers<br>26.1.2浏览器支持概述<br>26.1.3熟悉WebWorkers成员<br>26.2使用WebWorkers<br>26.2.1检查浏览器支持性<br>26.2.2创建WebWorkers<br>26.2.3与WebWorkers通信<br>26.2.4案例：使用WebWorkers<br>26.3案例实战<br>26.3.1使用多线程实现后台运算<br>26.3.2在后台过滤值<br>26.3.3多任务并发处理<br>26.3.4在多线程之间通信<br>26.3.5使用线程技术计算Fibonacci数列<br>26.3.6使用多线程绘图<br>26.4综合案例：模拟退火算法<br>26.4.1认识模拟退火算法<br>26.4.2编写应用主页面<br>26.4.3编写Worker.js<br>26.4.4与WebWorker通信<br>第27章离线应用<br>视频讲解：21分钟<br>27.1HTML5离线应用概述<br>27.1.1为什么要学习HTML5离线应用<br>27.1.2浏览器支持概述<br>27.2HTML5离线应用详解<br>27.2.1解析manifest文件<br>27.2.2搭建离线应用程序<br>27.2.3检查浏览器是否支持<br>27.2.4离线缓存更新实现<br>27.2.5JavaScript接口实现<br>27.2.6离线存储事件监听<br>27.3案例实战：缓存首页<br>27.4案例实战：离线编辑内容<br>27.5案例实战：离线跟踪<br>第28章案例开发<br>视频讲解：23分钟<br>28.1设计小程序：万年历<br>28.2设计游戏：俄罗斯方块<br>28.2.1设计游戏界面<br>28.2.2设计游戏模型<br>28.2.3实现游戏功能 </p><h3 id="JavaScript网页编程从入门到精通-PDF-下载地址"><a href="#JavaScript网页编程从入门到精通-PDF-下载地址" class="headerlink" title="JavaScript网页编程从入门到精通 PDF 下载地址:"></a>JavaScript网页编程从入门到精通 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1vGjrgQmk5ScaoB_2nPFiUg?pwd=wt27">https://pan.baidu.com/s/1vGjrgQmk5ScaoB_2nPFiUg?pwd=wt27</a> </p><p>提取码: wt27 </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript语言精粹(修订版) 》</title>
      <link href="/2023/10/07/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9(%E4%BF%AE%E8%AE%A2%E7%89%88)/"/>
      <url>/2023/10/07/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9(%E4%BF%AE%E8%AE%A2%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928174936.png" alt="《 JavaScript语言精粹(修订版) 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>JavaScript 曾是“世界上最被误解的语言”，因为它担负太多的特性，包括糟糕的交互和失败的设计，但随着Ajax 的到来，JavaScript“从最受误解的编程语言演变为最流行的语言”，这除了幸运之外，也证明了它其实是一门优秀的语言。Douglas Crockford 在本书中剥开了JavaScript 沾污的外衣，抽离出一个具有更好可靠性、可读性和可维护性的JavaScript 子集，让你看到一门优雅的、轻量级的和非常富有表现力的语言。作者从语法、对象、函数、继承、数组、正则表达式、方法、样式和优美的特性这9 个方面来呈现这门语言真正的精华部分，通过它们完全可以构建出优雅高效的代码。作者还通过附录列出了这门语言的毒瘤和糟粕部分，且告诉你如何避免它们。最后还介绍了JSLint，通过它的检验，能有效地保障我们的代码品质。</p><p>这是一本介绍 JavaScript 语言本质的权威书籍，值得任何正在或准备从事JavaScript 开发的人阅读，并且需要反复阅读。学习、理解、实践大师的思想，我们才可能站在巨人的肩上，才有机会超越大师，这本书就是开始。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Douglas Crockford是一名来自Yahoo!的资深JavaScript架构师，以创造和维护JSON (JavaScriptObject Notation) 格式而为大家所熟知。他定期在各类会议上发表有关高级JavaScript的主题演讲。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言………………………………………………………………………………………………………………..xv<br>第1 章 精华…………………………………………………………………………………………………… 1<br>为什么要使用JavaScript ………………………………………………………………………………………….2<br>分析JavaScript……………………………………………………………………………………………………….2<br>一个简单的试验场…………………………………………………………………………………………………..4<br>第2 章 语法…………………………………………………………………………………………………… 5<br>空白………………………………………………………………………………………………………………………5<br>标识符…………………………………………………………………………………………………………………..6<br>数字………………………………………………………………………………………………………………………7<br>字符串…………………………………………………………………………………………………………………..8<br>语句…………………………………………………………………………………………………………………….10<br>表达式…………………………………………………………………………………………………………………15<br>字面量…………………………………………………………………………………………………………………18<br>函数…………………………………………………………………………………………………………………….19<br>第3 章 对象…………………………………………………………………………………………………. 20<br>对象字面量…………………………………………………………………………………………………………..20<br>检索…………………………………………………………………………………………………………………….21<br>更新…………………………………………………………………………………………………………………….22<br>引用…………………………………………………………………………………………………………………….22<br>原型…………………………………………………………………………………………………………………….22<br>反射…………………………………………………………………………………………………………………….23<br>枚举…………………………………………………………………………………………………………………….24<br>删除…………………………………………………………………………………………………………………….24<br>减少全局变量污染…………………………………………………………………………………………………25<br>第4 章 函数…………………………………………………………………………………………………. 26<br>函数对象………………………………………………………………………………………………………………26<br>函数字面量…………………………………………………………………………………………………………..27<br>调用…………………………………………………………………………………………………………………….27<br>参数…………………………………………………………………………………………………………………….30<br>返回…………………………………………………………………………………………………………………….31<br>异常…………………………………………………………………………………………………………………….31<br>扩充类型的功能…………………………………………………………………………………………………….32<br>递归…………………………………………………………………………………………………………………….33<br>作用域…………………………………………………………………………………………………………………36<br>闭包…………………………………………………………………………………………………………………….36<br>回调…………………………………………………………………………………………………………………….39<br>模块…………………………………………………………………………………………………………………….40<br>级联…………………………………………………………………………………………………………………….42<br>柯里化…………………………………………………………………………………………………………………43<br>记忆…………………………………………………………………………………………………………………….43<br>第5 章 继承………………………………………………………………………………………………….. 46<br>伪类…………………………………………………………………………………………………………………….46<br>对象说明符…………………………………………………………………………………………………………..49<br>原型…………………………………………………………………………………………………………………….50<br>函数化…………………………………………………………………………………………………………………51<br>部件…………………………………………………………………………………………………………………….55<br>第6 章 数组………………………………………………………………………………………………….. 57<br>数组字面量…………………………………………………………………………………………………………..57<br>长度…………………………………………………………………………………………………………………….58<br>删除…………………………………………………………………………………………………………………….59<br>枚举…………………………………………………………………………………………………………………….59<br>容易混淆的地方…………………………………………………………………………………………………….60<br>方法…………………………………………………………………………………………………………………….60<br>指定初始值…………………………………………………………………………………………………………..62<br>第7 章 正则表达式……………………………………………………………………………………….. 64<br>一个例子………………………………………………………………………………………………………………65<br>结构…………………………………………………………………………………………………………………….69<br>元素…………………………………………………………………………………………………………………….71<br>第8 章 方法………………………………………………………………………………………………….. 77<br>Array ……………………………………………………………………………………………………………………77<br>Function ……………………………………………………………………………………………………………….83<br>Number ………………………………………………………………………………………………………………..84<br>Object…………………………………………………………………………………………………………………..85<br>RegExp ………………………………………………………………………………………………………………..86<br>String……………………………………………………………………………………………………………………88<br>第9 章 代码风格………………………………………………………………………………………….. 94<br>第10 章 优美的特性……………………………………………………………………………………… 98<br>附录A 毒瘤………………………………………………………………………………………………… 101<br>附录B 糟粕………………………………………………………………………………………………… 109<br>附录C JSLint ………………………………………………………………………………………………. 115<br>附录D 语法图…………………………………………………………………………………………….. 127<br>附录E JSON………………………………………………………………………………………………… 138<br>索引……………………………………………………………………………………………………………… 149</p><h3 id="JavaScript语言精粹-修订版-PDF-下载地址"><a href="#JavaScript语言精粹-修订版-PDF-下载地址" class="headerlink" title="JavaScript语言精粹(修订版) PDF 下载地址:"></a>JavaScript语言精粹(修订版) PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1rHkT2CW99L6JGOQSGHIu_w?pwd=riec">https://pan.baidu.com/s/1rHkT2CW99L6JGOQSGHIu_w?pwd=riec</a> </p><p>提取码: riec </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 JavaScript高级程序设计（第3版） 》</title>
      <link href="/2023/10/07/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89/"/>
      <url>/2023/10/07/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928155229.png" alt="《 JavaScript高级程序设计（第3版） 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是JavaScript 超级畅销书的最新版。ECMAScript 5 和HTML5 在标准之争中双双胜出，使大量专有实现和客户端扩展正式进入规范，同时也为JavaScript 增添了很多适应未来发展的新特性。本书这一版除增加5 章全新内容外，其他章节也有较大幅度的增补和修订，新内容篇幅约占三分之一。全书从JavaScript 语言实现的各个组成部分——语言核心、DOM、BOM、事件模型讲起，深入浅出地探讨了面向对象编程、Ajax 与Comet 服务器端通信，HTML5 表单、媒体、Canvas（包括WebGL）及Web Workers、地理定位、跨文档传递消息、客户端存储（包括IndexedDB）等新API，还介绍了离线应用和与维护、性能、部署相关的最佳开发实践。本书附录展望了未来的API 和ECMAScript Harmony 规范。</p><p>本书适合有一定编程经验的Web 应用开发人员阅读，也可作为高校及社会实用技术培训相关专业课程的教材。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Nicholas C. Zakas（尼古拉斯•泽卡斯）世界顶级Web技术专家，现为雅虎公司界面呈现架构师，负责My Yahoo!和雅虎首页等大访问量站点的设计。尼古拉斯拥有丰富的Web开发和界面设计经验，曾经参与许多世界级大公司的Web解决方案开发。他还是High Performance JavaScript一书的作者，并与他人合作撰写了Professional Ajax和Even Faster Web Sites。尼古拉斯拥有梅里马克学院计算机科学学士学位和埃迪柯特学院的MBA学位。他的个人网站是<a href="http://www.nczonline.net%EF%BC%8C%E4%BB%96%E7%9A%84Twitter%E5%88%AB%E5%90%8D%E6%98%AF@slicknet./">www.nczonline.net，他的Twitter别名是@slicknet。</a></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　JavaScript简介　　1<br>1.1　JavaScript简史　　1<br>1.2　JavaScript实现　　2<br>1.2.1　ECMAScript　　3<br>1.2.2　文档对象模型（DOM）　　5<br>1.2.3　浏览器对象模型（BOM）　　8<br>1.3　JavaScript版本　　8<br>1.4　小结　　9<br>第2章　在HTML中使用JavaScript　　10<br>2.1　<script>元素　　10<br>2.1.1　标签的位置　　12<br>2.1.2　延迟脚本　　13<br>2.1.3　异步脚本　　13<br>2.1.4　在XHTML中的用法　　14<br>2.1.5　不推荐使用的语法　　16<br>2.2　嵌入代码与外部文件　　16<br>2.3　文档模式　　16<br>2.4　<noscript>元素　　18<br>2.5　小结　　18<br>第3章　基本概念　　19<br>3.1　语法　　19<br>3.1.1　区分大小写　　19<br>3.1.2　标识符　　19<br>3.1.3　注释　　20<br>3.1.4　严格模式　　20<br>3.1.5　语句　　20<br>3.2　关键字和保留字　　21<br>3.3　变量　　22<br>3.4　数据类型　　23<br>3.4.1　typeof操作符　　23<br>3.4.2　Undefined类型　　24<br>3.4.3　Null类型　　25<br>3.4.4　Boolean类型　　26<br>3.4.5　Number类型　　27<br>3.4.6　String类型　　32<br>3.4.7　Object类型　　35<br>3.5　操作符　　36<br>3.5.1　一元操作符　　36<br>3.5.2　位操作符　　39<br>3.5.3　布尔操作符　　44<br>3.5.4　乘性操作符　　47<br>3.5.5　加性操作符　　48<br>3.5.6　关系操作符　　50<br>3.5.7　相等操作符　　51<br>3.5.8　条件操作符　　53<br>3.5.9　赋值操作符　　53<br>3.5.10　逗号操作符　　54<br>3.6　语句　　54<br>3.6.1　if语句　　54<br>3.6.2　do-while语句　　55<br>3.6.3　while语句　　55<br>3.6.4　for语句　　56<br>3.6.5　for-in语句　　57<br>3.6.6　label语句　　58<br>3.6.7　break和continue语句　　58<br>3.6.8　with语句　　60<br>3.6.9　switch语句　　60<br>3.7　函数　　62<br>3.7.1　理解参数　　64<br>3.7.2　没有重载　　66<br>3.8　小结　　67<br>第4章　变量、作用域和内存问题　　68<br>4.1　基本类型和引用类型的值　　68<br>4.1.1　动态的属性　　68<br>4.1.2　复制变量值　　69<br>4.1.3　传递参数　　70<br>4.1.4　检测类型　　72<br>4.2　执行环境及作用域　　73<br>4.2.1　延长作用域链　　75<br>4.2.2　没有块级作用域　　76<br>4.3　垃圾收集　　78<br>4.3.1　标记清除　　78<br>4.3.2　引用计数　　79<br>4.3.3　性能问题　　80<br>4.3.4　管理内存　　81<br>4.4　小结　　81<br>第5章　引用类型　　83<br>5.1　Object类型　　83<br>5.2　Array类型　　86<br>5.2.1　检测数组　　88<br>5.2.2　转换方法　　89<br>5.2.3　栈方法　　90<br>5.2.4　队列方法　　91<br>5.2.5　重排序方法　　92<br>5.2.6　操作方法　　94<br>5.2.7　位置方法　　95<br>5.2.8　迭代方法　　96<br>5.2.9　缩小方法　　97<br>5.3　Date类型　　98<br>5.3.1　继承的方法　　100<br>5.3.2　日期格式化方法　　101<br>5.3.3　日期/时间组件方法　　102<br>5.4　RegExp类型　　103<br>5.4.1　RegExp实例属性　　105<br>5.4.2　RegExp实例方法　　106<br>5.4.3　RegExp构造函数属性　　107<br>5.4.4　模式的局限性　　109<br>5.5　Function类型　　110<br>5.5.1　没有重载（深入理解）　　111<br>5.5.2　函数声明与函数表达式　　111<br>5.5.3　作为值的函数　　112<br>5.5.4　函数内部属性　　113<br>5.5.5　函数属性和方法　　116<br>5.6　基本包装类型　　118<br>5.6.1　Boolean类型　　120<br>5.6.2　Number类型　　120<br>5.6.3　String类型　　122<br>5.7　单体内置对象　　130<br>5.7.1　Global对象　　131<br>5.7.2　Math对象　　134<br>5.8　小结　　137<br>第6章　面向对象的程序设计　　138<br>6.1　理解对象　　138<br>6.1.1　属性类型　　139<br>6.1.2　定义多个属性　　142<br>6.1.3　读取属性的特性　　143<br>6.2　创建对象　　144<br>6.2.1　工厂模式　　144<br>6.2.2　构造函数模式　　144<br>6.2.3　原型模式　　147<br>6.2.4　组合使用构造函数模式和原型模式　　159<br>6.2.5　动态原型模式　　159<br>6.2.6　寄生构造函数模式　　160<br>6.2.7　稳妥构造函数模式　　161<br>6.3　继承　　162<br>6.3.1　原型链　　162<br>6.3.2　借用构造函数　　167<br>6.3.3　组合继承　　168<br>6.3.4　原型式继承　　169<br>6.3.5　寄生式继承　　171<br>6.3.6　寄生组合式继承　　172<br>6.4　小结　　174<br>第7章　函数表达式　　175<br>7.1　递归　　177<br>7.2　闭包　　178<br>7.2.1　闭包与变量　　181<br>7.2.2　关于this对象　　182<br>7.2.3　内存泄漏　　183<br>7.3　模仿块级作用域　　184<br>7.4　私有变量　　186<br>7.4.1　静态私有变量　　188<br>7.4.2　模块模式　　189<br>7.4.3　增强的模块模式　　191<br>7.5　小结　　192<br>第8章　BOM　　193<br>8.1　window对象　　193<br>8.1.1　全局作用域　　193<br>8.1.2　窗口关系及框架　　194<br>8.1.3　窗口位置　　197<br>8.1.4　窗口大小　　198<br>8.1.5　导航和打开窗口　　199<br>8.1.6　间歇调用和超时调用　　203<br>8.1.7　系统对话框　　205<br>8.2　location对象　　207<br>8.2.1　查询字符串参数　　207<br>8.2.2　位置操作　　208<br>8.3　navigator对象　　210<br>8.3.1　检测插件　　211<br>8.3.2　注册处理程序　　213<br>8.4　screen对象　　214<br>8.5　history对象　　215<br>8.6　小结　　216<br>第9章　客户端检测　　217<br>9.1　能力检测　　217<br>9.1.1　更可靠的能力检测　　218<br>9.1.2　能力检测，不是浏览器检测　　220<br>9.2　怪癖检测　　220<br>9.3　用户代理检测　　221<br>9.3.1　用户代理字符串的历史　　222<br>9.3.2　用户代理字符串检测技术　　228<br>9.3.3　完整的代码　　242<br>9.3.4　使用方法　　245<br>9.4　小结　　246<br>第10章　DOM　　247<br>10.1　节点层次　　247<br>10.1.1　Node类型　　248<br>10.1.2　Document类型　　253<br>10.1.3　Element类型　　261<br>10.1.4　Text类型　　270<br>10.1.5　Comment类型　　273<br>10.1.6　CDATASection类型　　274<br>10.1.7　DocumentType类型　　274<br>10.1.8　DocumentFragment类型　　275<br>10.1.9　Attr类型　　276<br>10.2　DOM操作技术　　277<br>10.2.1　动态脚本　　277<br>10.2.2　动态样式　　279<br>10.2.3　操作表格　　281<br>10.2.4　使用NodeList　　283<br>10.3　小结　　284<br>第11章　DOM扩展　　286<br>11.1　选择符API　　286<br>11.1.1　querySelector()方法　　286<br>11.1.2　querySelectorAll()<br>方法　　287<br>11.1.3　matchesSelector()<br>方法　　288<br>11.2　元素遍历　　288<br>11.3　HTML5　　289<br>11.3.1　与类相关的扩充　　289<br>11.3.2　焦点管理　　291<br>11.3.3　HTMLDocument的变化　　292<br>11.3.4　字符集属性　　293<br>11.3.5　自定义数据属性　　293<br>11.3.6　插入标记　　294<br>11.3.7　scrollIntoView()方法　　298<br>11.4　专有扩展　　298<br>11.4.1　文档模式　　298<br>11.4.2　children属性　　299<br>11.4.3　contains()方法　　300<br>11.4.4　插入文本　　301<br>11.4.5　滚动　　303<br>11.5　小结　　304<br>第12章　DOM2和DOM3　　305<br>12.1　DOM变化　　305<br>12.1.1　针对XML命名空间的变化　　306<br>12.1.2　其他方面的变化　　309<br>12.2　样式　　312<br>12.2.1　访问元素的样式　　313<br>12.2.2　操作样式表　　317<br>12.2.3　元素大小　　320<br>12.3　遍历　　326<br>12.3.1　NodeIterator　　328<br>12.3.2　TreeWalker　　330<br>12.4　范围　　332<br>12.4.1　DOM中的范围　　332<br>12.4.2　IE8及更早版本中的范围　　340<br>12.5　小结　　343<br>第13章　事件　　345<br>13.1　事件流　　345<br>13.1.1　事件冒泡　　346<br>13.1.2　事件捕获　　346<br>13.1.3　DOM事件流　　347<br>13.2　事件处理程序　　348<br>13.2.1　HTML事件处理程序　　348<br>13.2.2　DOM0级事件处理程序　　350<br>13.2.3　DOM2级事件处理程序　　351<br>13.2.4　IE事件处理程序　　352<br>13.2.5　跨浏览器的事件处理程序　　353<br>13.3　事件对象　　355<br>13.3.1　DOM中的事件对象　　355<br>13.3.2　IE中的事件对象　　358<br>13.3.3　跨浏览器的事件对象　　360<br>13.4　事件类型　　362<br>13.4.1　UI事件　　362<br>13.4.2　焦点事件　　367<br>13.4.3　鼠标与滚轮事件　　368<br>13.4.4　键盘与文本事件　　379<br>13.4.5　复合事件　　384<br>13.4.6　变动事件　　385<br>13.4.7　HTML5事件　　388<br>13.4.8　设备事件　　395<br>13.4.9　触摸与手势事件　　399<br>13.5　内存和性能　　402<br>13.5.1　事件委托　　402<br>13.5.2　移除事件处理程序　　404<br>13.6　模拟事件　　405<br>13.6.1　DOM中的事件模拟　　405<br>13.6.2　IE中的事件模拟　　410<br>13.7　小结　　411<br>第14章　表单脚本　　412<br>14.1　表单的基础知识　　412<br>14.1.1　提交表单　　413<br>14.1.2　重置表单　　414<br>14.1.3　表单字段　　414<br>14.2　文本框脚本　　419<br>14.2.1　选择文本　　420<br>14.2.2　过滤输入　　423<br>14.2.3　自动切换焦点　　426<br>14.2.4　HTML5约束验证API　　427<br>14.3　选择框脚本　　431<br>14.3.1　选择选项　　432<br>14.3.2　添加选项　　434<br>14.3.3　移除选项　　435<br>14.3.4　移动和重排选项　　435<br>14.4　表单序列化　　436<br>14.5　富文本编辑　　438<br>14.5.1　使用contenteditable<br>属性　　438<br>14.5.2　操作富文本　　439<br>14.5.3　富文本选区　　441<br>14.5.4　表单与富文本　　443<br>14.6　小结　　443<br>第15章　使用Canvas绘图　　445<br>15.1　基本用法　　445<br>15.2　2D上下文　　446<br>15.2.1　填充和描边　　446<br>15.2.2　绘制矩形　　447<br>15.2.3　绘制路径　　449<br>15.2.4　绘制文本　　451<br>15.2.5　变换　　453<br>15.2.6　绘制图像　　456<br>15.2.7　阴影　　457<br>15.2.8　渐变　　458<br>15.2.9　模式　　460<br>15.2.10　使用图像数据　　460<br>15.2.11　合成　　462<br>15.3　WebGL　　463<br>15.3.1　类型化数组　　463<br>15.3.2　WebGL上下文　　468<br>15.3.3　支持　　478<br>15.4　小结　　478<br>第16章　HTML5脚本编程　　480<br>16.1　跨文档消息传递　　480<br>16.2　原生拖放　　481<br>16.2.1　拖放事件　　482<br>16.2.2　自定义放置目标　　482<br>16.2.3　dataTransfer对象　　483<br>16.2.4　dropEffect与effectAllowed　　484<br>16.2.5　可拖动　　485<br>16.2.6　其他成员　　485<br>16.3　媒体元素　　486<br>16.3.1　属性　　487<br>16.3.2　事件　　488<br>16.3.3　自定义媒体播放器　　488<br>16.3.4　检测编解码器的支持情况　　489<br>16.3.5　Audio类型　　490<br>16.4　历史状态管理　　491<br>16.5　小结　　492<br>第17章　错误处理与调试　　493<br>17.1　浏览器报告的错误　　493<br>17.1.1　IE　　493<br>17.1.2　Firefox　　494<br>17.1.3　Safari　　496<br>17.1.4　Opera　　497<br>17.1.5　Chrome　　498<br>17.2　错误处理　　499<br>17.2.1　try-catch语句　　500<br>17.2.2　抛出错误　　503<br>17.2.3　错误（error）事件　　505<br>17.2.4　处理错误的策略　　506<br>17.2.5　常见的错误类型　　507<br>17.2.6　区分致命错误和非致命<br>错误　　510<br>17.2.7　把错误记录到服务器　　511<br>17.3　调试技术　　512<br>17.3.1　将消息记录到控制台　　512<br>17.3.2　将消息记录到当前页面　　515<br>17.3.3　抛出错误　　515<br>17.4　常见的IE错误　　516<br>17.4.1　操作终止　　516<br>17.4.2　无效字符　　518<br>17.4.3　未找到成员　　518<br>17.4.4　未知运行时错误　　519<br>17.4.5　语法错误　　519<br>17.4.6　系统无法找到指定资源　　519<br>17.5　小结　　520<br>第18章　JavaScript与XML　　521<br>18.1　浏览器对XML DOM的支持　　521<br>18.1.1　DOM2级核心　　521<br>18.1.2　DOMParser类型　　522<br>18.1.3　XMLSerializer类型　　523<br>18.1.4　IE8及之前版本中的XML　　523<br>18.1.5　跨浏览器处理XML　　527<br>18.2　浏览器对XPath的支持　　529<br>18.2.1　DOM3级XPath　　529<br>18.2.2　IE中的XPath　　534<br>18.2.3　跨浏览器使用XPath　　535<br>18.3　浏览器对XSLT的支持　　537<br>18.3.1　IE中的XSLT　　537<br>18.3.2　XSLTProcessor类型　　541<br>18.3.3　跨浏览器使用XSLT　　543<br>18.4　小结　　544<br>第19章　E4X　　546<br>19.1　E4X的类型　　546<br>19.1.1　XML类型　　546<br>19.1.2　XMLList类型　　547<br>19.1.3　Namespace类型　　548<br>19.1.4　QName类型　　549<br>19.2　一般用法　　550<br>19.2.1　访问特性　　551<br>19.2.2　其他节点类型　　552<br>19.2.3　查询　　553<br>19.2.4　构建和操作XML　　555<br>19.2.5　解析和序列化　　557<br>19.2.6　命名空间　　558<br>19.3　其他变化　　559<br>19.4　全面启用E4X　　560<br>19.5　小结　　561<br>第20章　JSON　　562<br>20.1　语法　　562<br>20.1.1　简单值　　562<br>20.1.2　对象　　563<br>20.1.3　数组　　564<br>20.2　解析与序列化　　565<br>20.2.1　JSON对象　　565<br>20.2.2　序列化选项　　566<br>20.2.3　解析选项　　569<br>20.3　小结　　570<br>第21章　Ajax与Comet　　571<br>21.1　XMLHttpRequest对象　　571<br>21.1.1　XHR的用法　　573<br>21.1.2　HTTP头部信息　　575<br>21.1.3　GET请求　　576<br>21.1.4　POST请求　　577<br>21.2　XMLHttpRequest 2级　　578<br>21.2.1　FormData　　578<br>21.2.2　超时设定　　579<br>21.2.3　overrideMimeType()<br>方法　　580<br>21.3　进度事件　　580<br>21.3.1　load事件　　580<br>21.3.2　progress事件　　581<br>21.4　跨源资源共享　　582<br>21.4.1　IE对CORS的实现　　582<br>21.4.2　其他浏览器对CORS的<br>实现　　584<br>21.4.3　Preflighted Reqeusts　　584<br>21.4.4　带凭据的请求　　585<br>21.4.5　跨浏览器的CORS　　585<br>21.5　其他跨域技术　　586<br>21.5.1　图像Ping　　586<br>21.5.2　JSONP　　587<br>21.5.3　Comet　　588<br>21.5.4　服务器发送事件　　590<br>21.5.5　Web Sockets　　591<br>21.5.6　SSE与Web Sockets　　593<br>21.6　安全　　593<br>21.7　小结　　594<br>第22章　高级技巧　　596<br>22.1　高级函数　　596<br>22.1.1　安全的类型检测　　596<br>22.1.2　作用域安全的构造函数　　597<br>22.1.3　惰性载入函数　　600<br>22.1.4　函数绑定　　602<br>22.1.5　函数柯里化　　604<br>22.2　防篡改对象　　606<br>22.2.1　不可扩展对象　　606<br>22.2.2　密封的对象　　607<br>22.2.3　冻结的对象　　608<br>22.3　高级定时器　　609<br>22.3.1　重复的定时器　　610<br>22.3.2　Yielding Processes　　612<br>22.3.3　函数节流　　614<br>22.4　自定义事件　　616<br>22.5　拖放　　618<br>22.5.1　修缮拖动功能　　620<br>22.5.2　添加自定义事件　　622<br>22.6　小结　　624<br>第23章　离线应用与客户端存储　　626<br>23.1　离线检测　　626<br>23.2　应用缓存　　627<br>23.3　数据存储　　628<br>23.3.1　Cookie　　629<br>23.3.2　IE用户数据　　637<br>23.3.3　Web存储机制　　638<br>23.3.4　IndexedDB　　643<br>23.4　小结　　654<br>第24章　最佳实践　　656<br>24.1　可维护性　　656<br>24.1.1　什么是可维护的代码　　656<br>24.1.2　代码约定　　657<br>24.1.3　松散耦合　　659<br>24.1.4　编程实践　　662<br>24.2　性能　　666<br>24.2.1　注意作用域　　666<br>24.2.2　选择正确方法　　667<br>24.2.3　最小化语句数　　672<br>24.2.4　优化DOM交互　　673<br>24.3　部署　　676<br>24.3.1　构建过程　　676<br>24.3.2　验证　　677<br>24.3.3　压缩　　679<br>24.4　小结　　681<br>第25章　新兴的API　　682<br>25.1　requestAnimationFrame()　　682<br>25.1.1　早期动画循环　　682<br>25.1.2　循环间隔的问题　　683<br>25.1.3　mozRequestAnimation-Frame　　683<br>25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685<br>25.2　Page Visibility API　　686<br>25.3　Geolocation API　　687<br>25.4　File API　　689<br>25.4.1　FileReader类型　　690<br>25.4.2　读取部分内容　　692<br>25.4.3　对象URL　　693<br>25.4.4　读取拖放的文件　　694<br>25.4.5　使用XHR上传文件　　695<br>25.5　Web计时　　696<br>25.6　Web Workers　　697<br>25.6.1　使用Worker　　697<br>25.6.2　Worker全局作用域　　698<br>25.6.3　包含其他脚本　　699<br>25.6.4　Web Workers的未来　　700<br>25.7　小结　　700<br>附录A　ECMAScript Harmony　　701<br>附录B　严格模式　　717<br>附录C　JavaScript库　　723<br>附录D　JavaScript工具　　727</p><h3 id="JavaScript高级程序设计（第3版）-PDF-下载地址"><a href="#JavaScript高级程序设计（第3版）-PDF-下载地址" class="headerlink" title="JavaScript高级程序设计（第3版） PDF 下载地址:"></a>JavaScript高级程序设计（第3版） PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1HPMW7olgxh2FyGX7SvoQeQ?pwd=6ukn">https://pan.baidu.com/s/1HPMW7olgxh2FyGX7SvoQeQ?pwd=6ukn</a> </p><p>提取码: 6ukn </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Javascript框架高级编程 》</title>
      <link href="/2023/10/07/Javascript%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/10/07/Javascript%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230928160126.png" alt="《 Javascript框架高级编程 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>Spring框架是主要的开源应用程序开发框架，它使得Java／J2EE开发更容易、效率更高。本书不仅向读者展示了Spring能做什么?而且揭示了Spring完成这些功能的原理，解释其功能和动机，以帮助读者使用该框架的所有部分来开发成功的应用程序。本书涵盖Spring的所有特性，并且演示了如何将其构成一个连贯的整体，帮助读者理解Spring方法的基本原理、何时使用Sping以及如何效仿最佳实践。所有这些都以完整的样本应用程序来举例说明。读完本书，读者将能够有效地在各种应用中(从简单的web应用程序到复杂的企业级应用程序)使用Spring。</p><p>　　本书旨在指导读者何使用Spring框架来实现各种有效应用程序的开发(从简单的Web应用到复杂的企业级应用)。通过一个完整的样本应用程序贯穿全书，举例说明Spring如何提供一个清晰的、分层的体系结构的基础；以及如何适当地使用Spring来实现好的OO设计和体系结构设计，以及如何应用最佳实践。</p><p>　　本书面向欲深人学习Spring框架的Java／J2EE体系结构设计人员和开发人员，使他们能够把spring框架有效地用于从简单的Web应用到复杂的企业级应用；也非常适合Spring框架新手作为常备参考书。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Rod Johnson是Spring框架的创始人，并且是Java和J2EE领域的著名专家。</p><p>Rod获悉民大学博士学位。他具有C&#x2F;C++开发背景，从Java和J2EE发布以来就作为开发者、体系结构设计者和顾问涉足了Java和J2EE领域。</p><p>他撰写了两本最普及并最有影响力的J2EE书籍：《Expert One-on-one J2EE Design and Development》（Wrox，2002），和《J2EE without EJB》（Wrox，2004，与Juergen Hoeller合著）。这两本书在“敏捷”J2EE的兴起和改变过度复杂的传统J2EE体系结构方面都起了重要作用。</p><p>Rod是Spring框架的共同领导之一。他的发言很受欢迎，并且经常出现在美国、欧洲和亚洲举行的Java重要活动中。他是一些JSR的专家组的成员，为Java社区发展计划（Java Community Process，JCP）服务。</p><p>他还具有在银行和金融、保险、软件、媒体等领域从事顾问的广泛经验。他是Interface21（<a href="http://www.interface21.com)的ceo,interface21是一家致力于提供专家级j2ee和spring框架服务的咨询公司.他积极参与客户项目和spring开发./">www.interface21.com）的CEO，Interface21是一家致力于提供专家级J2EE和Spring框架服务的咨询公司。他积极参与客户项目和Spring开发。</a></p><p>Juergen Hoeller是Interface21的共同创始人，该公司从源头提供商业性Spring服务。他是Spring开发的主要驱动者，并且从Spring一发布开始就担任其发布经理。在该项目中，他负责多方面的开发内容，从核心容器到事务管理、数据访问和轻量级远程处理。</p><p>Juergen获林茨大学计算机科学硕士学位，专攻Java、OO建模和软件工程。他是《Expert One-on-One J2EE Development without EJB》（Wiley，2001）一书的合著者，并且经常参加各种会议和活动。他还活跃于许多社区论坛中，其中包括TheServerSide。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 Spring框架概述 1<br>1.1 为什么要Spring？ 1<br>1.1.1 J2EE传统方式的问题 1<br>1.1.2 轻量级框架 3<br>1.1.3 进入Spring 4<br>1.2 Spring的价值 5<br>1.3 上下文中的Spring 6<br>1.3.1 技术 7<br>1.3.2 面向方面的编程 9<br>1.3.3 一致性抽象 12<br>1.3.4 与其他框架的关系 16<br>1.4 使用Spring构造应用程序 18<br>1.4.1 关系图 18<br>1.4.2 持久性和集成 20<br>1.4.3 业务服务对象 23<br>1.4.4 表示 24<br>1.5 前景 25<br>1.5.1 发布日程 25<br>1.5.2 Java和J2EE的进展 26<br>1.5.3 技术趋势 27<br>1.5.4 标准与源码公开 27<br>1.6 Spring项目和社区 28<br>1.6.1 历史 28<br>1.6.2 模块摘要 29<br>1.6.3 支持的环境 32<br>1.7 小结 32<br>第2章 BEAN工厂与应用程序上下文 34<br>2.1 控制反转和依赖注入 34<br>2.1.1 不同形式的依赖注入 36<br>2.1.2 在设置器注入和构造函数注入之间决定 37<br>2.2 容器 38<br>2.2.1 Bean工厂 39<br>2.2.2 应用程序上下文 40<br>2.2.3 启动容器 41<br>2.2.4 使用来自工厂的Bean 42<br>2.2.5 XML Bean配置 43<br>2.2.6 基本的Bean定义 43<br>2.2.7 管理Bean生命周期 52<br>2.2.8 对服务和资源访问的抽象 54<br>2.2.9 重用Bean定义 57<br>2.2.10 使用后置处理器处理定制的Bean和容器 59<br>2.3 小结 63<br>第3章 高级容器概念 64<br>3.1 低层资源的抽象 64<br>3.1.1 应用程序上下文作为ResourceLoader 64<br>3.1.2 应用程序上下文作为消息源 66<br>3.2 应用程序事件 68<br>3.3 管理容器 69<br>3.3.1 ApplicationContext构造函数中的资源位置路径 69<br>3.3.2 应用程序上下文的声明性用法 71<br>3.3.3 将容器定义划分到多个文件 72<br>3.3.4 处理组件的策略 73<br>3.3.5 用于访问容器的单态 75<br>3.4 一些方便的工厂BEAN 75<br>3.4.1 PropertyPathFactoryBean 76<br>3.4.2 FieldRetrievingFactoryBean 76<br>3.4.3 MethodInvokingFactoryBean 77<br>3.5 SPRING提供的属性编辑器 77<br>3.6 测试策略 78<br>3.6.1 单元测试 78<br>3.6.2 使用Spring容器的测试 80<br>3.7 XML的替代品 81<br>3.7.1 来自Properties文件的定义 82<br>3.7.2 编程化的Bean定义 82<br>3.7.3 其他格式 83<br>3.7.4 参考文献 83<br>3.8 小结 83<br>第4章 SPRING与AOP 84<br>4.1 目标 84<br>4.2 假设 85<br>4.3 例子 85<br>4.4 SPRING的AOP框架 86<br>4.4.1 拦截器链 87<br>4.4.2 赞成与反对 87<br>4.4.3 通知 88<br>4.4.4 切点 92<br>4.4.5 通知器（Advisor） 96<br>4.4.6 与Spring IoC容器的集成 97<br>4.4.7 在运行时间检验并处理代理状态 107<br>4.4.8 编程化的代理创建 107<br>4.5 使用SPRING的AOP框架的高级特性 108<br>4.5.1 TargetSources 108<br>4.5.2 及早终止拦截器链 112<br>4.5.3 使用介绍 112<br>4.5.4 暴露当前的代理 114<br>4.5.5 暴露当前的MethodInvocation 115<br>4.5.6 理解代理类型 115<br>4.5.7 调试与测试 117<br>4.5.8 其他 118<br>4.6 与其他AOP框架集成 120<br>4.6.1 目标 120<br>4.6.2 AspectJ集成 121<br>4.6.3 AspectWerkz 125<br>4.7 参考文献 125<br>4.8 小结 126<br>第5章 DAO支持与JDBC框架 127<br>5.1 数据访问对象模式 127<br>5.2 SPRING的JDBC框架概述 128<br>5.2.1 起因：直接使用JDBC的问题 128<br>5.2.2 Spring可以如何帮助 130<br>5.2.3 简单的例子 130<br>5.3 建立样本应用程序的数据访问层 131<br>5.3.1 样本应用程序的数据模型 131<br>5.3.2 DataSource 132<br>5.3.3 异常转译 133<br>5.4 使用JDBCTEMPLATE的操作 134<br>5.4.1 回调方法的使用 134<br>5.4.2 JdbcTemplate的方便方法 135<br>5.4.3 使用JdbcTemplate的基本查询 136<br>5.4.4 使用JdbcTemplate的基本更新 137<br>5.4.5 JdbcTemplate的高级用法 137<br>5.4.6 对RowSet的支持 138<br>5.5 使用RDBMS操作类 139<br>5.5.1 SqlQuery和MappingSqlQuery 139<br>5.5.2 使用SqlUpdate插入和更新 140<br>5.5.3 使用UpdatableSqlQuery更新ResultSet 141<br>5.5.4 生成主键 141<br>5.5.5 检索数据库生成的键 142<br>5.5.6 调用存储过程 143<br>5.6 高级概念 144<br>5.6.1 在应用程序服务器中的运行Spring JDBC 144<br>5.6.2 使用定制的异常转译 145<br>5.6.3 读写LOB数据 147<br>5.6.4 批量更新 149<br>5.6.5 存储过程的高级用法 150<br>5.7 其他的考虑事项 152<br>5.7.1 性能 152<br>5.7.2 何时使用JDBC和O&#x2F;R映射 152<br>5.7.3 JDBC版本和J2EE版本 153<br>5.8 小结 153<br>第6章 事务和资源管理 154<br>6.1 背景 154<br>6.1.1 什么是事务？ 154<br>6.1.2 ACID属性 154<br>6.1.3 并发控制 156<br>6.2 事务与J2EE 156<br>6.2.1 局部事务 157<br>6.2.2 全局&#x2F;分布式事务 157<br>6.2.3 事务传播 157<br>6.2.4 事务划分 157<br>6.3 SPRING事务支持的例子 158<br>6.4 SPRING的事务抽象介绍 159<br>6.4.1 事务控制选择的概述 159<br>6.4.2 事务划分策略 162<br>6.4.3 事务管理策略 167<br>6.5 DATASOURCE声明 171<br>6.5.1 本地非缓冲 171<br>6.5.2 本地缓冲 172<br>6.5.3 JNDI 172<br>6.5.4 在本地DataSource和JNDI DataSource之间选择 173<br>6.6 小结 173<br>第7章 对象&#x2F;关系映射 175<br>7.1 背景知识 175<br>7.1.1 基本的O&#x2F;R映射 176<br>7.1.2 对象查询语言 176<br>7.1.3 透明持久性 177<br>7.1.4 何时选择O&#x2F;R映射 177<br>7.2 SPRING中的O&#x2F;R映射支持 178<br>7.2.1 数据访问对象 178<br>7.2.2 事务管理 179<br>7.3 IBATIS SQL MAPS 179<br>7.3.1 映射文件 180<br>7.3.2 DAO实现 181<br>7.3.3 在Spring上下文中设置 182<br>7.3.4 事务管理 182<br>7.3.5 iBATIS概要 183<br>7.4 HIBERNATE 184<br>7.4.1 映射文件 184<br>7.4.2 DAO实现 185<br>7.4.3 Spring上下文中的设置 186<br>7.4.4 设置为JCA连接器 187<br>7.4.5 事务管理 188<br>7.4.6 Open Session in View 192<br>7.4.7 BLOB&#x2F;CLOB处理 194<br>7.4.8 Hibernate：小结 195<br>7.5 JDO 196<br>7.5.1 持久性对象的生命周期 197<br>7.5.2 DAO实现 197<br>7.5.3 在Spring上下文中设置 199<br>7.5.4 事务管理 200<br>7.5.5 PersistenceManager的生命周期 200<br>7.5.6 Open PersistenceManager in View 201<br>7.5.7 JDO方言 203<br>7.5.8 JDO：小结 203<br>7.6 其他O&#x2F;R映射工具 205<br>7.6.1 Apache OJB 205<br>7.6.2 TopLink 206<br>7.6.3 Cayenne 207<br>7.6.4 JSR-220持久性 207<br>7.7 小结 207<br>第8章 轻量级远程处理 209<br>8.1 概念和范围 209<br>8.2 公共的配置风格 211<br>8.3 HESSIAN和BURLAP 212<br>8.3.1 访问一个服务 213<br>8.3.2 导出一个服务 214<br>8.4 HTTP调用器 215<br>8.4.1 访问一个服务 216<br>8.4.2 导出一个服务 216<br>8.4.3 定制化选项 217<br>8.5 RMI 218<br>8.5.1 访问一个服务 219<br>8.5.2 Stub查询策略 220<br>8.5.3 导出一个服务 221<br>8.5.4 定制化选项 222<br>8.5.5 RMI-IIOP 222<br>8.6 通过JAX-RPC的WEB服务 223<br>8.6.1 访问一个服务 224<br>8.6.2 导出一个服务 225<br>8.6.3 定制的类型映射 226<br>8.7 小结 227<br>第9章 支持性服务 229<br>9.1 JMS 229<br>9.1.1 引言 229<br>9.1.2 Spring的JMS支持的起因 230<br>9.1.3 通过模板的JMS访问 230<br>9.1.4 异常处理 232<br>9.1.5 ConnectionFactory管理 232<br>9.1.6 消息转换器 233<br>9.1.7 目的管理 233<br>9.1.8 事务管理 234<br>9.1.9 JmsGatewaySupport 235<br>9.1.10 前景 236<br>9.2 使用SPRING的调度 236<br>9.2.1 Timer与Quartz 236<br>9.2.2 Timer 237<br>9.2.3 Quartz 238<br>9.3 使用SPRING发送电子邮件 241<br>9.3.1 入门指南 242<br>9.3.2 重用现有的邮件会话 242<br>9.3.3 使用COS的邮寄发送 242<br>9.3.4 通用的邮件管理器 243<br>9.4 脚本 245<br>9.4.1 一致性模型 245<br>9.4.2 其他脚本语言 248<br>9.5 小结 248<br>第10章 SPRING的ACEGI SECURITY系统 249<br>10.1 企业应用程序的安全选择 249<br>10.1.1 典型的需求 249<br>10.1.2 Acegi Security简介 250<br>10.1.3 Java身份验证和授权服务 252<br>10.1.4 Servlet规范 254<br>10.2 ACEGI SECURITY的基础 255<br>10.2.1 身份验证 255<br>10.2.2 存储身份验证对象 257<br>10.2.3 授权 258<br>10.2.4 域对象实例的安全 259<br>10.3 范例代码 262<br>10.3.1 范例介绍 262<br>10.3.2 安全不知道的实现 262<br>10.3.3 安全方法 263<br>10.3.4 身份验证 263<br>10.3.5 授权 264<br>10.4 小结 265<br>第11章 SPRING与EJB 267<br>11.1 对EJB的需要做出决断 267<br>11.2 访问EJB 268<br>11.2.1 样板方法 268<br>11.2.2 Spring的方法 269<br>11.3 用SPRING实现EJB 273<br>11.3.1 无状态会话Bean 273<br>11.3.2 有状态会话Bean 275<br>11.3.3 消息驱动的Bean 276<br>11.3.4 XDoclet 276<br>11.4 单态容器访问，好还是坏？ 277<br>11.4.1 ContextSingletonBeanFactoryLocator和SingletonBeanFactoryLocator 278<br>11.4.2 共享的上下文作为Web应用程序的应用程序上下文的双亲 280<br>11.4.3 使用来自EJB的共享的上下文 280<br>11.5 测试关注点 281<br>11.5.1 在POJO委托中实现业务功能 281<br>11.5.2 使用模仿的EJB容器 282<br>11.5.3 应用程序服务器内部的集成测试 282<br>11.6 小结 283<br>第12章 WEB MVC框架 284<br>12.1 简单的例子 284<br>12.2 一般的体系结构 285<br>12.2.1 Web MVC概念 285<br>12.2.2 使用分发器和控制器的通用Web MVC 286<br>12.2.3 好的Web MVC框架的需求 286<br>12.2.4 Spring的Web MVC的等价物 287<br>12.3 基础设施组件 289<br>12.3.1 DispatcherServlet 289<br>12.3.2 WebApplicationContext 291<br>12.4 处理请求有关的工作流 293<br>12.5 SPRING MVC WEB应用程序的一般布局 294<br>12.6 HANDLERMAPPING 295<br>12.6.1 BeanNameUrlHandlerMapping 296<br>12.6.2 SimpleUrlHandlerMapping 296<br>12.6.3 CommonsPathMapUrlHandlerMapping 297<br>12.6.4 多个HandlerMapping 298<br>12.7 HANDLEREXECUTIONCHAIN和拦截器 298<br>12.7.1 WebContentInterceptor 299<br>12.7.2 UserRoleAuthorizationInterceptor 300<br>12.7.3 Spring MVC提供的其他处理器拦截器 300<br>12.8 处理器及其适配器 300<br>12.9 MODELANDVIEW和VIEWRESOLVERS 301<br>12.9.1 UrlBasedViewResolver 301<br>12.9.2 BeanNameViewResolver和XmlViewResolver 302<br>12.9.3 ResourceBundleViewResolver 302<br>12.9.4 视图解析器成链 303<br>12.10 地区值的改变和解析 304<br>12.11 HANDLEREXCEPTIONRESOLVERS 305<br>12.12 控制器 307<br>12.12.1 WebContentGenerator 307<br>12.12.2 AbstractController 308<br>12.12.3 UrlFilenameViewController 308<br>12.12.4 ParameterizableViewController 309<br>12.12.5 MultiActionController 309<br>12.13 数据绑定 310<br>12.13.1 使用数据绑定时的方便功能 310<br>12.14 使用控制器的实际例子 311<br>12.15 使用ABSTRACTCONTROLLER查看演出列表 311<br>12.15.1 预订 313<br>12.16 向导功能 318<br>12.16.1 基本配置 318<br>12.16.2 模板方法 318<br>12.16.3 向导流程 319<br>12.16.4 页面改变、编号和其他动作 319<br>12.17 扩展SPRING处理器的基础设施 320<br>12.18 上传文件 321<br>12.18.1 配置多部分解析器 321<br>12.18.2 创建表单来上传文件 321<br>12.18.3 处理上传的数据 322<br>12.19 测试控制器 322<br>12.19.1 无需应用程序上下文的测试 323<br>12.19.2 使用模仿对象的更广泛测试 323<br>12.19.3 使用完全的应用程序上下文测试 323<br>12.19.4 测试Web应用程序的其他方法 324<br>12.19.5 小结 324<br>第13章 WEB视图技术 326<br>13.1 一个例子 326<br>13.1.1 通用配置 327<br>13.1.2 JSP 327<br>13.1.3 FreeMarker 327<br>13.1.4 使用iText生成PDF 328<br>13.2 选择技术时的注意事项 328<br>13.3 视图对象和模型 329<br>13.4 ABSTRACTVIEW提供的特性 330<br>13.4.1 使用RedirectView发布新的请求 330<br>13.4.2 使用视图前缀发布转向或者重定向 331<br>13.5 JSP 332<br>13.5.1 配置应用程序以使用JSP 332<br>13.5.2 使用定制标记创建表单 333<br>13.5.3 使用标记文件创建可重用的元素 337<br>13.6 VELOCITY和FREEMARKER 338<br>13.6.1 配置视图解析器 338<br>13.6.2 使用表单简化宏 340<br>13.7 TILES 342<br>13.8 基于XML和XSLT的视图 344<br>13.9 EXCEL和基于其他文档的视图 345<br>13.9.1 从表演列表生成Excel文件 345<br>13.9.2 以模板作为Excel文件的基础 346<br>13.9.3 基于其他文档的视图 346<br>13.9.4 使用HandlerInterceptor区分HTML和Excel 346<br>13.10 实现定制视图 347<br>13.10.1 View和AbstractView 347<br>13.10.2 实现从数据对象生成XML的视图 348<br>13.10.3 实现定制视图时的注意事项 348<br>13.11 小结 349<br>第14章 与其他WEB框架集成 350<br>14.1 选择MVC框架时的注意事项 350<br>14.1.1 比较传统的Web MVC框架 350<br>14.2 与SPRING集成：核心概念 359<br>14.3 WEBWORK 集成 361<br>14.3.1 设置ObjectFactory 361<br>14.4 STRUTS集成 361<br>14.4.1 使用ActionSupport 362<br>14.4.2 使用DelegationRequestProcessor和DelegationActionProxy 362<br>14.4.3 使用自动装配的基本动作 364<br>14.5 TAPESTRY集成 365<br>14.5.1 为Tapestry准备Bean 365<br>14.5.2 页面类 365<br>14.5.3 页面定义 366<br>14.5.4 页面模板 366<br>14.5.5 Tapestry集成的最终思考 366<br>14.6 JSF集成 367<br>14.7 小结 368<br>第15章 样本应用程序 369<br>15.1 服务器技术的选择 369<br>15.2 应用层 370<br>15.3 持久性层 370<br>15.3.1 数据模型 370<br>15.3.2 域对象模型 371<br>15.3.3 对象&#x2F;关系映射 371<br>15.3.4 DAO实现 373<br>15.3.5 数据访问上下文 374<br>15.4 业务服务层 374<br>15.4.1 服务 374<br>15.4.2 应用程序上下文 375<br>15.5 WEB层 375<br>15.5.1 应用程序流程 376<br>15.5.2 通过web.xml配置应用程序 376<br>15.5.3 Web控制器 377<br>15.5.4 视图技术 377<br>15.6 与J2EE设计和开发实现的比较 378<br>15.6.1 更简单的技术 378<br>15.6.2 数据库变化 378<br>15.7 服务器配置 378<br>15.7.1 MySQL 379<br>15.7.2 Tomcat 379<br>15.8 组建和部署 379<br>15.8.1 创建和载入数据库表 380<br>15.8.2 组建应用程序并部署到Tomcat服务器 380<br>15.9 小结 380<br>第16章 结论 381<br>16.1 SPRING解决的问题 381<br>16.2 SPRING解决方案 381<br>16.3 SPRING开发的指导方针 383<br>16.3.1 技术选择 383<br>16.3.2 层与层 385<br>16.3.3 构造应用程序 389<br>16.3.4 测试应用程序 392<br>16.4 相关项目 394<br>16.4.1 Spring的Acegi Security 394<br>16.5 其他项目 395<br>16.6 非J2EE环境中的SPRING 395<br>16.7 发现更多 396<br>16.7.1 书籍和文章 396<br>16.7.2 在线资源 397<br>16.7.3 样本应用程序 397<br>16.8 前景.. 398<br>附录A 样本应用程序的需求 399<br>A.1 概述 399<br>A.2 用户群体 399<br>A.2.1 公众Internet用户 399<br>A.2.2 售票处用户 400<br>A.2.3 系统管理员 400<br>A.3 假设 400<br>A.4 范围限制 401<br>A.5 交付时间表 401<br>A.6 INTERNET用户界面 401<br>A.6.1 基本工作流 402<br>A.6.2 错误处理 402<br>A.6.3 应用程序屏幕 402<br>A.7 非功能性需求 409<br>A.8 硬件和软件环境 410</p><h3 id="Javascript框架高级编程-PDF-下载地址"><a href="#Javascript框架高级编程-PDF-下载地址" class="headerlink" title="Javascript框架高级编程 PDF 下载地址:"></a>Javascript框架高级编程 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1DkiEczF-hG6QLQiqsRAUwg?pwd=3guh">https://pan.baidu.com/s/1DkiEczF-hG6QLQiqsRAUwg?pwd=3guh</a> </p><p>提取码: 3guh </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 精通JavaScript(图灵计算机科学丛书) 》</title>
      <link href="/2023/10/07/%E7%B2%BE%E9%80%9AJavaScript(%E5%9B%BE%E7%81%B5%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%9B%E4%B9%A6)/"/>
      <url>/2023/10/07/%E7%B2%BE%E9%80%9AJavaScript(%E5%9B%BE%E7%81%B5%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%9B%E4%B9%A6)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231007093153.png" alt="《 精通JavaScript(图灵计算机科学丛书) 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是目前最深入的 JavaScript 图书，讲述了现代 JavaScript 的所有知识，展现了这门技术将能给网站建设带来如何丰富的体验。本书言简意赅，扩展了读者视野，并关注于基础且重要的主题——现代 JavaScript 是什么和不是什么，浏览器支持的当前状态，以及需要注意的陷阱等。书中所有概念都来自于现实案例的分析。</p><p>本书适合各层次 Web 开发人员阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　认识现代javascript<br>第1章　现代javascript程序设计　2<br>1.1　面向对象的javascript　2<br>1.2　测试代码　3<br>1.3　打包分发　4<br>1.4　分离式dom脚本编程　5<br>1.4.1　dom　6<br>1.4.2　事件　7<br>1.4.3　javascript与css　8<br>1.5　ajax　8<br>1.6　浏览器支持　11<br>1.7　小结　12<br>第二部分　专业javascript开发<br>第2章　面向对象的javascript　14<br>2.1　语言特性　14<br>2.1.1　引用　14<br>2.1.2　函数重载和类型检查　16<br>.2.1.3　作用域　19<br>2.1.4　闭包　20<br>2.1.5　上下文对象　23<br>2.2　面向对象基础　24<br>2.2.1　对象　25<br>2.2.2　对象的创建　25<br>2.3　小结　30<br>第3章　创建可重用代码　31<br>3.1　标准化面向对象的代码　31<br>3.1.1　原型式继承　31<br>3.1.2　类式继承　32<br>3.1.3　base库　35<br>3.1.4　prototype库　36<br>3.2　打包　39<br>3.2.1　命名空间　40<br>3.2.2　清理代码　42<br>3.2.3　压缩　43<br>3.3　分发　45<br>3.4　小结　47<br>第4章　调试与测试的工具　48<br>4.1　调试　48<br>4.1.1　错误控制台　48<br>4.1.2　dom查看器　52<br>4.1.3　firebug　54<br>4.1.4　venkman　55<br>4.2　测试　56<br>4.2.1　jsunit　56<br>4.2.2　j3unit　57<br>4.2.3　test.simple　58<br>4.3　小结　59<br>第三部分　分离式javascript<br>第5章　dom　62<br>5.1　dom简介　62<br>5.2　遍历dom　62<br>5.2.1　处理dom中的空格　64<br>5.2.2　简单的dom遍历　66<br>5.2.3　绑定到每一个html元素　67<br>5.2.4　标准的dom方法　68<br>5.3　等待html dom的加载　69<br>5.3.1　等待整个页面的加载　70<br>5.3.2　等待大部分dom的加载　70<br>5.3.3　判断dom何时加载完毕　71<br>5.4　在html文档中查找元素　73<br>5.4.1　通过类的值查找元素　73<br>5.4.2　使用css选择器查找元素　74<br>5.4.3　xpath　76<br>5.5　获取元素的内容　77<br>5.5.1　获取元素内的文本　77<br>5.5.2　获取元素内的html　78<br>5.6　操作元素特性　79<br>5.7　修改dom　82<br>5.7.1　使用dom创建节点　83<br>5.7.2　插入到dom中　83<br>5.7.3　注入html到dom　85<br>5.7.4　删除dom节点　87<br>5.8　小结　88<br>第6章　事件　89<br>6.1　javascript事件简介　89<br>6.1.1　异步事件与线程　89<br>6.1.2　事件阶段　91<br>6.2　常见事件特性　93<br>6.2.1　事件对象　93<br>6.2.2　this关键字　93<br>6.2.3　取消事件冒泡　94<br>6.2.4　重载浏览器的默认行为　95<br>6.3　绑定事件监听函数　97<br>6.3.1　传统绑定　98<br>6.3.2　dom绑定：w3c　99<br>6.3.3　dom绑定：ie　100<br>6.3.4　addevent和removeevent　100<br>6.4　事件类型　103<br>6.5　分离式脚本编程　103<br>6.5.1　javascript禁用的未雨绸缪　104<br>6.5.2　确保链接不依赖于javascript　104<br>6.5.3　监听css何时禁用　105<br>6.5.4　事件的亲和力　105<br>6.6　小结　106<br>第7章　javascript与css　107<br>7.1　访问样式信息　107<br>7.2　动态元素　109<br>7.2.1　元素的位置　109<br>7.2.2　元素的尺寸　115<br>7.2.3　元素的可见性　117<br>7.3　动画　119<br>7.3.1　滑动　119<br>7.3.2　渐显　119<br>7.4　浏览器　120<br>7.4.1　鼠标位置　120<br>7.4.2　视口　121<br>7.5　拖放　123<br>7.6　库　128<br>7.6.1　moo.fx和jquery　128<br>7.6.2　scriptaculous　129<br>7.7　小结　131<br>第8章　改进表单　132<br>8.1　表单验证　132<br>8.1.1　必填字段　134<br>8.1.2　模式匹配　136<br>8.1.3　规则集合　138<br>8.2　显示错误信息　139<br>8.2.1　验证　140<br>8.2.2　何时验证　142<br>8.3　可用性的提升　144<br>8.3.1　悬停的说明　144<br>8.3.2　标记必填字段　146<br>8.4　小结　147<br>第9章　制作图库　148<br>9.1　图库示例　148<br>9.1.1　lightbox　148<br>9.1.2　thickbox　150<br>9.2　制作图库　151<br>9.2.1　分离加载　154<br>9.2.2　半透明的覆盖层　155<br>9.2.3　定位盒子　157<br>9.2.4　导航　160<br>9.2.5　幻灯片　162<br>9.3　小结　165<br>第四部分　ajax<br>第10章　ajax导引　168<br>10.1　使用ajax　168<br>10.1.1　http请求　169<br>10.1.2　http响应　173<br>10.2　处理响应数据　176<br>10.3　完整的ajax程序包　177<br>10.4　数据的不同用途　179<br>10.4.1　基于xml的rss feed　179<br>10.4.2　html注入器　181<br>10.4.3　json与javascript：远程执行　182<br>10.5　小结　182<br>第11章　用ajax改进blog　183<br>11.1　永不终止的blog　183<br>11.1.1　blog的模板　183<br>11.1.2　数据源　186<br>11.1.3　事件检测　187<br>11.1.4　请求　188<br>11.1.5　结果　188<br>11.2　实时网志　191<br>11.3　小结　193<br>第12章　自动补全的搜索　194<br>12.1　自动补全搜索的例子　194<br>12.2　制作页面　195<br>12.3　监听键盘输入　197<br>12.4　抓取结果　200<br>12.5　导航结果列表　202<br>12.5.1　键盘导航　202<br>12.5.2　鼠标导航　203<br>12.6　最终成果　203<br>12.7　小结　208<br>第13章　ajax wiki　209<br>13.1　wiki是什么　209<br>13.2　对话数据库　209<br>13.3　ajax请求　211<br>13.4　服务器端代码　212<br>13.4.1　处理请求　212<br>13.4.2　执行和格式化sql　213<br>13.5　处理json响应　215<br>13.6　附加的案例研究：javascript blog　216<br>13.7　应用程序的代码　217<br>13.7.1　核心javascript代码　218<br>13.7.2　javascript sql库　221<br>13.7.3　ruby服务器端代码　221<br>13.8　小结　224<br>第五部分　javascript的未来<br>第14章　javascript路在何方　226<br>14.1　javascript 1.6与1.7　226<br>14.1.1　javascript 1.6　226<br>14.1.2　javascript 1.7　229<br>14.2　web applications 1.0　231<br>14.2.1　制作时钟　232<br>14.2.2　简单行星模拟　235<br>14.3　comet　238<br>14.4　小结　240<br>第六部分　附录<br>附录a　dom参考手册　242<br>附录b　事件参考手册　257<br>附录c　浏览器　273</p><h3 id="精通JavaScript-图灵计算机科学丛书-PDF-下载地址"><a href="#精通JavaScript-图灵计算机科学丛书-PDF-下载地址" class="headerlink" title="精通JavaScript(图灵计算机科学丛书) PDF 下载地址:"></a>精通JavaScript(图灵计算机科学丛书) PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/10NLJMQ1W5YS6qeHhy0EjCQ?pwd=q43u">https://pan.baidu.com/s/10NLJMQ1W5YS6qeHhy0EjCQ?pwd=q43u</a> </p><p>提取码: q43u </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 精通JavaScript动态网页编程 》</title>
      <link href="/2023/10/07/%E7%B2%BE%E9%80%9AJavaScript%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/10/07/%E7%B2%BE%E9%80%9AJavaScript%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231007100745.png" alt="《 精通JavaScript动态网页编程 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书结合JavaScript1.5和Jscript5.5，由浅入深、循序渐进地全面介绍了JavaScript知识体系编程设计技巧。全书分4篇，共30章，内容涵盖了JavaScript语法、JavaScript核心内容、JavaScript高级以及JavaScript应用等内容，对网页设计中各方面内容进行了详尽。本书最大的特色在于，通过大量的代码实例对各个知识点的实际应用进行讲解，力求例使读者通过对代码的分析，提高学习兴趣，加深对知识点的理解。</p><p>本书适用于各层次、各类网页编程设计人员，同时也可作为高校相关师生和社会培训班的教材。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一篇 javascript基础<br>第1章 javascript简介 3<br>1.1 历史、版本与兼容性 3<br>1.1.1 javascript与ecmascript 3<br>1.1.2 不同浏览器对javascript的支持 4<br>1.1.3 本书对读者知识结构的要求 4<br>1.2 javascript在html中的使用 5<br>1.2.1 在[script][&#x2F;script]中的使用 5<br>1.2.2 代码屏蔽 6<br>1.2.3 在单独文件中使用 7<br>1.2.4 作为属性值使用 8<br>1.3 javascript基本语法 8<br>1.3.1 执行顺序 8<br>1.3.2 大小写敏感 8<br>1.3.3 空白符与换行符 9<br>1.3.4 语句与分隔符 9<br>1.3.5 块 9<br>1.3.6 注释 10<br>1.4 javascript保留字 10<br>1.5 错误与调试 11<br>.1.5.1 语法错误 11<br>1.5.2 逻辑错误 12<br>第2章 数据类型与变量 13<br>2.1 简单数据类型 13<br>2.1.1 数值型 13<br>2.1.2 字串型 16<br>2.1.3 boolean 18<br>2.2 特殊数据类型 19<br>2.2.1 无定义数据类型（undefined） 19<br>2.2.2 空值（null） 19<br>2.3 变量 20<br>2.3.1 类型规则 20<br>2.3.2 声明变量 20<br>2.3.3 变量命名 20<br>2.3.4 作用范围 21<br>2.3.5 基本类型与合成类型 22<br>2.3.6 无用存储单元的收集 23<br>2.3.7 作为属性的变量 24<br>2.4 类型转换 24<br>2.4.1 转换规则 24<br>2.4.2 提升基本数据为对象 26<br>2.4.3 显式类型转换 26<br>2.5 使用值与使用引用 26<br>2.5.1 使用值操作数据 27<br>2.5.2 使用引用操作数据 27<br>2.5.3 原始类型与引用类型 27<br>2.5.4 举例 28<br>2.5.5 字符串的特殊性 29<br>第3章 运算符与表达式 31<br>3.1 表达式 31<br>3.2 算术运算符 32<br>3.2.1 加号（+）的特殊含义 32<br>3.2.2 减号（?）的特殊含义 34<br>3.3 赋值运算符 34<br>3.4 比较运算符 35<br>3.4.1 条件语句中使用&#x3D;符号 35<br>3.4.2 比较运算符的自动转换 36<br>3.5 逻辑运算符 36<br>3.6 位运算符 37<br>3.6.1 普通位运算符 37<br>3.6.2 位移运算符 38<br>3.7 其他运算符 38<br>3.7.1 递增与递减运算符 38<br>3.7.2 算术运算符与位运算符的结合使用 39<br>3.7.3 ?:运算符 39<br>3.7.4 字符串比较 39<br>3.7.5 逗号（,）运算符 40<br>3.7.6 void运算符 40<br>3.7.7 typeof运算符 41<br>3.7.8 对象运算符 41<br>3.8 运算符优先级 42<br>第4章 基本的流程控制语句 45<br>4.1 条件判断语句：if语句 45<br>4.1.1 简单if语句 45<br>4.1.2 if…else语句 46<br>4.1.3 else if语句 47<br>4.1.4 if语句的嵌套 48<br>4.2 条件判断语句：switch语句 49<br>4.3 循环控制语句 50<br>4.3.1 while循环 50<br>4.3.2 do…while循环 51<br>4.3.3 for循环 52<br>4.3.4 循环控制：continue与break语句 54<br>第5章 函数 55<br>5.1 函数的定义与调用 55<br>5.1.1 定义函数 55<br>5.1.2 函数调用 56<br>5.2 全局变量与局部变量 58<br>5.3 参数变量可变的函数 59<br>5.4 创建动态函数 60<br>5.5 javascript的系统函数 60<br>5.5.1 uri编码处理函数 61<br>5.5.2 数值处理函数 62<br>5.5.3 字符串编码处理函数 63<br>5.6 function构造函数与函数直接量 65<br>第6章 javascript对象与数组 67<br>6.1 javascript对象 67<br>6.1.1 对象的创建 67<br>6.1.2 对象的方法 69<br>6.1.3 原型对象和继承 69<br>6.1.4 面向对象的javascript 70<br>6.1.5 构造函数与this关键字 71<br>6.2 javascript中的数组 72<br>6.2.1 数组和数组元素 72<br>6.2.2 用对象的方式实现数组 75<br>6.2.3 array对象及其属性与方法 77<br>6.2.4 作为关联数组的对象 79<br>6.3 javascript内部对象 80<br>6.3.1 object对象 80<br>6.3.2 string对象 80<br>6.3.3 date对象 84<br>6.3.4 tostring方法 85<br>6.4 专门用于对象的语句 86<br>6.4.1 with语句 86<br>6.4.2 for…in语句 87<br>第7章 字符串与数值处理对象 89<br>7.1 字符串对象 89<br>7.1.1 字符串和数值数据类型 89<br>7.1.2 url字符串编码和译码 91<br>7.2 数值处理对象 92<br>7.2.1 javascript中的数值 92<br>7.2.2 math对象 94<br>7.2.3 number对象 96<br>7.2.4 boolean对象 98<br>第8章 正则表达式 99<br>8.1 正则表达式及其作用 99<br>8.2 元字符“?”与“( )” 99<br>8.2.1 用?表示可选项 99<br>8.2.2 用( )表示子匹配 100<br>8.3 regexp对象 100<br>8.4 regexp对象的属性 101<br>8.4.1 静态属性 101<br>8.4.2 实例属性 102<br>8.5 regexp对象的方法 102<br>8.5.1 test方法 102<br>8.5.2 exec方法 103<br>8.5.3 compile方法 104<br>8.5.4 综合举例 104<br>8.6 string对象中的相关方法 105<br>8.6.1 match方法 105<br>8.6.2 search方法 106<br>8.6.3 replace方法 107<br>8.6.4 split方法 107<br>8.7 限定符与选择匹配符 108<br>8.7.1 用限定符指定连续出现的次数 108<br>8.7.2 贪婪匹配与非贪婪匹配 109<br>8.7.3 用选择匹配符进行匹配选择 109<br>8.8 分组组合与反向引用符 109<br>8.8.1 分组组合 109<br>8.8.2 反向引用 110<br>8.8.3 非捕获匹配 110<br>8.8.4 正向“预测先行”匹配 110<br>8.8.5 反向“预测先行”匹配 110<br>8.9 特殊字符与字符匹配符 111<br>8.9.1 特殊字符 111<br>8.9.2 字符匹配符 111<br>8.10 定位符与原义字符 113<br>8.10.1 用于文本验证的定位符 113<br>8.10.2 对特殊字符进行转义 116<br>8.11 实用举例 116<br>8.11.1 普通字符匹配 116<br>8.11.2 限制表单输入的内容 117<br>8.11.3 去除重复字符 117<br>8.11.4 从url中提取文件名 117<br>8.11.5 匹配ip地址 118<br>第二篇 javascript核心技术<br>第9章 事件处理 121<br>9.1 事件与事件处理概述 121<br>9.1.1 事件与事件名称 121<br>9.1.2 事件应用 121<br>9.2 基本事件模型 122<br>9.2.1 xhtml中的事件绑定 122<br>9.2.2 使用javascript绑定事件处<br>理器 127<br>9.2.3 事件处理器的作用域 128<br>9.2.4 事件处理器的返回值 129<br>9.2.5 手动触发事件 130<br>9.3 ie 4+事件模型 133<br>9.3.1 绑定处理器至对象 133<br>9.3.2 event对象 134<br>9.3.3 事件流 135<br>9.4 dom2事件模型 136<br>9.4.1 绑定处理器至对象 136<br>9.4.2 event对象 137<br>9.4.3 鼠标事件 137<br>9.4.4 取消默认动作 139<br>9.4.5 创建事件 140<br>第10章 键盘和鼠标事件处理 143<br>10.1 鼠标事件处理 143<br>10.1.1 在netscape浏览器中使用鼠标事件 143<br>10.1.2 在ie浏览器中使用鼠标事件 144<br>10.1.3 页面布局 145<br>10.1.4 处理mousedown和mouseup事件 145<br>10.1.5 确定用户在使用哪一种浏览器 145<br>10.2 页面预览 151<br>10.3 图像切换 154<br>10.4 接收键盘输入 155<br>10.4.1 使用keypress事件 155<br>10.4.2 在netscape浏览器中读取按键 156<br>10.4.3 在ie浏览器中读取按键 156<br>10.5 用鼠标点亮文本 158<br>10.6 鼠标跟随 161<br>10.6.1 图片跟随鼠标 162<br>10.6.2 文字跟随鼠标 164<br>10.6.3 星星跟随鼠标 166<br>10.7 鼠标感应 170<br>10.7.1 弹出警告框 170<br>10.7.2 渐显图片 171<br>10.8 禁用鼠标右键 172<br>第11章 对象模型 175<br>11.1 对象模型的概念 175<br>11.1.1 对象模型概述 175<br>11.1.2 初始对象模型 175<br>11.2 document对象简介 177<br>11.2.1 document对象的属性与方法 177<br>11.2.2 属性与方法的应用 178<br>11.2.3 文档元素的按位置访问 180<br>11.2.4 文档元素的按名称访问 181<br>11.2.5 事件控制器 181<br>11.3 组合应用 182<br>11.4 动态修改表单元素内容 183<br>第12章 文档对象模型（dom） 187<br>12.1 dom概述 187<br>12.1.1 dom分层 187<br>12.1.2 document树 187<br>12.2 访问元素 189<br>12.2.1 使用元素标识 189<br>12.2.2 dom结点属性 190<br>12.2.3 相邻结点检测 192<br>12.2.4 文档树检测示例 192<br>12.3 结点 194<br>12.3.1 创建 194<br>12.3.2 插入和追加 195<br>12.3.3 结点复制 197<br>12.3.4 删除与替换 198<br>12.3.5 修改 199<br>12.4 属性 201<br>12.4.1 属性使用 201<br>12.4.2 dom与html元素 202<br>12.4.3 dom遍历api 205<br>12.4.4 dom range选择 206<br>12.5 与dhtml相对的dom 207<br>12.5.1 innerhtml属性 208<br>12.5.2 其他类似属性 209<br>12.5.3 document.all[] 210<br>第13章 样式与定位 213<br>13.1 网页对象模型与网页元素对象 213<br>13.1.1 html对象模型方法 213<br>13.1.2 dhtml对象模型方法 214<br>13.1.3 w3c对象模型方法 217<br>13.2 动态网页样式 220<br>13.2.1 样式表简介 220<br>13.2.2 样式的语法规则 220<br>13.2.3 层叠式应用规则 221<br>13.2.4 改变元素对象的样式属性 221<br>13.2.5 改变网页样式表 222<br>13.3 网页对象动态定位 222<br>13.3.1 绝对位置与相对位置 223<br>13.3.2 用z-index设置网页元素<br>13.3.3 坐标位置及尺寸 224<br>13.3.4 控制网页元素对象的显示与隐藏 225<br>13.4 构建跨浏览器dhtml库 225<br>第14章 window对象 231<br>14.1 对话框（dialog） 231<br>14.1.1 警告（alert） 231<br>14.1.2 确认（confirm） 232<br>14.1.3 举例 233<br>14.1.4 提示（prompts） 234<br>14.2 窗口的打开与关闭 236<br>14.2.1 打开窗口 236<br>14.2.2 关闭窗口 237<br>14.2.3 窗口特征 238<br>14.2.4 窗口写入 240<br>14.2.5 dom方法与窗口 242<br>14.3 控制窗口 244<br>14.3.1 移动窗口 244<br>14.3.2 改变窗口大小 245<br>14.3.3 窗口滚动 245<br>14.3.4 设置窗口定位 247<br>14.3.5 访问窗口历史 247<br>14.3.6 控制窗口状态栏 248<br>14.3.7 窗口时间与超时设定 249<br>14.4 窗口事件 250<br>14.4.1 通用窗口事件 251<br>14.4.2 扩展窗口事件 251<br>14.5 ie浏览器窗口扩展 252<br>14.5.1 模式窗口 252<br>14.5.2 无模式窗口 253<br>14.5.3 弹出窗口 253<br>14.5.4 举例 253<br>14.5.5 全屏窗口 255<br>第15章 frame对象 257<br>15.1 特殊的窗口 257<br>15.1.1 使用框架 257<br>15.1.2 访问框架中的窗口 258<br>15.1.3 对框架赋值 260<br>15.2 内联框架 261<br>15.3 框架的嵌套应用 262<br>15.3.1 框架嵌套 262<br>15.3.2 noframes 263<br>15.3.3 命名框架 264<br>15.3.4 框架交叉通信 264<br>15.3.5 嵌套框架交叉通信 266<br>15.4 框架应用 268<br>15.4.1 装入框架 268<br>15.4.2 取消框架 269<br>15.4.3 框架组装 269<br>15.5 用框架进行状态管理 270<br>第16章 处理文档（document） 273<br>16.1 早期文档处理 273<br>16.1.1 文档颜色 273<br>16.1.2 上次修改日期 276<br>16.1.3 定位与相关属性 277<br>16.2 基本document方法 280<br>16.2.1 document.write( )与document.writeln( ) 280<br>16.2.2 其他方法 282<br>16.3 使用document访问传统html元素 283<br>16.3.1 锚与链接 283<br>16.3.2 表单聚集 285<br>16.3.3 表单元素聚集 285<br>16.3.4 图像聚集 286<br>16.4 dom中的相关内容 289<br>16.4.1 dom 1中的文档属性与聚集 289<br>16.4.2 htmlelement 的公用属性与方法 290<br>16.4.3 访问具体html元素属性 291<br>16.5 用dom处理表格 294<br>16.5.1 html 4中的表格 294<br>16.5.2 设置表格属性 297<br>16.5.3 操作表格元素 300<br>16.5.4 操作表元 302<br>16.6 dom应用 305<br>16.6.1 改变[div]的内容 306<br>16.6.2 改变页面样式 306<br>第17章 表单和表单元素 309<br>17.1 表单基础 309<br>17.1.1 表单元素 309<br>17.1.2 访问表单 310<br>17.1.3 访问表单域 310<br>17.2 表单域 312<br>17.2.1 input元素属性 312<br>17.2.2 按钮 312<br>17.2.3 图像按钮 314<br>17.2.4 无显著特征的按钮 314<br>17.2.5 文本域与文本区 315<br>17.2.6 复选框与单选按钮 320<br>17.2.7 文件上传域 322<br>17.3 表单验证 322<br>17.3.1 概述 322<br>17.3.2 编写验证表单 325<br>17.3.3 混合表单验证 327<br>17.3.4 通过隐藏域验证表单 331<br>17.3.5 onchange事件 331<br>17.3.6 按键屏蔽 332<br>17.4 表单可用性与javascript 333<br>17.4.1 起始焦点域 333<br>17.4.2 标签与域选择 333<br>17.4.3 状态信息 334<br>17.4.4 屏蔽域 334<br>17.5 动态表单 335<br>第18章 复选框和单选按钮 339<br>18.1 复选框 339<br>18.1.1 设计思路 339<br>18.1.2 完整代码 340<br>18.2 单选按钮 341<br>18.2.1 设计思路 341<br>18.2.2 完整代码 342<br>18.3 复选框与单选按钮的组合使用 344<br>18.3.1 设计思路 344<br>18.3.2 完整代码 347<br>18.4 使用elements[]数组 350<br>18.4.1 设计步骤 350<br>18.4.2 完整代码 351<br>18.5 选择控件 354<br>18.5.1 单项选择控件 354<br>18.5.2 多项选择控件 355<br>18.5.3 级联选择控件 358<br>第19章 设置菜单 361<br>19.1 下拉菜单 361<br>19.1.1 基本应用 361<br>19.1.2 改进 363<br>19.1.3 渐显效果 365<br>19.2 dhtml菜单 368<br>19.2.1 模拟系统菜单 368<br>19.2.2 远程控制菜单 370<br>19.2.3 滑动菜单 373<br>19.3 常见菜单样式举例 376<br>19.3.1 弹出式菜单 376<br>19.3.2 浮动菜单 378<br>19.3.3 树型导航式菜单 380<br>第20章 浏览器与性能检测 385<br>20.1 浏览器检测 385<br>20.1.1 用于浏览器的navigator对象 385<br>20.1.2 检测初步 386<br>20.2 检测内容 387<br>20.2.1 javascript检测 387<br>20.2.2 javascript版本检测 389<br>20.2.3 javascript对象检测 389<br>20.2.4 java检测 390<br>20.2.5 插件检测 390<br>20.2.6 语言检测 391<br>20.3 用于可视化检测的screen对象 391<br>20.3.1 获取浏览器窗口大小 392<br>20.3.2 设置屏幕对象的尺寸 393<br>20.3.3 有选择地显示图片 394<br>20.4 高级检测技术：示例代码 395<br>20.5 浏览器控制：浏览器按键模拟 396<br>20.6 个性设置：指定主页 397<br>第21章 使用cookie保存状态 399<br>21.1 cookie概述 399<br>21.2 在javascript中使用cookie 400<br>21.2.1 cookie设置 400<br>21.2.2 cookie读取 401<br>21.2.3 cookie分析 401<br>21.2.4 删除cookie 402<br>21.2.5 安全问题 403<br>21.3 管理用户状态 403<br>21.3.1 重定向 403<br>21.3.2 弹出窗口 404<br>21.3.3 用cookie保存定制样式 404<br>21.4 ie浏览器状态扩展 406<br>第22章 图像处理 409<br>22.1 通过单击按钮来改变图像 409<br>22.2 彩色页面 410<br>22.2.1 使用image对象 410<br>22.2.2 使用images[]数组 411<br>22.3 ie浏览器中的结构化图形控件 414<br>22.3.1 属性 414<br>22.3.2 方法 415<br>22.3.3 事件 415<br>22.3.4 设置画笔颜色 416<br>22.3.5 画矩形 416<br>22.3.6 画椭圆 417<br>22.3.7 画扇形 417<br>22.3.8 完整的实例代码 417<br>22.4 在web页面中定位图像 418<br>22.5 在ie浏览器中拖动图像 419<br>22.5.1 mousemove事件 420<br>22.5.2 取消系统拖动事件 420<br>22.6 通用翻转代码 421<br>22.7 应用举例 423<br>22.7.1 跟随屏幕移动的图片 423<br>22.7.2 图像滚动公告板 426<br>22.7.3 左右移动的图片 429<br>22.7.4 图片的渐隐渐显 430<br>22.7.5 不停闪烁的图片 433<br>22.7.6 图片倒映 434<br>第23章 动画 437<br>23.1 应用dhtml 437<br>23.1.1 简单过渡 437<br>23.1.2 目标翻转 441<br>23.1.3 普通动画 442<br>23.2 随机发生器 446<br>23.3 使用ie浏览器的directanimation 447<br>23.3.1 pixellibrary库和meterlibrary库 448<br>23.3.2 使用画板 448<br>23.3.3 创建平移 449<br>23.3.4 创建旋转 450<br>23.3.5 完整代码 451<br>23.4 sequencer控件 453<br>23.4.1 事件与方法 453<br>23.4.2 创建动画 453<br>23.4.3 完整代码 454<br>23.5 path控件 456<br>23.5.1 属性、方法与事件 456<br>23.5.2 创建动画 457<br>23.5.3 完整代码 458<br>23.6 应用实例 459<br>23.6.1 永远居中的背景图片 459<br>23.6.2 随机显示的背景图片 460<br>23.6.3 垂直滚动公告板 461<br>23.6.4 类似flash的字幕效果 464<br>23.6.5 地震效果 465<br>第三篇 javascript高级技术<br>第24章 嵌入式对象 469<br>24.1 java applet 469<br>24.1.1 ie浏览器中的java applet 469<br>24.1.2 在html中引用java applet 469<br>24.1.3 archive属性 470<br>24.1.4 codebase属性 470<br>24.1.5 alt属性 470<br>24.1.6 name属性 470<br>24.1.7 在javascript中访问javaapplet 470<br>24.1.8 java检测 471<br>24.2 插件技术 473<br>24.2.1 插件简介 473<br>24.2.2 使用插件 473<br>24.2.3 mime类型 474<br>24.2.4 检测特殊插件 477<br>24.2.5 实现插件交互 478<br>24.3 activex控件 481<br>24.3.1 在xhtml中的使用 481<br>24.3.2 使代码兼容多种浏览器 481<br>24.3.3 用activex控件实现交互 482<br>第25章 远程javascript 485<br>25.1 单向通信 485<br>25.1.1 概述 485<br>25.1.2 创建image对象 485<br>25.1.3 重定向 486<br>25.2 双向通信 487<br>25.2.1 image对象的不同 487<br>25.2.2 线程 488<br>25.2.3 用cookie替代image 488<br>25.2.4 动态内容 489<br>25.2.5 服务端计算 491<br>25.2.6 回收 492<br>25.2.7 嵌入式框架（iframe）示例 493<br>25.3 xmlhttp对象 494<br>25.3.1 属性与方法 495<br>25.3.2 创建与发送请求 495<br>25.3.3 post 496<br>第26章 javascript与xml 497<br>26.1 xml概述 497<br>26.1.1 xml规范性 497<br>26.1.2 xml有效性 499<br>26.2 显示xml 500<br>26.2.1 使用xslt将xml转换为html 500<br>26.2.2 使用css显示xml文档 504<br>26.2.3 xml与xhtml的结合 505<br>26.3 dom与xml 507<br>26.3.1 internet explorer 507<br>26.3.2 mozilla 510<br>26.4 ie xml数据岛 513<br>26.4.1 格式化输出 513<br>26.4.2 动态增删记录 514<br>26.5 一个rss阅读器的例子 516<br>第27章 javascript的安全 521<br>27.1 同源策略 521<br>27.1.1 同源检测 521<br>27.1.2 嵌入式文档 522<br>27.1.3 外部脚本 522<br>27.1.4 例外 523<br>27.1.5 问题 523<br>27.2 结构化安全规则 524<br>27.2.1 mozilla安全规则 524<br>27.2.2 internet explorer中的安全设置 525<br>27.2.3 activex控件 527<br>27.3 浏览器使用javascript的安全问题 527<br>27.3.1 轰炸 527<br>27.3.2 欺骗 528<br>27.4 跨站点脚本 529<br>27.4.1 潜在的威胁 529<br>27.4.2 预防 530<br>第四篇 javascript典型应用<br>第28章 常用特效设计 533<br>28.1 日期时间设计 533<br>28.1.1 显示当前时间 533<br>28.1.2 显示当前日期和星期 535<br>28.1.3 同时显示日期、时间和星期 536<br>28.1.4 分时段问候 537<br>28.1.5 以数字图片来显示时间 539<br>28.1.6 显示世界不同地区的当前时间 542<br>28.1.7 总是悬浮的时钟 546<br>28.2 计算器设计 549<br>28.2.1 简单的加减乘除运算 549<br>28.2.2 能进行四则混合运算的计算器 552<br>28.3 文字效果设计 554<br>28.4 随机显示的图片 557<br>28.4.1 随页面刷新更换页面背景 557<br>28.4.2 随页面刷新显示不同图片 558<br>第29章 综合应用举例 561<br>29.1 递归 561<br>29.1.1 原理 561<br>29.1.2 汉诺塔问题求解 562<br>29.2 页面广告代码设计 565<br>29.2.1 位置固定的对联广告 565<br>29.2.2 随页面滚动的对联广告 567<br>29.2.3 循环滚动的多幅广告 571<br>29.3 与ajax结合实现级联选择 575<br>29.3.1 javascript的实现 575<br>29.3.2 用ajax的实现 579<br>第30章 与asp的结合开发留言板 587<br>30.1 结构与功能实现 587<br>30.1.1 控制留言长度 587<br>30.1.2 控制留言字体 588<br>30.2 数据库设计 589<br>30.2.1 设置管理信息表 589<br>30.2.2 设置留言信息表 589<br>30.2.3 连接数据库 590<br>30.3 后台管理 590<br>30.3.1 管理员登录 590<br>30.3.2 管理员管理 592<br>30.3.3 基本设置管理 595<br>30.4 填写留言 597<br>30.4.1 用户信息输入 599<br>30.4.2 控制留言长度 600<br>30.4.3 留言内容过滤 602<br>30.4.4 控制文本属性 602<br>30.5 显示留言 605<br>30.5.1 页面控制 605<br>30.5.2 显示用户信息 606<br>30.5.3 显示留言内容 607<br>30.6 留言管理 609<br>30.6.1 修改与回复 609<br>30.6.2 删除留言 611<br>30.6.3 显示用户ip 611<br>30.7 程序运行 612</p><h3 id="精通JavaScript动态网页编程-PDF-下载地址"><a href="#精通JavaScript动态网页编程-PDF-下载地址" class="headerlink" title="精通JavaScript动态网页编程 PDF 下载地址:"></a>精通JavaScript动态网页编程 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/19euB6_xqzmCOQnnSDFz7Cw?pwd=49sb">https://pan.baidu.com/s/19euB6_xqzmCOQnnSDFz7Cw?pwd=49sb</a> </p><p>提取码: 49sb </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 零基础学JavaScript(第2版) 》</title>
      <link href="/2023/10/07/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6JavaScript(%E7%AC%AC2%E7%89%88)/"/>
      <url>/2023/10/07/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6JavaScript(%E7%AC%AC2%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231007101105.png" alt="《 零基础学JavaScript(第2版) 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《零基础学JavaScript》将这两者结合在一起，介绍了如何使用 VisualBasic和sQLServeI开发数据管理软件。全书共分四篇24章，详细介绍了VisualBasic数据库访问技术以及Windows邑用控件的使用、ActiveX组件开发及网络程序开发等方面的内容。</p><p>零基础学JavaScript(第2版)由浅入深、循序渐进地介绍了javascript的语法、各对象的方法和属性的使用方法。全书由3篇组成：第一篇为基础篇，介绍了javascript的数据类型、常量、变量、表达式、运算符、语句、函数、对象和数组；第二篇为实用篇，介绍了javascript的对象层次与事件、窗口对象、屏幕对象、浏览器对象、历史对象、地址对象和文档对象等；第三篇为ajax篇，介绍了ajax的使用方法以及相关技术，还有一些流行的ajax框架，如jquery等。.<br>零基础学JavaScript(第2版)适用于掌握了html语言、想进一步学习如何制作动态网页的入门者，也适用于有一定javascript基础的想进一步提高的网页开发者</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>第一篇 基 础 篇<br>第1章 javascript简介        1<br>第2章 数据类型、常量与变量        5<br>第3章 表达式与运算符        28<br>第4章 语句        71<br>第5章 函数        100<br>第6章 对象        135<br>第7章 数组        191<br>第二篇 实用篇<br>第8章 javascript对象层次与事件处理        213<br>第9章 窗口与框架        236<br>第10章 屏幕对象与浏览器对象        293<br>第11章 历史对象与地址对象        307<br>第12章 文档对象        323<br>第13章 表单对象        371<br>第14章 cookie        433<br>第三篇 ajax篇<br>第15章 ajax初步—无刷新表单提交        451<br>第16章 ajax应用—构造动态加载的树        469<br>第17章 常见的ajax框架介绍        490<br>第1章 变量        1<br>第2章 客户端的流程控制        13<br>第3章 字符串操作        23<br>第4章 数组技术        35<br>第5章 javascript快速处理日期和时间的操作        46<br>第6章 javascript页面处理技巧        59<br>第7章 javascript的鼠标事件和键盘事件        75<br>第8章 窗口大小自动化管理        96<br>第9章 javascript结合文字实现特殊页面        114<br>第10章 页面中的链接地址个性化        134<br>第11章 在html中用javascript控制图像页面        151<br>第12章 菜单特效        173<br>第13章 背景特效        189<br>第14章 页面特效        202<br>第15章 javascript操作表格        224<br>第16章 ajax应用特效        243<br>第17章 prototype基础应用        270</p><h3 id="零基础学JavaScript-第2版-PDF-下载地址"><a href="#零基础学JavaScript-第2版-PDF-下载地址" class="headerlink" title="零基础学JavaScript(第2版) PDF 下载地址:"></a>零基础学JavaScript(第2版) PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1c5PRhrGyMVSoXXLCjWAcLw?pwd=qt2b">https://pan.baidu.com/s/1c5PRhrGyMVSoXXLCjWAcLw?pwd=qt2b</a> </p><p>提取码: qt2b </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 高性能JavaScript 》</title>
      <link href="/2023/10/07/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/"/>
      <url>/2023/10/07/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231007090247.png" alt="《 高性能JavaScript 》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>如果你使用 JavaScript 构建交互丰富的 Web 应用，那么 JavaScript 代码可能是造成你的Web应用速度变慢的主要原因。《高性能JavaScript》揭示的技术和策略能帮助你在开发过程中消除性能瓶颈。你将会了解如何提升各方面的性能，包括代码的加载、运行、DOM 交互、页面生存周期等。雅虎的前端工程师 Nicholas C. Zakas 和其他五位 JavaScript 专家介绍了页面代码加载的最佳方法和编程技巧，来帮助你编写更为高效和快速的代码。你还会了解到构建和部署文件到生产环境的最佳实践，以及有助于定位线上问题的工具。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Nicholas C.Zakas，雅虎首页的主要开发者，雅虎用户界面库（YUI）代码贡献者，擅长利用JavaScript、HTML、CSS、XML、XSLT设计和实现WEB界面的软件工程师。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言 I<br>第1章：加载和执行 1<br>1.1 脚本位置 2<br>1.2 组织脚本 4<br>1.3 无阻塞的脚本 5<br>1.3.1 延迟的脚本 5<br>1.3.2 动态脚本元素 6<br>1.3.3 XMLHttpRequest脚本注入 9<br>1.3.4 推荐的无阻塞模式 10<br>1.4 小结 14<br>第2章：数据访问 15<br>2.1 管理作用域 16<br>2.1.1 作用域链和标识符解析 16<br>2.1.2 标识符解析的性能 19<br>2.1.3 改变作用域链 21<br>2.1.4 动态作用域 24<br>2.1.5 闭包，作用域和内存 24<br>2.2 对象成员 27<br>2.2.1 原型 27<br>2.2.2 原型链 29<br>2.2.3 嵌套成员 30<br>2.2.4 缓存对象成员值 31<br>2.3 小结 33<br>第3章：DOM编程 35<br>3.1 浏览器中的DOM 35<br>3.1.1 天生就慢 36<br>3.2 DOM访问与修改 36<br>3.2.1 innerHTML对比DOM方法 37<br>3.2.2 节点克隆 41<br>3.2.3 HTML集合 42<br>3.2.4 遍历DOM 46<br>3.3 重绘与重排 50<br>3.3.1 重排何时发生？ 51<br>3.3.2 渲染树变化的排队与刷新 51<br>3.3.3 最小化重绘和重排 52<br>3.3.4 缓存布局信息 56<br>3.3.5 让元素脱离动画流 56<br>3.3.6 IE和:hover 57<br>3.4 事件委托 57<br>3.5 小结 59<br>第4章：算法和流程控制 61<br>4.1 循环 61<br>4.1.1 循环的类型 61<br>4.1.2 循环性能 63<br>4.1.3 基于函数的迭代 67<br>4.2 条件语句 68<br>4.2.1 if-else对比switch 68<br>4.2.2 优化if-else 70<br>4.2.3 查找表 72<br>4.3 递归 73<br>4.3.1 调用栈限制 74<br>4.3.2 递归模式 75<br>4.3.3 迭代 76<br>4.3.4 Memoization 77<br>4.4 小结 79<br>第5章：字符串和正则表达式 81<br>5.1 字符串连接 81<br>5.1.1 加（+）和加等于（+&#x3D;）操作符 82<br>5.1.2 数组项连接 84<br>5.1.3 String.prototype.concat 86<br>5.2 正则表达式优化 87<br>5.2.1 正则表达式工作原理 88<br>5.2.2 理解回溯 89<br>5.2.3 回溯失控 91<br>5.2.4 基准测试的说明 96<br>5.2.5 更多提高正则表达式效率的方法 96<br>5.2.6 何时不使用正则表达式 99<br>5.3 去除字符串首尾空白 99<br>5.3.1 使用正则表达式去首尾空白 99<br>5.3.2 不使用正则表达式去除字符串首尾空白 102<br>5.3.3 混合解决方案 103<br>5.4 小结 104<br>第6章：快速响应的用户界面 107<br>6.1 浏览器UI线程 107<br>6.1.1 浏览器限制 109<br>6.1.2 多久才算“太久”？ 110<br>6.2 使用定时器让出时间片段 111<br>6.2.1 定时器基础 112<br>6.2.2 定时器的精度 114<br>6.2.3 使用定时器处理数组 114<br>6.2.4 分割任务 116<br>6.2.5 记录代码运行时间 118<br>6.2.6 定时器与性能 119<br>6.3 Web Workers 120<br>6.3.1 Worker运行环境 120<br>6.3.2 与Worker通信 121<br>6.3.3 加载外部文件 122<br>6.3.4 实际应用 122<br>6.4 小结 124<br>第7章：Ajax 125<br>7.1 数据传输 125<br>7.1.1 请求数据 125<br>7.1.2 发送数据 131<br>7.2 数据格式 134<br>7.2.1 XML 134<br>7.2.2 JSON 137<br>7.2.3 HTML 141<br>7.2.4 自定义格式 142<br>7.2.5 数据格式总结 144<br>7.3 Ajax性能指南 145<br>7.3.1 缓存数据 145<br>7.3.2 了解Ajax类库的局限 148<br>7.4 小结 149<br>第8章：编程实践 151<br>8.1 避免双重求值（Double Evaluation） 151<br>8.2 使用Object&#x2F;Array直接量 153<br>8.3 不要重复工作 154<br>8.3.1 延迟加载 154<br>8.3.2 条件预加载 156<br>8.4 使用速度快的部分 156<br>8.4.1 位操作 156<br>8.4.2 原生方法 159<br>8.5 小结 161<br>第9章：构建并部署高性能JavaScript应用 163<br>9.1 Apache Ant 163<br>9.2 合并多个JavaScript文件 165<br>9.3 预处理JavaScript文件 166<br>9.4 JavaScript压缩 168<br>9.5 构建时处理对比运行时处理 170<br>9.6 JavaScript的HTTP压缩 170<br>9.7 缓存JavaScript文件 171<br>9.8 处理缓存问题 172<br>9.9 使用内容分发网络（CDN） 173<br>9.10 部署JavaScript资源 173<br>9.11 敏捷JavaScript构建过程 174<br>9.12 小结 175<br>第10章：工具 177<br>10.1 JavaScript性能分析 178<br>10.2 YUI Profiler 179<br>10.3 匿名函数 182<br>10.4 Firebug 183<br>10.4.1 控制台面板分析工具 183<br>10.4.2 Console API 184<br>10.4.3 网络面板 185<br>10.5 IE开发人员工具 186<br>10.6 Safari Web检查器（Web Inspector） 188<br>10.6.1 分析面板 189<br>10.6.2 资源面板 191<br>10.7 Chrome开发人员工具 192<br>10.8 脚本阻塞 193<br>10.9 Page Speed 194<br>10.10 Fiddler 196<br>10.11 YSlow 198<br>10.12 dynaTrace Ajax Edition 199<br>10.13 小结 202<br>索引 203</p><h3 id="高性能JavaScript-PDF-下载地址"><a href="#高性能JavaScript-PDF-下载地址" class="headerlink" title="高性能JavaScript PDF 下载地址:"></a>高性能JavaScript PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1sOC7uyyAWFNu63J1MSWRBA?pwd=fwbg">https://pan.baidu.com/s/1sOC7uyyAWFNu63J1MSWRBA?pwd=fwbg</a> </p><p>提取码: fwbg </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kubernetes修炼手册》</title>
      <link href="/2023/07/25/Kubernetes%E4%BF%AE%E7%82%BC%E6%89%8B%E5%86%8C/"/>
      <url>/2023/07/25/Kubernetes%E4%BF%AE%E7%82%BC%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Z3M0B0C6Q1K2M6S5R2U9Q9B1J0K5L1C2.png" alt="《Kubernetes修炼手册》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是一本Kubernetes入门图书，共分为12章，涵盖了Kubernetes的基础知识，并附带了大量的配置案例。此外，还介绍了Kubernetes架构、构建Kubernetes集群、在Kubernetes上部署和管理应用程序、Kubernetes安全，以及云本地、微服务、容器化等术语的含义。本书在内容上不断进行充实和完善，可以帮助读者快速入门Kubernetes。</p><p>本书适合系统管理员、开发人员，以及对Kubernetes感兴趣的初学者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>奈吉尔.波尔顿（Nigel Poulton），亚马逊畅销图书作者，存储专家，Docker技术先驱。奈吉尔有丰富的运维技术经验，著有多部容器相关的图书，并开设了视频培训课程，在业界有非常大的影响力。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 初识Kubernetes 1<br>1.1 Kubernetes的背景 1<br>1.1.1 编排器 1<br>1.1.2 容器化应用 1<br>1.1.3 云原生应用 2<br>1.1.4 微服务应用 2<br>1.2 Kubernetes的诞生 3<br>1.2.1 Kubernetes和Docker 3<br>1.2.2 Kubernetes与Docker Swarm对比 4<br>1.2.3 Kubernetes和Borg：抵抗是徒劳的 5<br>1.2.4 Kubernetes—名字从何而来 5<br>1.3 云操作系统 6<br>1.3.1 云的规模 6<br>1.3.2 应用的调度 7<br>1.3.3 一个简单的模拟 7<br>1.4 总结 7<br>第2章 Kubernetes操作概览 9<br>2.1 Kubernetes概览 9<br>2.1.1 作为集群的Kubernetes 9<br>2.1.2 作为编排器的Kubernetes 10<br>2.1.3 Kubernetes是如何工作的 11<br>2.2 主节点与工作节点 12<br>2.2.1 主节点（控制平面） 12<br>2.2.2 工作节点 15<br>2.3 Kubernetes DNS 17<br>2.4 Kubernetes的应用打包 17<br>2.5 声明式模型与期望状态 18<br>2.6 Pod 20<br>2.6.1 Pod与容器 20<br>2.6.2 Pod深度剖析 21<br>2.6.3 调度单元 22<br>2.6.4 原子操作单位 22<br>2.6.5 Pod的生命周期 22<br>2.7 Deployment 23<br>2.8 服务与稳定的网络 23<br>2.9 总结 26<br>第3章 安装Kubernetes 27<br>3.1 Kubernetes练习环境 27<br>3.2 托管的Kubernetes环境 27<br>3.3 自定义Kubernetes集群 28<br>3.4 安装Kubernetes 28<br>3.5 Play with Kubernetes 28<br>3.6 桌面版Docker 31<br>3.7 Google Kubernetes引擎（GKE） 32<br>3.8 其他安装方法 34<br>3.9 kubectl 34<br>3.10 总结 36<br>第4章 Pod的使用 37<br>4.1 Pod原理 37<br>4.1.1 Pod和容器 38<br>4.1.2 多容器Pod：典型示例 38<br>4.1.3 如何部署Pod 39<br>4.1.4 “解剖”Pod 40<br>4.1.5 Pod与共享网络 40<br>4.1.6 Pod与CGroup 42<br>4.1.7 Pod的原子部署 42<br>4.1.8 Pod的生命周期 42<br>4.1.9 小结 43<br>4.2 Pod实战 43<br>4.2.1 Pod清单文件 44<br>4.2.2 清单文件：共情即代码 45<br>4.2.3 基于清单文件部署Pod 46<br>4.2.4 查看运行中的Pod 46<br>4.2.5 kubectl describe 48<br>4.2.6 kubectl exec：在Pod中执行命令 49<br>4.2.7 kubectl logs 50<br>4.3 总结 50<br>第5章 Kubernetes Deployment 51<br>5.1 Deployment原理 51<br>5.1.1 自愈和扩缩容 52<br>5.1.2 使用Deployment进行滚动升级 54<br>5.1.3 回滚 56<br>5.2 如何创建一个Deployment 56<br>5.2.1 查看Deployment 58<br>5.2.2 访问该应用 59<br>5.3 执行滚动升级 60<br>5.4 执行回滚操作 63<br>5.5 总结 64<br>第6章 Kubernetes Service 65<br>6.1 要点前瞻 65<br>6.2 原理 66<br>6.2.1 Label与松耦合 67<br>6.2.2 Service和Endpoint对象 69<br>6.2.3 从集群内部访问Service 70<br>6.2.4 从集群外部访问Service 70<br>6.2.5 服务发现 72<br>6.2.6 小结 72<br>6.3 Service实战 73<br>6.3.1 命令式 73<br>6.3.2 声明式 76<br>6.4 实例 79<br>6.5 总结 81<br>第7章 服务发现 82<br>7.1 快速入门 82<br>7.2 服务注册 83<br>7.2.1 服务后端 85<br>7.2.2 小结 86<br>7.3 服务发现 86<br>7.3.1 使用集群DNS将名称解析为IP地址 87<br>7.3.2 网络“黑科技” 88<br>7.3.3 小结 89<br>7.4 服务发现与命名空间 90<br>7.5 服务发现问题排查 96<br>7.6 总结 98<br>第8章 Kubernetes存储 99<br>8.1 概述 99<br>8.2 存储提供者 101<br>8.3 容器存储接口（CSI） 101<br>8.4 Kubernetes持久化卷子系统 101<br>8.5 存储类和动态置备 107<br>8.5.1 存储类YAML 108<br>8.5.2 多个存储类 109<br>8.5.3 实现存储类 109<br>8.6 示例 111<br>8.6.1 清理 111<br>8.6.2 创建一个存储类 112<br>8.6.3 创建一个PVC 113<br>8.6.4 清理 114<br>8.6.5 使用默认的StorageClass 115<br>8.7 总结 115<br>第9章 ConfigMap 116<br>9.1 概述 116<br>9.1.1 简单的例子 117<br>9.1.2 例子分析 117<br>9.1.3 解耦的世界 117<br>9.2 ConfigMap原理 118<br>9.2.1 ConfigMap如何工作 119<br>9.2.2 ConfigMap与Kubernetes原生应用 120<br>9.3 ConfigMap实战 120<br>9.3.1 命令式创建ConfigMap 120<br>9.3.2 查看ConfigMap 122<br>9.3.3 声明式创建ConfigMap 123<br>9.3.4 将ConfigMap数据注入Pod和容器 125<br>9.4 总结 129<br>第10章 StatefulSet 130<br>10.1 StatefulSet原理 130<br>10.1.1 StatefulSet中Pod的命名 131<br>10.1.2 按序创建和删除 132<br>10.1.3 删除StatefulSet 133<br>10.1.4 卷 133<br>10.1.5 故障处理 134<br>10.1.6 网络ID和headless Service 134<br>10.2 StatefulSet实战 135<br>10.2.1 部署StorageClass 135<br>10.2.2 创建一个governing headless Service 136<br>10.2.3 部署StatefulSet 137<br>10.2.4 测试点对点发现 140<br>10.2.5 StatefulSet扩缩容 141<br>10.2.6 执行滚动升级 143<br>10.2.7 模拟Pod故障 143<br>10.2.8 删除StatefulSet 145<br>10.3 总结 145<br>第11章 安全模型分析 146<br>11.1 安全模型 146<br>11.2 伪装 146<br>11.2.1 与API Server的安全通信 147<br>11.2.2 Pod间的安全通信 147<br>11.3 篡改 149<br>11.3.1 对Kubernetes组件的篡改 149<br>11.3.2 对运行在Kubernetes中的应用的篡改 150<br>11.4 抵赖 151<br>11.5 信息泄露 153<br>11.5.1 保护集群数据 153<br>11.5.2 保护Pod中的数据 153<br>11.6 拒绝服务 154<br>11.6.1 保护集群资源免于DoS攻击 154<br>11.6.2 保护API Server防范DoS攻击 155<br>11.6.3 保护集群存储防范DoS攻击 155<br>11.6.4 保护应用组件防范DoS攻击 156<br>11.7 提升权限 157<br>11.7.1 保护API Server 157<br>11.7.2 保护Pod 158<br>11.8 Pod安全策略 162<br>11.9 Kubernetes安全展望 164<br>11.10 总结 164<br>第12章 现实中Kubernetes的安全性 165<br>12.1 CI&#x2F;CD流水线 165<br>12.1.1 镜像仓库 165<br>12.1.2 使用已验证的基础镜像 166<br>12.1.3 非标准基础镜像 167<br>12.1.4 控制镜像的访问权限 167<br>12.1.5 从非生产库复制镜像到生产库 168<br>12.1.6 漏洞扫描 168<br>12.1.7 配置即代码 169<br>12.1.8 镜像签名 169<br>12.1.9 镜像晋升工作流 170<br>12.2 基础设施与网络 170<br>12.2.1 集群层负载隔离 170<br>12.2.2 节点隔离 172<br>12.2.3 运行时隔离 172<br>12.2.4 网络隔离 173<br>12.3 身份认证与访问控制管理（IAM） 176<br>12.4 审计与安全监控 177<br>12.4.1 安全配置 177<br>12.4.2 容器与Pod的生命周期事件 178<br>12.4.3 应用的日志 178<br>12.4.4 用户执行的操作 178<br>12.4.5 管理日志数据 179<br>12.4.6 迁移现有App到Kubernetes 179<br>12.5 现实例子 179<br>12.6 总结 180<br>术语表 181<br>延伸 184</p><h3 id="Kubernetes修炼手册-PDF-下载"><a href="#Kubernetes修炼手册-PDF-下载" class="headerlink" title="Kubernetes修炼手册 PDF 下载"></a>Kubernetes修炼手册 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1UbG_qxRIt91Jjz0lQEprsQ?pwd=fdc2">https://pan.baidu.com/s/1UbG_qxRIt91Jjz0lQEprsQ?pwd=fdc2</a> </p><p>提取码: fdc2 </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 开发 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《PHP基础教程（第4版）》</title>
      <link href="/2023/07/25/PHP%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89/"/>
      <url>/2023/07/25/PHP%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/527efa359c7d12f012639a10b4d00cdd.png" alt="《PHP基础教程（第4版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>由贾菡等编译的《PHP基础教程(第4版)》以通俗易懂的语言向初学者介绍了PHP语言的基本概念、使用方法和注意事项。全书通过丰富的示例，引领读者逐步掌握这门流行的Web开发语言，使读者能够上手编写适用于常用场景的PHP脚本。</p><p>《PHP基础教程(第4版)》适合有基本HTML经验的读者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Brian Halligan 市场营销软件开发公司HubSpot创始人兼CEO，致力于帮助其他企业“被目标客户找到”。他也是一位眼光超前的风险投资家、经验丰富的销售及营销主管，常应邀去MIT以及哈佛商学院举办讲座。</p><p>Dharmesh Shah HubSpot公司创始人兼CTO，天使投资人，撰写的博客OnStartups.com拥有大量粉丝。他还屡次应邀就市场营销以及企业家精神这类主题发表演说。</p><p>侯德杰 北京邮电大学英语专业，后取得北京交通大学项目管理硕士学位。目前就职于北京全路通信信号研究设计院，全职翻译和审核文档，曾翻译出版《网络营销实训》，对网络营销有较深入的研究。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1 章 PHP 概述　　 1<br>1.1 HTML 语法基础　　 1<br>1.2 PHP 语法基础　　6<br>1.3 使用FTP 　 8<br>1.4 测试脚本　　 9<br>1.5 向浏览器发送文本　　 12<br>1.6 使用PHP 手册　　14<br>1.7 向浏览器发送HTML 　　16<br>1.8 为脚本添加注释　　19<br>1.9 调试的基本步骤　　21<br>1.10 回顾和实践　　 22<br>第2 章 变量　　 24<br>2.1 什么是变量　　 24<br>2.2 变量语法　　 27<br>2.3 变量类型　　 29<br>2.4 为变量赋值　　 32<br>2.5 理解引号　　 34<br>2.6 回顾和实践　　 37<br>第3 章 HTML 表单和PHP 　　 38<br>3.1 创建简单的表单　　 38<br>3.2 选择表单的method　　 42<br>3.3 使用PHP 接收表单数据　　 44<br>3.4 显示错误　　 48<br>3.5 错误报告　　 51<br>3.6 向页面手动发送数据　　 53<br>3.7 回顾和实践　　 58<br>第4 章 使用数值　　 60<br>4.1 创建表单　　 60<br>4.2 算术运算　　 63<br>4.3 格式化数值　　 67<br>4.4 理解优先级　　 70<br>4.5 数值的自增和自减　　 72<br>4.6 创建随机数　　 75<br>4.7 回顾和实践　　 77<br>第5 章 使用字符串　　 78<br>5.1 创建HTML 表单　　 78<br>5.2 连接字符串　　 81<br>5.3 处理换行符　　 84<br>5.4 HTML 和PHP　　 85<br>5.5 字符串的编码和解码　　89<br>5.6 查找子字符串　　 92<br>5.7 替换局部字符串　　 96<br>5.8 回顾和实践　　 99<br>第6 章 控制结构　　100<br>6.1 创建HTML 表单　　 100<br>6.2 if 条件语句　　 104<br>6.3 验证函数　　 106<br>6.4 使用else 　　110<br>6.5 更多运算符　　112<br>6.6 使用elseif　　 121<br>6.7 switch 条件语句　　 125<br>6.8 for 循环　　 130<br>6.9 回顾和实践　　135<br>第7 章 使用数组　　136<br>7.1 什么是数组　　136<br>7.2 创建数组　　138<br>7.3 向数组添加项　　 141<br>7.4 访问数组元素　　 144<br>7.5 创建多维数组　　 148<br>7.6 数组排序　　 152<br>7.7 字符串和数组之间的转换　　156<br>7.8 在表单中创建数组　　160<br>7.9 回顾和实践　　165<br>第8 章 创建Web 应用程序　　166<br>8.1 创建模板　　 166<br>8.2 使用外部文件　　 175<br>8.3 使用常量　　180<br>8.4 使用日期和时间　　 184<br>8.5 再谈使用PHP 处理HTML 表单　　 188<br>8.6 使表单更具粘性　　 194<br>8.7 发送Email　　 201<br>8.8 输出缓冲　　205<br>8.9 处理HTTP 头　　 209<br>8.10 回顾和实践　　 213<br>第9 章 cookie 和session 　　214<br>9.1 什么是cookie　　 214<br>9.2 创建cookie　　 217<br>9.3 读取cookie　　 223<br>9.4 向cookie 添加参数　　 227<br>9.5 删除cookie　　 230<br>9.6 什么是session　　 233<br>9.7 创建session　　234<br>9.8 访问session 变量　　 237<br>9.9 删除session　　239<br>9.10 回顾和实践　　241<br>第10 章 创建函数　　243<br>10.1 创建和使用简单函数　　243<br>10.2 创建和调用接受参数的函数　　248<br>10.3 设置参数默认值　　 253<br>10.4 创建和使用带有返回值的函数　　 255<br>10.5 理解变量作用域　　 259<br>10.6 回顾和实践　　 264<br>第11 章 文件和目录　　265<br>11.1 文件权限　　265<br>11.2 写入文件　　270<br>11.3 锁定文件　　276<br>11.4 读取文件　　278<br>11.5 处理文件上传　　 281<br>11.6 导航目录　　288<br>11.7 创建目录　　293<br>11.8 增量读取文件　　298<br>11.9 回顾和实践　　 303<br>第12 章 数据库介绍　　305<br>12.1 SQL 介绍　　 305<br>12.2 连接MySQL 　307<br>12.3 MySQL 错误处理　　311<br>12.4 创建和选择数据库　　313<br>12.5 创建表　　316<br>12.6 向数据库插入数据　　320<br>12.7 安全查询数据　　325<br>12.8 从数据库中检索数据　　 328<br>12.9 删除数据库中的数据　　 333<br>12.10 更新数据库中的数据　　 338<br>12.11 回顾和实践　　 343<br>第13 章 将所有的组合在一起　　344<br>13.1 准备开始　　 344<br>13.2 连接数据库　　 346<br>13.3 编写用户定义函数　　 347<br>13.4 创建模板　　349<br>13.5 登录　　 352<br>13.6 登出　　 355<br>13.7 添加名人名言　　 357<br>13.8 列示名人名言　　 361<br>13.9 编辑名人名言　　 364<br>13.10 删除名人名言　　 370<br>13.11 创建主页　　 374<br>13.12 回顾和实践　　378<br>附录A 安装和配置　　379<br>附录B 深入学习PHP 的资源　　397</p><h3 id="PHP基础教程（第4版）-PDF-下载"><a href="#PHP基础教程（第4版）-PDF-下载" class="headerlink" title="PHP基础教程（第4版） PDF 下载"></a>PHP基础教程（第4版） PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1wYnMhDS5kqsgHKb9lSNC3w?pwd=cxu2">https://pan.baidu.com/s/1wYnMhDS5kqsgHKb9lSNC3w?pwd=cxu2</a> </p><p>提取码：cxu2</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 开发 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入剖析Kubernetes》</title>
      <link href="/2023/07/25/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/"/>
      <url>/2023/07/25/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Q8N1H1Z3X5I2A0K8L6K6M1P1U7I9W7L4.png" alt="《深入剖析Kubernetes》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>Kubernetes已成为容器领域当之无愧的事实标准。然而，从过去以物理机和虚拟机为主体的开发运维环境向以容器为核心的基础设施的转变过程，涉及对网络、存储、调度、操作系统、分布式原理等各个方面的容器化理解和改造，很多初学者和从业者在面对容器技术中的种种难题时，要么知识储备不足，要么知识不成体系。本书即为解决这些难题而作，通过深入剖析Kubernetes的本质、核心原理和设计思想，帮你打通学习容器技术的“任督二脉”，让你真正掌握容器技术体系的精髓。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>张磊，《Docker——容器与容器云》主要作者，CNCF TOC成员，Kubernetes社区成员与早期项目维护者，Kubernetes容器运行时和集群调度等多个核心特性的作者之一，长期专注并活跃于容器集群管理和云计算领域。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言 iii<br>第　1章 背景回顾：云原生大事记　2<br>1.1　初出茅庐　2<br>1.2　崭露头角　6<br>1.3　群雄并起　8<br>1.4　尘埃落定　11<br>第　2章 容器技术基础　17<br>2.1　从进程开始说起　17<br>2.2　隔离与限制　21<br>2.3　深入理解容器镜像　27<br>2.4　重新认识Linux容器　36<br>第3章　Kubernetes设计与架构　47<br>3.1　Kubernetes核心设计与架构　47<br>3.2　Kubernetes核心能力与项目定位　51<br>第4章　Kubernetes集群搭建与配置　56<br>4.1　Kubernetes部署利器：kubeadm　56<br>4.2　从0到1：搭建一个完整的Kubernetes集群　63<br>4.3　第 一个Kubernetes应用　73<br>第5章　Kubernetes编排原理　82<br>5.1　为什么我们需要Pod　82<br>5.2　深入解析Pod对象　91<br>5.3　Pod对象使用进阶　96<br>5.4　编排确实很简单：谈谈“控制器”思想　109<br>5.5　经典PaaS的记忆：作业副本与水平扩展　112<br>5.6　深入理解StatefulSet（一）：拓扑状态　121<br>5.7　深入理解StatefulSet（二）：存储状态　127<br>5.8　深入理解StatefulSet（三）：有状态应用实践　133<br>5.9　容器化守护进程：DaemonSet　147<br>5.10　撬动离线业务：Job与CronJob　156<br>5.11　声明式API与Kubernetes编程范式　166<br>5.12　声明式API的工作原理　175<br>5.13　API编程范式的具体原理　185<br>5.14　基于角色的权限控制：RBAC　196<br>5.15　聪明的微创新：Operator 工作原理解读　204<br>第6章　Kubernetes存储原理　217<br>6.1　持久化存储：PV和PVC的设计与实现原理　217<br>6.2　深入理解本地持久化数据卷　226<br>6.3　开发自己的存储插件：FlexVolume与CSI　233<br>6.4　容器存储实践：CSI插件编写指南　242<br>第7章　Kubernetes网络原理　253<br>7.1　单机容器网络的实现原理　253<br>7.2　深入解析容器跨主机网络　260<br>7.3　Kubernetes网络模型与CNI网络插件　268<br>7.4　解读Kubernetes三层网络方案　276<br>7.5　Kubernetes中的网络隔离：NetworkPolicy　285<br>7.6　找到容器不容易：Service、DNS与服务发现　293<br>7.7　从外界连通Service与Service 调试“三板斧”　299<br>7.8　Kubernetes中的Ingress对象　304<br>第8章　Kubernetes调度与资源管理　312<br>8.1　Kubernetes的资源模型与资源管理　312<br>8.2　Kubernetes的默认调度器　317<br>8.3　Kubernetes默认调度器调度策略解析　321<br>8.4　Kubernetes默认调度器的优先级和抢占机制　326<br>8.5　Kubernetes GPU管理与Device Plugin 机制　330<br>第9章　容器运行时　335<br>9.1　幕后英雄：SIG-Node与CRI　335<br>9.2　解读CRI与容器运行时　339<br>9.3　绝不仅仅是安全：Kata Containers与gVisor　343<br>第　10章 Kubernetes监控与日志　349<br>10.1　Prometheus、Metrics Server与Kubernetes监控体系　349<br>10.2　Custom Metrics：让Auto Scaling不再“食之无味”　353<br>10.3　容器日志收集与管理：让日志无处可逃　358<br>第　11章 Kubernetes应用管理进阶　366<br>11.1　再谈Kubernetes的本质与云原生　366<br>11.2　声明式应用管理简介　368<br>11.3　声明式应用管理进阶　370<br>11.4　打造以应用为中心的Kubernetes　374<br>第　12章 Kubernetes开源社区　378<br>结语　Kubernetes：赢开发者赢天下　382</p><h3 id="深入剖析Kubernetes-PDF-下载"><a href="#深入剖析Kubernetes-PDF-下载" class="headerlink" title="深入剖析Kubernetes PDF 下载"></a>深入剖析Kubernetes PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1Pw4QDG5GkwsalZLJPFQ7yQ?pwd=xw66">https://pan.baidu.com/s/1Pw4QDG5GkwsalZLJPFQ7yQ?pwd=xw66</a> </p><p>提取码: xw66 </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 开发 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kubernetes in Action中文版》</title>
      <link href="/2023/05/24/Kubernetes%20in%20Action%E4%B8%AD%E6%96%87%E7%89%88/"/>
      <url>/2023/05/24/Kubernetes%20in%20Action%E4%B8%AD%E6%96%87%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/4311db6aa915c642bafafcf5873fd2d5.png" alt="《Kubernetes in Action中文版》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《Kubernetes in Action中文版》主要讲解如何在 Kubernetes 中部署分布式容器应用。《Kubernetes in Action中文版》开始部分概要介绍了 Docker 和Kubernetes 的由来和发展，然后通过在 Kubernetes 中部署一个应用程序，一点点增加功能，逐步加深我们对于Kubernetes架构的理解和操作的实践。在本书的后面部分，也可以学习一些高阶的主题，比如监控、调试及伸缩。 Kubernetes是希腊文，意思是“舵手”，带领我们安全地到达未知水域。Kubernetes这样的容器编排系统，会帮助我们妥善地管理分布式应用的部署结构和线上流量，高效地组织容器和服务。Kubernetes 作为数据中心操作系统，在设计软件系统时，能够尽量降低在底层网络和硬件设施上的负担。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Marko Luksa是一位拥有20年以上专业开发经验的软件工程师，经手项目小到简单的Web应用，大到ERP系统、框架和中间件软件，应有尽有。在为Red Hat工作期间，他从Google App Engine API实现的开发起步, 这些API将基于Red Hat的JBoss中间件产品，之后他一直在为CDI&#x2F;Weld、Infinispan&#x2F;JBoss DataGrid等项目贡献力量。2014后, 他加入Red Hat的Cloud Enablement团队，负责 Kubernetes和相关技术开发的更新，保障公司的中间件软件能将Kubernetes与OpenShift特性的潜能用到极致。 译者简介 七牛容器云 （KIRK）团队，是负责七牛云基于自身公有云业务在容器方面的多年实践经验，针对企业应用快速部署、便捷运维打造的容器云计算平台。提供持续集成、弹性伸缩、应用市场等功能特性，使企业专注于业务逻辑开发，缩短业务上线周期，优化资源利用率，提高服务响应效率的一支技术团队。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>1Kubernetes介绍1<br>1.1Kubernetes系统的需求2<br>1.1.1从单体应用到微服务2<br>1.1.2为应用程序提供一个一致的环境5<br>1.1.3迈向持续交付：DevOps和无运维6<br>1.2介绍容器技术7<br>1.2.1什么是容器7<br>1.2.2Docker容器平台介绍11<br>1.2.3rkt——一个Docker的替代方案14<br>1.3Kubernetes介绍15<br>1.3.1初衷15<br>1.3.2深入浅出地了解Kubernetes15<br>1.3.3Kubernetes集群架构17<br>1.3.4在Kubernetes中运行应用18<br>1.3.5使用Kubernetes的好处20<br>1.4本章小结22<br>2开始使用Kubernetes和Docker23<br>2.1创建、运行及共享容器镜像23<br>2.1.1安装Docker并运行HelloWorld容器24<br>2.1.2创建一个简单的Node.js应用26<br>2.1.3为镜像创建Dockerfile27<br>2.1.4构建容器镜像27<br>2.1.5运行容器镜像30<br>2.1.6探索运行容器的内部31<br>2.1.7停止和删除容器32<br>2.1.8向镜像仓库推送镜像33<br>2.2配置Kubernetes集群34<br>2.2.1用Minikube运行一个本地单节点Kubernetes集群34<br>2.2.2使用GoogleKubernetesEngine托管Kubernetes集群36<br>2.2.3为kubectl配置别名和命令行补齐39<br>2.3在Kubernetes上运行第一个应用40<br>2.3.1部署Node.js应用40<br>2.3.2访问Web应用43<br>2.3.3系统的逻辑部分45<br>2.3.4水平伸缩应用46<br>2.3.5查看应用运行在哪个节点上49<br>2.3.6介绍Kubernetesdashboard50<br>2.4本章小结51<br>3pod：运行于Kubernetes中的容器53<br>3.1介绍pod53<br>3.1.1为何需要pod54<br>3.1.2了解pod55<br>3.1.3通过pod合理管理容器56<br>3.2以YAML或JSON描述文件创建pod58<br>3.2.1检查现有pod的YAML描述文件59<br>3.2.2为pod创建一个简单的YAML描述文件61<br>3.2.3使用kubectlcreate来创建pod63<br>3.2.4查看应用程序日志64<br>3.2.5向pod发送请求65<br>3.3使用标签组织pod66<br>3.3.1介绍标签66<br>3.3.2创建pod时指定标签67<br>3.3.3修改现有pod的标签68<br>3.4通过标签选择器列出pod子集69<br>3.4.1使用标签选择器列出pod69<br>3.4.2在标签选择器中使用多个条件71<br>3.5使用标签和选择器来约束pod调度71<br>3.5.1使用标签分类工作节点72<br>3.5.2将pod调度到特定节点72<br>3.5.3调度到一个特定节点73<br>3.6注解pod73<br>3.6.1查找对象的注解74<br>3.6.2添加和修改注解74<br>3.7使用命名空间对资源进行分组75<br>3.7.1了解对命名空间的需求75<br>3.7.2发现其他命名空间及其pod75<br>3.7.3创建一个命名空间76<br>3.7.4管理其他命名空间中的对象77<br>3.7.5命名空间提供的隔离78<br>3.8停止和移除pod78<br>3.8.1按名称删除pod78<br>3.8.2使用标签选择器删除pod79<br>3.8.3通过删除整个命名空间来删除pod80<br>3.8.4删除命名空间中的所有pod，但保留命名空间80<br>3.8.5删除命名空间中的（几乎）所有资源80<br>3.9本章小结81<br>4副本机制和其他控制器：部署托管的pod83<br>4.1保持pod健康84<br>4.1.1介绍存活探针84<br>4.1.2创建基于HTTP的存活探针85<br>4.1.3使用存活探针86<br>4.1.4配置存活探针的附加属性87<br>4.1.5创建有效的存活探针88<br>4.2了解ReplicationController89<br>4.2.1ReplicationController的操作90<br>4.2.2创建一个ReplicationController92<br>4.2.3使用ReplicationController94<br>4.2.4将pod移入或移出ReplicationController的作用域97<br>4.2.5修改pod模板100<br>4.2.6水平缩放pod101<br>4.2.7删除一个ReplicationController103<br>4.3使用ReplicaSet而不是ReplicationController104<br>4.3.1比较ReplicaSet和ReplicationController104<br>4.3.2定义ReplicaSet105<br>4.3.3创建和检查ReplicaSet106<br>4.3.4使用ReplicaSet的更富表达力的标签选择器106<br>4.3.5ReplicaSet小结107<br>4.4使用DaemonSet在每个节点上运行一个pod107<br>4.4.1使用DaemonSet在每个节点上运行一个pod108<br>4.4.2使用DaemonSet只在特定的节点上运行pod109<br>4.5运行执行单个任务的pod112<br>4.5.1介绍Job资源112<br>4.5.2定义Job资源113<br>4.5.3看Job运行一个pod114<br>4.5.4在Job中运行多个pod实例114<br>4.5.5限制Jobpod完成任务的时间116<br>4.6安排Job定期运行或在将来运行一次116<br>4.6.1创建一个CronJob116<br>4.6.2了解计划任务的运行方式118<br>4.7本章小结118<br>5服务：让客户端发现pod并与之通信121<br>5.1介绍服务122<br>5.1.1创建服务123<br>5.1.2服务发现129<br>5.2连接集群外部的服务132<br>5.2.1介绍服务endpoint133<br>5.2.2手动配置服务的endpoint133<br>5.2.3为外部服务创建别名135<br>5.3将服务暴露给外部客户端136<br>5.3.1使用NodePort类型的服务137<br>5.3.2通过负载均衡器将服务暴露出来140<br>5.3.3了解外部连接的特性142<br>5.4通过Ingress暴露服务143<br>5.4.1创建Ingress资源145<br>5.4.2通过Ingress访问服务146<br>5.4.3通过相同的Ingress暴露多个服务147<br>5.4.4配置Ingress处理TLS传输149<br>5.5pod就绪后发出信号150<br>5.5.1介绍就绪探针151<br>5.5.2向pod添加就绪探针152<br>5.5.3了解就绪探针的实际作用154<br>5.6使用headless服务来发现独立的pod155<br>5.6.1创建headless服务156<br>5.6.2通过DNS发现pod156<br>5.6.3发现所有的pod——包括未就绪的pod157<br>5.7排除服务故障158<br>5.8本章小结159<br>6卷：将磁盘挂载到容器161<br>6.1介绍卷162<br>6.1.1卷的应用示例162<br>6.1.2介绍可用的卷类型164<br>6.2通过卷在容器之间共享数据165<br>6.2.1使用emptyDir卷165<br>6.2.2使用Git仓库作为存储卷168<br>6.3访问工作节点文件系统上的文件171<br>6.3.1介绍hostPath卷171<br>6.3.2检查使用hostPath卷的系统pod172<br>6.4使用持久化存储173<br>6.4.1使用GCE持久磁盘作为pod存储卷174<br>6.4.2通过底层持久化存储使用其他类型的卷177<br>6.5从底层存储技术解耦pod179<br>6.5.1介绍持久卷和持久卷声明179<br>6.5.2创建持久卷180<br>6.5.3通过创建持久卷声明来获取持久卷182<br>6.5.4在pod中使用持久卷声明184<br>6.5.5了解使用持久卷和持久卷声明的好处185<br>6.5.6回收持久卷186<br>6.6持久卷的动态卷配置187<br>6.6.1通过StorageClass资源定义可用存储类型188<br>6.6.2请求持久卷声明中的存储类188<br>6.6.3不指定存储类的动态配置190<br>6.7本章小结193<br>7ConfigMap和Secret：配置应用程序195<br>7.1配置容器化应用程序195<br>7.2向容器传递命令行参数196<br>7.2.1在Docker中定义命令与参数196<br>7.2.2在Kubernetes中覆盖命令和参数199<br>7.3为容器设置环境变量200<br>7.3.1在容器定义中指定环境变量201<br>7.3.2在环境变量值中引用其他环境变量201<br>7.3.3了解硬编码环境变量的不足之处202<br>7.4利用ConfigMap解耦配置202<br>7.4.1ConfigMap介绍202<br>7.4.2创建ConfigMap203<br>7.4.3给容器传递ConfigMap条目作为环境变量206<br>7.4.4一次性传递ConfigMap的所有条目作为环境变量208<br>7.4.5传递ConfigMap条目作为命令行参数209<br>7.4.6使用configMap卷将条目暴露为文件210<br>7.4.7更新应用配置且不重启应用程序216<br>7.5使用Secret给容器传递敏感数据218<br>7.5.1介绍Secret218<br>7.5.2默认令牌Secret介绍218<br>7.5.3创建Secret220<br>7.5.4对比ConfigMap与Secret221<br>7.5.5在pod中使用Secret222<br>7.6本章小结228<br>8从应用访问pod元数据以及其他资源229<br>8.1通过DownwardAPI传递元数据229<br>8.1.1了解可用的元数据230<br>8.1.2通过环境变量暴露元数据231<br>8.1.3通过downwardAPI卷来传递元数据234<br>8.2与KubernetesAPI服务器交互237<br>8.2.1探究KubernetesRESTAPI238<br>8.2.2从pod内部与API服务器进行交互242<br>8.2.3通过ambassador容器简化与API服务器的交互248<br>8.2.4使用客户端库与API服务器交互251<br>8.3本章小结253<br>9Deployment:声明式地升级应用255<br>9.1更新运行在pod内的应用程序256<br>9.1.1删除旧版本pod，使用新版本pod替换257<br>9.1.2先创建新pod再删除旧版本pod257<br>9.2使用ReplicationController实现自动的滚动升级259<br>9.2.1运行第一个版本的应用259<br>9.2.2使用kubectl来执行滚动式升级261<br>9.2.3为什么kubectlrolling-update已经过时265<br>9.3使用Deployment声明式地升级应用266<br>9.3.1创建一个Deployment267<br>9.3.2升级Deployment269<br>9.3.3回滚Deployment273<br>9.3.4控制滚动升级速率276<br>9.3.5暂停滚动升级278<br>9.3.6阻止出错版本的滚动升级279<br>9.4本章小结284<br>10StatefulSet：部署有状态的多副本应用285<br>10.1复制有状态pod285<br>10.1.1运行每个实例都有单独存储的多副本286<br>10.1.2每个pod都提供稳定的标识287<br>10.2了解Statefulset289<br>10.2.1对比Statefulset和ReplicaSet289<br>10.2.2提供稳定的网络标识290<br>10.2.3为每个有状态实例提供稳定的专属存储292<br>10.2.4Statefulset的保障294<br>10.3使用Statefulset295<br>10.3.1创建应用和容器镜像295<br>10.3.2通过Statefulset部署应用296<br>10.3.3使用你的pod301<br>10.4在Statefulset中发现伙伴节点305<br>10.4.1通过DNS实现伙伴间彼此发现306<br>10.4.2更新Statefulset308<br>10.4.3尝试集群数据存储309<br>10.5了解Statefulset如何处理节点失效310<br>10.5.1模拟一个节点的网络断开310<br>10.5.2手动删除pod312<br>10.6本章小结313<br>11了解Kubernetes机理315<br>11.1了解架构315<br>11.1.1Kubernetes组件的分布式特性316<br>11.1.2Kubernetes如何使用etcd318<br>11.1.3API服务器做了什么322<br>11.1.4API服务器如何通知客户端资源变更324<br>11.1.5了解调度器325<br>11.1.6介绍控制器管理器中运行的控制器327<br>11.1.7Kubelet做了什么331<br>11.1.8KubernetesServiceProxy的作用332<br>11.1.9介绍Kubernetes插件333<br>11.1.10总结概览335<br>11.2控制器如何协作335<br>11.2.1了解涉及哪些组件335<br>11.2.2事件链336<br>11.2.3观察集群事件337<br>11.3了解运行中的pod是什么339<br>11.4跨pod网络340<br>11.4.1网络应该是什么样的340<br>11.4.2深入了解网络工作原理341<br>11.4.3引入容器网络接口343<br>11.5服务是如何实现的344<br>11.5.1引入kube-proxy344<br>11.5.2kube-proxy如何使用iptables344<br>11.6运行高可用集群346<br>11.6.1让你的应用变得高可用346<br>11.6.2让Kubernetes控制平面变得高可用347<br>11.7本章小结350<br>12KubernetesAPI服务器的安全防护351<br>12.1了解认证机制351<br>12.1.1用户和组352<br>12.1.2ServiceAccount介绍353<br>12.1.3创建ServiceAccount354<br>12.1.4将ServiceAccount分配给pod356<br>12.2通过基于角色的权限控制加强集群安全358<br>12.2.1介绍RBAC授权插件359<br>12.2.2介绍RBAC资源360<br>12.2.3使用Role和RoleBinding363<br>12.2.4使用ClusterRole和ClusterRoleBinding367<br>12.2.5了解默认的ClusterRole和ClusterRoleBinding376<br>12.2.6理性地授予授权权限379<br>12.3本章小结379<br>13保障集群内节点和网络安全381<br>13.1在pod中使用宿主节点的Linux命名空间381<br>13.1.1在pod中使用宿主节点的网络命名空间382<br>13.1.2绑定宿主节点上的端口而不使用宿主节点的网络命名空间383<br>13.1.3使用宿主节点的PID与IPC命名空间385<br>13.2配置节点的安全上下文386<br>13.2.1使用指定用户运行容器387<br>13.2.2阻止容器以root用户运行388<br>13.2.3使用特权模式运行pod389<br>13.2.4为容器单独添加内核功能390<br>13.2.5在容器中禁用内核功能391<br>13.2.6阻止对容器根文件系统的写入392<br>13.2.7容器使用不同用户运行时共享存储卷394<br>13.3限制pod使用安全相关的特性396<br>13.3.1PodSecurityPolicy资源介绍396<br>13.3.2了解runAsUser、fsGroup和supplementalGroup策略398<br>13.3.3配置允许、默认添加、禁止使用的内核功能400<br>13.3.4限制pod可以使用的存储卷类型402<br>13.3.5对不同的用户与组分配不同的PodSecurityPolicy402<br>13.4隔离pod的网络406<br>13.4.1在一个命名空间中启用网络隔离406<br>13.4.2允许同一命名空间中的部分pod访问一个服务端pod407<br>13.4.3在不同Kubernetes命名空间之间进行网络隔离408<br>13.4.4使用CIDR隔离网络409<br>13.4.5限制pod的对外访问流量409<br>13.5本章小结410<br>14计算资源管理411<br>14.1为pod中的容器申请资源411<br>14.1.1创建包含资源requests的pod412<br>14.1.2资源requests如何影响调度413<br>14.1.3CPUrequests如何影响CPU时间分配418<br>14.1.4定义和申请自定义资源418<br>14.2限制容器的可用资源419<br>14.2.1设置容器可使用资源量的硬限制419<br>14.2.2超过limits421<br>14.2.3容器中的应用如何看待limits422<br>14.3了解podQoS等级423<br>14.3.1定义pod的QoS等级424<br>14.3.2内存不足时哪个进程会被杀死426<br>14.4为命名空间中的pod设置默认的requests和limits427<br>14.4.1LimitRange资源简介428<br>14.4.2LimitRange对象的创建428<br>14.4.3强制进行限制430<br>14.4.4应用资源requests和limits的默认值430<br>14.5限制命名空间中的可用资源总量431<br>14.5.1ResourceQuota资源介绍431<br>14.5.2为持久化存储指定配额434<br>14.5.3限制可创建对象的个数434<br>14.5.4为特定的pod状态或者QoS等级指定配额435<br>14.6监控pod的资源使用量436<br>14.6.1收集、获取实际资源使用情况437<br>14.6.2保存并分析历史资源的使用统计信息439<br>14.7本章小结442<br>15自动横向伸缩pod与集群节点443<br>15.1pod的横向自动伸缩444<br>15.1.1了解自动伸缩过程444<br>15.1.2基于CPU使用率进行自动伸缩447<br>15.1.3基于内存使用进行自动伸缩453<br>15.1.4基于其他自定义度量进行自动伸缩453<br>15.1.5确定哪些度量适合用于自动伸缩456<br>15.1.6缩容到0个副本456<br>15.2pod的纵向自动伸缩456<br>15.2.1自动配置资源请求457<br>15.2.2修改运行中pod的资源请求457<br>15.3集群节点的横向伸缩457<br>15.3.1ClusterAutoscaler介绍457<br>15.3.2启用ClusterAutoscaler459<br>15.3.3限制集群缩容时的服务干扰460<br>15.4本章小结461<br>16高级调度463<br>16.1使用污点和容忍度阻止节点调度到特定节点463<br>16.1.1介绍污点和容忍度464<br>16.1.2在节点上添加自定义污点466<br>16.1.3在pod上添加污点容忍度467<br>16.1.4了解污点和污点容忍度的使用场景467<br>16.2使用节点亲缘性将pod调度到特定节点上469<br>16.2.1指定强制性节点亲缘性规则470<br>16.2.2调度pod时优先考虑某些节点472<br>16.3使用pod亲缘性与非亲缘性对pod进行协同部署475<br>16.3.1使用pod间亲缘性将多个pod部署在同一个节点上475<br>16.3.2将pod部署在同一机柜、可用性区域或者地理地域478<br>16.3.3表达pod亲缘性优先级取代强制性要求479<br>16.3.4利用pod的非亲缘性分开调度pod481<br>16.4本章小结483<br>17开发应用的最佳实践485<br>17.1集中一切资源486<br>17.2了解pod的生命周期487<br>17.2.1应用必须预料到会被杀死或者重新调度487<br>17.2.2重新调度死亡的或者部分死亡的pod490<br>17.2.3以固定顺序启动pod491<br>17.2.4增加生命周期钩子493<br>17.2.5了解pod的关闭497<br>17.3确保所有的客户端请求都得到了妥善处理500<br>17.3.1在pod启动时避免客户端连接断开500<br>17.3.2在pod关闭时避免客户端连接断开501<br>17.4让应用在Kubernetes中方便运行和管理505<br>17.4.1构建可管理的容器镜像505<br>17.4.2合理地给镜像打标签，正确地使用ImagePullPolicy506<br>17.4.3使用多维度而不是单维度的标签506<br>17.4.4通过注解描述每个资源506<br>17.4.5给进程终止提供更多的信息507<br>17.4.6处理应用日志508<br>17.5开发和测试的最佳实践510<br>17.5.1开发过程中在Kubernetes之外运行应用510<br>17.5.2在开发过程中使用Minikube512<br>17.5.3发布版本和自动部署资源清单513<br>17.5.4使用Ksonnet作为编写YAML&#x2F;JSONmanifest文件的额外选择513<br>17.5.5利用持续集成和持续交付514<br>17.6本章小结515<br>18Kubernetes应用扩展517<br>18.1定义自定义API对象517<br>18.1.1CustomResourceDefinitions介绍518<br>18.1.2使用自定义控制器自动定制资源522<br>18.1.3验证自定义对象526<br>18.1.4为自定义对象提供自定义API服务器527<br>18.2使用Kubernetes服务目录扩展Kubernetes528<br>18.2.1服务目录介绍529<br>18.2.2服务目录API服务器与控制器管理器介绍530<br>18.2.3Service代理和OpenServiceBrokerAPI530<br>18.2.4提供服务与使用服务533<br>18.2.5解除绑定与取消配置535<br>18.2.6服务目录给我们带来了什么535<br>18.3基于Kubernetes搭建的平台536<br>18.3.1红帽OpenShift容器平台536<br>18.3.2DeisWorkflow与Helm539<br>18.4本章小结541<br>A在多个集群中使用kubectl543<br>B使用kubeadm配置多节点集群549<br>C使用其他容器运行时563<br>DClusterFederation567</p><h3 id="Kubernetes-in-Action中文版-PDF-下载地址"><a href="#Kubernetes-in-Action中文版-PDF-下载地址" class="headerlink" title="Kubernetes in Action中文版 PDF 下载地址:"></a>Kubernetes in Action中文版 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1WeU06FLqA0dFtOSO6Kj49Q?pwd=42h4">https://pan.baidu.com/s/1WeU06FLqA0dFtOSO6Kj49Q?pwd=42h4</a> </p><p>提取码：42h4</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Lua程序设计》</title>
      <link href="/2023/05/24/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/05/24/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cf9e4f3d7bd23092d0bd78cf82db10d1.png" alt="《Lua程序设计》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《Lua程序设计（第4版）》由Lua 语言作者亲自撰写，针对Lua 语言本身由浅入深地从各个方面进行了完整和细致的讲解。作为第4 版，《Lua程序设计（第4版）》主要针对的是Lua 5.3，这是《Lua程序设计（第4版）》撰写时Lua 语言的最新版本。作者从语言使用者的角度出发，讲解了语言基础、编程实操、高级特性及C 语言API 等四个方面的内容，既有Lua 语言基本数据类型、输入输出、控制结构等基础知识，也有对模块、闭包、元表、协程、延续、反射、环境、垃圾回收、函数式编程、面向对象编程、C 语言API 等高级特性的系统讲解，还有对Lua 5.3 中引入的整型、位运算、瞬表、延续等新功能的细致说明。 所有与Lua 语言打交道的人均能从《Lua程序设计（第4版）》受益，包括游戏、嵌入式、物联网、软件安全、逆向工程、移动互联网、C 语言核心系统开发等诸多领域中对Lua 语言有一般使用需要的从业人员，以及需要从编译原理或语言设计哲学和实现角度深入学习Lua 语言脚本引擎的高级开发者或研究人员。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第 1 部分 语言基础 1<br>1 Lua 语言入门 2<br>1.1 程序段 3<br>1.2 一些词法规范 5<br>1.3 全局变量 7<br>1.4 类型和值 7<br>1.4.1 nil 8<br>1.4.2 Boolean 8<br>1.5 独立解释器 10<br>1.6 练习 12<br>2 小插曲：八皇后问题 13<br>2.1 练习 15<br>3 数值 17<br>3.1 数值常量 17<br>3.2 算术运算 19<br>3.3 关系运算 21<br>3.4 数学库 21<br>3.4.1 随机数发生器 22<br>3.4.2 取整函数 22<br>3.5 表示范围 24<br>3.6 惯例 25<br>3.7 运算符优先级 26<br>3.8 兼容性 27<br>3.9 练习 28<br>4 字符串 30<br>4.1 字符串常量 31<br>4.2 长字符串&#x2F;多行字符串 33<br>4.3 强制类型转换 34<br>4.4 字符串标准库 36<br>4.5 Unicode 编码 39<br>4.6 练习 41<br>5 表 43<br>5.1 表索引 44<br>5.2 表构造器 46<br>5.3 数组、列表和序列 48<br>5.4 遍历表 50<br>5.5 安全访问 52<br>5.6 表标准库 53<br>5.7 练习 54<br>6 函数 56<br>6.1 多返回值 58<br>6.2 可变长参数函数 61<br>6.3 函数 table.unpack 64<br>6.4 正确的尾调用 65<br>6.5 练习 66<br>7 输入输出 68<br>7.1 简单 I&#x2F;O 模型 68<br>7.2 完整 I&#x2F;O 模型 72<br>7.3 其他文件操作 74<br>7.4 其他系统调用 75<br>7.4.1 运行系统命令 75<br>7.5 练习 77<br>8 补充知识 78<br>8.1 局部变量和代码块 78<br>8.2 控制结构 80<br>8.2.1 if then else 81<br>8.2.2 while 81<br>8.2.3 repeat 82<br>8.2.4 数值型 for 82<br>8.2.5 泛型 for 83<br>8.3 break、return 和 goto 84<br>8.4 练习 88<br>第 2 部分 编程实操 90<br>9 闭包 91<br>9.1 函数是第一类值 92<br>9.2 非全局函数 94<br>9.3 词法定界 96<br>9.4 小试函数式编程 100<br>9.5 练习 103<br>10 模式匹配 105<br>10.1 模式匹配的相关函数 105<br>10.1.1 函数 string.find 105<br>10.1.2 函数 string.match 106<br>10.1.3 函数 string.gsub 107<br>10.1.4 函数 string.gmatch 107<br>10.2 模式 108<br>10.3 捕获 112<br>10.4 替换 114<br>10.4.1 URL 编码 116<br>10.4.2 制表符展开 118<br>10.5 诀窍 119<br>10.6 练习 123<br>11 小插曲：出现频率最高的单词 124<br>11.1 练习 126<br>12 日期和时间 128<br>12.1 函数 os.time 129<br>12.2 函数 os.date 130<br>12.3 日期和时间处理 132<br>12.4 练习 134<br>13 位和字节 135<br>13.1 位运算 135<br>13.2 无符号整型数 136<br>13.3 打包和解包二进制数据 139<br>13.4 二进制文件 142<br>13.5 练习 144<br>14 数据结构 145<br>14.1 数组 146<br>14.2 矩阵及多维数组 146<br>14.3 链表 149<br>14.4 队列及双端队列 150<br>14.5 反向表 151<br>14.6 集合与包 152<br>14.7 字符串缓冲区 154<br>14.8 图形 156<br>14.9 练习 158<br>15 数据文件和序列化 159<br>15.1 数据文件 160<br>15.2 序列化 162<br>15.2.1 保存不带循环的表 165<br>15.2.2 保存带有循环的表 167<br>15.3 练习 169<br>16 编译、执行和错误 171<br>16.1 编译 171<br>16.2 预编译的代码 175<br>16.3 错误 177<br>16.4 错误处理和异常 179<br>16.5 错误信息和栈回溯 180<br>16.6 练习 182<br>17 模块和包 184<br>17.1 函数 require 185<br>17.1.1 模块重命名 187<br>17.1.2 搜索路径 188<br>17.1.3 搜索器 190<br>17.2 Lua 语言中编写模块的基本方法 190<br>17.3 子模块和包 193<br>17.4 练习 194<br>第 3 部分 语言特性 196<br>18 迭代器和泛型 for 197<br>18.1 迭代器和闭包 197<br>18.2 泛型 for 的语法 200<br>18.3 无状态迭代器 201<br>18.4 按顺序遍历表 203<br>18.5 迭代器的真实含义 205<br>18.6 练习 206<br>19 小插曲：马尔可夫链算法 208<br>19.1 练习 211<br>20 元表和元方法 212<br>20.1 算术运算相关的元方法 213<br>20.2 关系运算相关的元方法 216<br>20.3 库定义相关的元方法 217<br>20.4 表相关的元方法 219<br>20.4.1 __index 元方法 219<br>20.4.2 __newindex 元方法 220<br>20.4.3 具有默认值的表 221<br>20.4.4 跟踪对表的访问 222<br>20.4.5 只读的表 224<br>20.5 练习 225<br>21 面向对象（Object-Oriented）编程 226<br>21.1 类（Class） 228<br>21.2 继承（Inheritance） 230<br>21.3 多重继承（Multiple Inheritance） 232<br>21.4 私有性（Privacy） 235<br>21.5 单方法对象（Single-method Object） 237<br>21.6 对偶表示（Dual Representation） 238<br>21.7 练习 240<br>22 环境（Environment） 241<br>22.1 具有动态名称的全局变量 242<br>22.2 全局变量的声明 243<br>22.3 非全局环境 246<br>22.4 使用 _ENV 248<br>22.5 环境和模块 251<br>22.6 _ENV 和 load 252<br>22.7 练习 254<br>23 垃圾收集 255<br>23.1 弱引用表 255<br>23.2 记忆函数（Memorize Function） 257<br>23.3 对象属性（Object Attribute） 259<br>23.4 回顾具有默认值的表 260<br>23.5 瞬表（Ephemeron Table） 261<br>23.6 析构器（Finalizer） 262<br>23.7 垃圾收集器 266<br>23.8 控制垃圾收集的步长（Pace） 267<br>23.9 练习 268<br>24 协程（Coroutine） 270<br>24.1 协程基础 270<br>24.2 哪个协程占据主循环 273<br>24.3 将协程用作迭代器 276<br>24.4 事件驱动式编程 279<br>24.5 练习 284<br>25 反射（Reflection） 285<br>25.1 自省机制（Introspective Facility） 286<br>25.1.1 访问局部变量 288<br>25.1.2 访问非局部变量 289<br>25.1.3 访问其他协程 291<br>25.2 钩子（Hook） 292<br>25.3 调优（Profile） 293<br>25.4 沙盒（Sandbox） 296<br>25.5 练习 300<br>26 小插曲：使用协程实现多线程 301<br>26.1 练习 306<br>第 4 部分 C 语言 API 307<br>27 C 语言 API 总览 308<br>27.1 第一个示例 309<br>27.2 栈 312<br>27.2.1 压入元素 313<br>27.2.2 查询元素 314<br>27.2.3 其他栈操作 317<br>27.3 使用 C API 进行错误处理 320<br>27.3.1 处理应用代码中的错误 320<br>27.3.2 处理库代码中的错误 321<br>27.4 内存分配 322<br>27.5 练习 324<br>28 扩展应用 325<br>28.1 基础知识 325<br>28.2 操作表 327<br>28.2.1 一些简便方法 331<br>28.3 调用 Lua 函数 333<br>28.4 一个通用的调用函数 334<br>28.5 练习 338<br>29 在 Lua 中调用 C 语言 339<br>29.1 C 函数 339<br>29.2 延续（Continuation） 342<br>29.3 C 模块 345<br>29.4 练习 347<br>30 编写 C 函数的技巧 349<br>30.1 数组操作 349<br>30.2 字符串操作 351<br>30.3 在 C 函数中保存状态 355<br>30.3.1 注册表 355<br>30.3.2 上值 358<br>30.3.3 共享的上值（Shared upvalue） 361<br>30.4 练习 362<br>31 C 语言中的用户自定义类型 363<br>31.1 用户数据（Userdata） 364<br>31.2 元表（Metatable） 367<br>31.3 面向对象访问 370<br>31.4 数组访问 372<br>31.5 轻量级用户数据 373<br>31.6 练习 375<br>32 管理资源 376<br>32.1 目录迭代器 376<br>32.2 XML 解析器 380<br>32.3 练习 390<br>33 线程和状态 392<br>33.1 多线程 392<br>33.2 Lua 状态 397<br>33.3 练习 406</p><h3 id="Lua程序设计-PDF-下载地址"><a href="#Lua程序设计-PDF-下载地址" class="headerlink" title="Lua程序设计 PDF 下载地址:"></a>Lua程序设计 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1uZCy84RbQIQ6NpLMc__MtQ?pwd=0g09">https://pan.baidu.com/s/1uZCy84RbQIQ6NpLMc__MtQ?pwd=0g09</a> </p><p>提取码：0g09</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Lua语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kafka权威指南》</title>
      <link href="/2023/05/24/Kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/24/Kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1cf24ea01ffd8c6e8d27b099935eedd4.png" alt="《Kafka权威指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>每个应用程序都会产生数据，包括日志消息、度量指标、用户活动记录、响应消息等。如何移动数据，几乎变得与数据本身一样重要。如果你是架构师、开发者或者产品工程师，同时也是Apache Kafka新手，那么这本实践指南将会帮助你成为流式平台上处理实时数据的专家。 本书由出身于LinkedIn的Kafka核心作者和一线技术人员共同执笔，详细介绍了如何部署Kafka集群、开发可靠的基于事件驱动的微服务，以及基于Kafka平台构建可伸缩的流式应用程序。通过详尽示例，你将会了解到Kafka的设计原则、可靠性保证、关键API，以及复制协议、控制器和存储层等架构细节。 ● 了解发布和订阅消息模型以及该模型如何被应用在大数据生态系统中 ● 学习使用Kafka生产者和消费者来生成消息和读取消息 ● 了解Kafka保证可靠性数据传递的模式和场景需求 ● 使用Kafka构建数据管道和应用程序的最佳实践 ● 在生产环境中管理Kafka，包括监控、调优和维护 ● 了解Kafka的关键度量指标 ● 探索Kafka如何成为流式处理利器</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Neha Narkhede， Confluent联合创始人、CTO，曾在LinkedIn主导基于Kafka和Apache Samza构建流式基础设施，是Kafka作者之一。 Gwen Shapira， Confluent系统架构师，帮助客户构建基于Kafka的系统，在可伸缩数据架构方面拥有十余年经验；曾任Cloudera公司解决方案架构师。另著有《Hadoop应用架构》。 Todd Palino， LinkedIn主任级SRE，负责部署管理大型的Kafka、Zookeeper和Samza集群。 【译者简介】 薛命灯，毕业于厦门大学软件学院，十余年软件开发和架构经验，InfoQ高级社区编辑。译有《硅谷革命》《生产微服务》等书。微信公众号CodeDeep。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>序xiii<br>前言xv<br>第1章　初识Kafka1<br>1.1　发布与订阅消息系统1<br>1.1.1　如何开始2<br>1.1.2　独立的队列系统3<br>1.2　Kafka登场4<br>1.2.1　消息和批次4<br>1.2.2　模式4<br>1.2.3　主题和分区5<br>1.2.4　生产者和消费者5<br>1.2.5　broker和集群6<br>1.2.6　多集群7<br>1.3　为什么选择Kafka8<br>1.3.1　多个生产者8<br>1.3.2　多个消费者8<br>1.3.3　基于磁盘的数据存储9<br>1.3.4　伸缩性9<br>1.3.5　高性能9<br>1.4　数据生态系统9<br>1.5　起源故事11<br>1.5.1　LinkedIn的问题11<br>1.5.2　Kafka的诞生12<br>1.5.3　走向开源12<br>1.5.4　命名13<br>1.6　开始Kafka之旅13<br>第2章　安装Kafka14<br>2.1　要事先行14<br>2.1.1　选择操作系统14<br>2.1.2　安装Java14<br>2.1.3　安装Zookeeper15<br>2.2　安装KafkaBroker17<br>2.3　broker配置18<br>2.3.1　常规配置18<br>2.3.2　主题的默认配置19<br>2.4　硬件的选择23<br>2.4.1　磁盘吞吐量23<br>2.4.2　磁盘容量23<br>2.4.3　内存23<br>2.4.4　网络24<br>2.4.5　CPU24<br>2.5　云端的Kafka24<br>2.6　Kafka集群24<br>2.6.1　需要多少个broker25<br>2.6.2　broker配置25<br>2.6.3　操作系统调优26<br>2.7　生产环境的注意事项28<br>2.7.1　垃圾回收器选项28<br>2.7.2　数据中心布局29<br>2.7.3　共享Zookeeper29<br>2.8　总结30<br>第3章　Kafka生产者——向Kafka写入数据31<br>3.1　生产者概览32<br>3.2　创建Kafka生产者33<br>3.3　发送消息到Kafka34<br>3.3.1　同步发送消息35<br>3.3.2　异步发送消息35<br>3.4　生产者的配置36<br>3.5　序列化器39<br>3.5.1　自定义序列化器39<br>3.5.2　使用Avro序列化41<br>3.5.3　在Kafka里使用Avro42<br>3.6　分区45<br>3.7　旧版的生产者API46<br>3.8　总结47<br>第4章　Kafka消费者——从Kafka读取数据48<br>4.1　KafkaConsumer概念48<br>4.1.1　消费者和消费者群组48<br>4.1.2　消费者群组和分区再均衡51<br>4.2　创建Kafka消费者52<br>4.3　订阅主题53<br>4.4　轮询53<br>4.5　消费者的配置55<br>4.6　提交和偏移量57<br>4.6.1　自动提交58<br>4.6.2　提交当前偏移量59<br>4.6.3　异步提交59<br>4.6.4　同步和异步组合提交61<br>4.6.5　提交特定的偏移量61<br>4.7　再均衡监听器62<br>4.8　从特定偏移量处开始处理记录64<br>4.9　如何退出66<br>4.10　反序列化器67<br>4.11　独立消费者——为什么以及怎样使用没有群组的消费者71<br>4.12　旧版的消费者API71<br>4.13　总结72<br>第5章　深入Kafka73<br>5.1　集群成员关系73<br>5.2　控制器74<br>5.3　复制74<br>5.4　处理请求76<br>5.4.1　生产请求78<br>5.4.2　获取请求78<br>5.4.3　其他请求80<br>5.5　物理存储81<br>5.5.1　分区分配81<br>5.5.2　文件管理82<br>5.5.3　文件格式83<br>5.5.4　索引84<br>5.5.5　清理84<br>5.5.6　清理的工作原理84<br>5.5.7　被删除的事件86<br>5.5.8　何时会清理主题86<br>5.9　总结86<br>第6章　可靠的数据传递87<br>6.1　可靠性保证87<br>6.2　复制88<br>6.3　broker配置89<br>6.3.1　复制系数89<br>6.3.2　不完全的首领选举90<br>6.3.3　最少同步副本91<br>6.4　在可靠的系统里使用生产者92<br>6.4.1　发送确认92<br>6.4.2　配置生产者的重试参数93<br>6.4.3　额外的错误处理94<br>6.5　在可靠的系统里使用消费者94<br>6.5.1　消费者的可靠性配置95<br>6.5.2　显式提交偏移量95<br>6.6　验证系统可靠性97<br>6.6.1　配置验证98<br>6.6.2　应用程序验证98<br>6.6.3　在生产环境监控可靠性99<br>6.7　总结100<br>第7章　构建数据管道101<br>7.1　构建数据管道时需要考虑的问题102<br>7.1.1　及时性102<br>7.1.2　可靠性102<br>7.1.3　高吞吐量和动态吞吐量103<br>7.1.4　数据格式103<br>7.1.5　转换104<br>7.1.6　安全性104<br>7.1.7　故障处理能力104<br>7.1.8　耦合性和灵活性105<br>7.2　如何在ConnectAPI和客户端API之间作出选择105<br>7.3　KafkaConnect106<br>7.3.1　运行Connect106<br>7.3.2　连接器示例——文件数据源和文件数据池107<br>7.3.3　连接器示例——从MySQL到ElasticSearch109<br>7.3.4　深入理解Connect114<br>7.4　Connect之外的选择116<br>7.4.1　用于其他数据存储的摄入框架116<br>7.4.2　基于图形界面的ETL工具117<br>7.4.3　流式处理框架117<br>7.5　总结117<br>第8章　跨集群数据镜像118<br>8.1　跨集群镜像的使用场景118<br>8.2　多集群架构119<br>8.2.1　跨数据中心通信的一些现实情况119<br>8.2.2　Hub和Spoke架构120<br>8.2.3　双活架构121<br>8.2.4　主备架构123<br>8.2.5　延展集群127<br>8.3　Kafka的MirrorMaker128<br>8.3.1　如何配置129<br>8.3.2　在生产环境部署MirrorMaker130<br>8.3.3　MirrorMaker调优132<br>8.4　其他跨集群镜像方案134<br>8.4.1　优步的uReplicator134<br>8.4.2　Confluent的Replicator135<br>8.5　总结135<br>第9章　管理Kafka136<br>9.1　主题操作136<br>9.1.1　创建主题137<br>9.1.2　增加分区138<br>9.1.3　删除主题138<br>9.1.4　列出集群里的所有主题139<br>9.1.5　列出主题详细信息139<br>9.2　消费者群组140<br>9.2.1　列出并描述群组140<br>9.2.2　删除群组142<br>9.2.3　偏移量管理142<br>9.3　动态配置变更143<br>9.3.1　覆盖主题的默认配置143<br>9.3.2　覆盖客户端的默认配置145<br>9.3.3　列出被覆盖的配置145<br>9.3.4　移除被覆盖的配置146<br>9.4　分区管理146<br>9.4.1　首选的首领选举146<br>9.4.2　修改分区副本147<br>9.4.3　修改复制系数150<br>9.4.4　转储日志片段151<br>9.4.5　副本验证152<br>9.5　消费和生产153<br>9.5.1　控制台消费者153<br>9.5.2　控制台生产者155<br>9.6　客户端ACL157<br>9.7　不安全的操作157<br>9.7.1　移动集群控制器157<br>9.7.2　取消分区重分配157<br>9.7.3　移除待删除的主题158<br>9.7.4　手动删除主题158<br>9.8　总结159<br>第10章　监控Kafka160<br>10.1　度量指标基础160<br>10.1.1　度量指标在哪里160<br>10.1.2　内部或外部度量161<br>10.1.3　应用程序健康检测161<br>10.1.4　度量指标的覆盖面161<br>10.2　broker的度量指标162<br>10.2.1　非同步分区162<br>10.2.2　broker度量指标166<br>10.2.3　主题和分区的度量指标173<br>10.2.4　Java虚拟机监控174<br>10.2.5　操作系统监控175<br>10.2.6　日志176<br>10.3　客户端监控177<br>10.3.1　生产者度量指标177<br>10.3.2　消费者度量指标179<br>10.3.3　配额181<br>10.4　延时监控182<br>10.5　端到端监控183<br>10.6　总结183<br>第11章　流式处理184<br>11.1　什么是流式处理185<br>11.2　流式处理的一些概念186<br>11.2.1　时间187<br>11.2.2　状态188<br>11.2.3　流和表的二元性188<br>11.2.4　时间窗口189<br>11.3　流式处理的设计模式190<br>11.3.1　单个事件处理191<br>11.3.2　使用本地状态191<br>11.3.3　多阶段处理和重分区193<br>11.3.4　使用外部查找——流和表的连接193<br>11.3.5　流与流的连接195<br>11.3.6　乱序的事件195<br>11.3.7　重新处理196<br>11.4　Streams示例197<br>11.4.1　字数统计197<br>11.4.2　股票市场统计199<br>11.4.3　填充点击事件流201<br>11.5　KafkaStreams的架构概览202<br>11.5.1　构建拓扑202<br>11.5.2　对拓扑进行伸缩203<br>11.5.3　从故障中存活下来205<br>11.6　流式处理使用场景205<br>11.7　如何选择流式处理框架206<br>11.8　总结208<br>附录A　在其他操作系统上安装Kafka209<br>作者介绍214<br>封面介绍214</p><h3 id="Kafka权威指南-PDF-下载地址"><a href="#Kafka权威指南-PDF-下载地址" class="headerlink" title="Kafka权威指南 PDF 下载地址:"></a>Kafka权威指南 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1NbS95FK6jjwdsT3CVVpBdA?pwd=g4l1">https://pan.baidu.com/s/1NbS95FK6jjwdsT3CVVpBdA?pwd=g4l1</a> </p><p>提取码：g4l1</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《每天5分钟玩转Docker容器技术》</title>
      <link href="/2023/05/24/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%ACDocker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/05/24/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%ACDocker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/711ccdbbc82b13f2ef0dd8ef5cb677c5.png" alt="《每天5分钟玩转Docker容器技术》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>Docker和容器技术是当下热门的IT技术，无论是互联网还是传统企业都在研究和实践如何用容器构建自己的 IT 基础设施。学习本书能够让读者少走弯路，系统地学习、掌握和实践 Docker 和容器技术。 本书共分为三部分。靠前部分介绍容器技术生态环境。第二部分是容器核心知识，包括架构、镜像、容器、网络和存储。第三部分是容器进阶知识，包括多主机管理、跨主机网络方案、监控、日志管理和数据管理。读者在学习的过程中，可以跟着教程进行操作，在实践中掌握 Docker 容器技术的核心技能。在之后的工作中，可以将本教程作为参考书，按需查找相关知识点。 本书主要面向微服务软件开发人员，以及 IT 实施和运维工程师等相关人员，也适合高等院校和培训学校相关专业的师生教学参考。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>CloudMan，十多年 IT 从业经验，就职于国际知名 IT 企业，从事 IT 基础设施实施服务，项目涉及服务器、存储、网络、虚拟化、云技术等各个方面。CloudMan 对新技术长期保持浓厚的兴趣和学习热情，十几年来一直专注 IT 技术领域的钻研与实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1篇启程<br>第1章鸟瞰容器生态系统3<br>1.1容器生态系统3<br>1.2本教程覆盖的知识范围10<br>1.3准备实验环境10<br>1.3.1环境选择10<br>1.3.2安装Docker10<br>1.4运行第1个容器11<br>1.5小结12<br>第二篇容器技术<br>第2章容器核心知识概述15<br>2.1What——什么是容器15<br>2.2Why——为什么需要容器16<br>2.2.1容器解决的问题16<br>2.2.2Docker的特性20<br>2.2.3容器的优势20<br>2.3How——容器是如何工作的21<br>2.4小结24<br>第3章Docker镜像26<br>3.1镜像的内部结构26<br>3.1.1hello-world——最小的镜像26<br>3.1.2base镜像27<br>3.1.3镜像的分层结构30<br>3.2构建镜像32<br>3.2.1dockercommit32<br>3.2.2Dockerfile34<br>3.3RUNvsCMDvsENTRYPOINT42<br>3.3.1Shell和Exec格式42<br>3.3.2RUN44<br>3.3.3CMD44<br>3.3.4ENTRYPOINT45<br>3.3.5最佳实践46<br>3.4分发镜像46<br>3.4.1为镜像命名46<br>3.4.2使用公共Registry49<br>3.4.3搭建本地Registry51<br>3.5小结52<br>第4章Docker容器55<br>4.1运行容器55<br>4.1.1让容器长期运行56<br>4.1.2两种进入容器的方法57<br>4.1.3运行容器的最佳实践59<br>4.1.4容器运行小结59<br>4.2stop&#x2F;start&#x2F;restart容器60<br>4.3pause&#x2F;unpause容器61<br>4.4删除容器61<br>4.5StateMachine62<br>4.6资源限制65<br>4.6.1内存限额65<br>4.6.2CPU限额66<br>4.6.3BlockIO带宽限额68<br>4.7实现容器的底层技术69<br>4.7.1cgroup70<br>4.7.2namespace70<br>4.8小结72<br>第5章Docker网络74<br>5.1none网络74<br>5.2host网络75<br>5.3bridge网络76<br>5.4user-defined网络78<br>5.5容器间通信84<br>5.5.1IP通信84<br>5.5.2DockerDNSServer85<br>5.5.3joined容器85<br>5.6将容器与外部世界连接87<br>5.6.1容器访问外部世界87<br>5.6.2外部世界访问容器90<br>5.7小结91<br>第6章Docker存储92<br>6.1storagedriver92<br>6.2DataVolume94<br>6.2.1bindmount94<br>6.2.2dockermanagedvolume96<br>6.3数据共享99<br>6.3.1容器与host共享数据99<br>6.3.2容器之间共享数据99<br>6.4volumecontainer100<br>6.5data-packedvolumecontainer102<br>6.6DataVolume生命周期管理103<br>6.6.1备份104<br>6.6.2恢复104<br>6.6.3迁移104<br>6.6.4销毁104<br>6.7小结105<br>第三篇容器进阶知识<br>第7章多主机管理109<br>7.1实验环境描述110<br>7.2安装DockerMachine111<br>7.3创建Machine112<br>7.4管理Machine114<br>第8章容器网络117<br>8.1libnetwork&amp;CNM117<br>8.2overlay119<br>8.2.1实验环境描述120<br>8.2.2创建overlay网络121<br>8.2.3在overlay中运行容器122<br>8.2.4overlay网络连通性124<br>8.2.5overlay网络隔离126<br>8.2.6overlayIPAM127<br>8.3macvlan127<br>8.3.1准备实验环境127<br>8.3.2创建macvlan网络128<br>8.3.3macvlan网络结构分析130<br>8.3.4用sub-interface实现多macvlan网络131<br>8.3.5macvlan网络间的隔离和连通132<br>8.4flannel136<br>8.4.1实验环境描述137<br>8.4.2安装配置etcd137<br>8.4.3buildflannel138<br>8.4.4将flannel网络的配置信息保存到etcd139<br>8.4.5启动flannel139<br>8.4.6配置Docker连接flannel141<br>8.4.7将容器连接到flannel网络143<br>8.4.8flannel网络连通性144<br>8.4.9flannel网络隔离146<br>8.4.10flannel与外网连通性146<br>8.4.11host-gwbackend146<br>8.5weave148<br>8.5.1实验环境描述148<br>8.5.2安装部署weave149<br>8.5.3在host1中启动weave149<br>8.5.4在host1中启动容器150<br>8.5.5在host2中启动weave并运行容器153<br>8.5.6weave网络连通性154<br>8.5.7weave网络隔离155<br>8.5.8weave与外网的连通性156<br>8.5.9IPAM158<br>8.6calico158<br>8.6.1实验环境描述159<br>8.6.2启动etcd159<br>8.6.3部署calico160<br>8.6.4创建calico网络161<br>8.6.5在calico中运行容器161<br>8.6.6calico默认连通性164<br>8.6.7calicopolicy167<br>8.6.8calicoIPAM169<br>8.7比较各种网络方案170<br>8.7.1网络模型171<br>8.7.2DistributedStore171<br>8.7.3IPAM171<br>8.7.4连通与隔离172<br>8.7.5性能172<br>第9章容器监控173<br>9.1Docker自带的监控子命令173<br>9.1.1ps173<br>9.1.2…74<br>9.1.3stats175<br>9.2sysdig175<br>9.3WeaveScope179<br>9.3.1安装179<br>9.3.2容器监控181<br>9.3.3监控host184<br>9.3.4多主机监控186<br>9.4cAdvisor189<br>9.4.1监控DockerHost189<br>9.4.2监控容器191<br>9.5Prometheus194<br>9.5.1架构194<br>9.5.2多维数据模型195<br>9.5.3实践196<br>9.6比较不同的监控工具204<br>9.7几点建议205<br>第10章日志管理207<br>10.1Dockerlogs207<br>10.2Dockerloggingdriver209<br>10.3ELK211<br>10.3.1日志处理流程211<br>10.3.2安装ELK套件212<br>10.3.3Filebeat214<br>10.3.4管理日志216<br>10.4Fluentd220<br>10.4.1安装Fluentd221<br>10.4.2重新配置Filebeat221<br>10.4.3监控容器日志221<br>10.5Graylog222<br>10.5.1Graylog架构222<br>10.5.2部署Graylog223<br>10.5.3配置Graylog225<br>10.5.4监控容器日志227<br>10.6小结229<br>第11章数据管理230<br>11.1从一个例子开始230<br>11.2实践Rex-Raydriver232<br>11.2.1安装Rex-Ray232<br>11.2.2配置VirtualBox234<br>11.2.3创建Rex-Rayvolume236<br>11.2.4使用Rex-Rayvolume237<br>写在最后243</p><h3 id="每天5分钟玩转Docker容器技术-PDF-下载地址"><a href="#每天5分钟玩转Docker容器技术-PDF-下载地址" class="headerlink" title="每天5分钟玩转Docker容器技术 PDF 下载地址:"></a>每天5分钟玩转Docker容器技术 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1erOEpzOOWo5djAMRMIlPHA?pwd=avvw">https://pan.baidu.com/s/1erOEpzOOWo5djAMRMIlPHA?pwd=avvw</a> </p><p>提取码：avvw</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Nginx（第2版）》</title>
      <link href="/2023/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/586618a77d10293862d1149eba4e03c3.png" alt="《深入理解Nginx（第2版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书致力于说明开发Nginx模块的必备知识，第1版发行以后，深受广大读者的喜爱．然而由于Ng,nx功能繁多且性能强大，以致必须了解的基本技能也很庞杂，而第1版成书匆忙，缺失了几个进阶的技巧描述，因此第2版在此基础上进行了完善。</p><p>书中首先通过介绍官方Nginx的基本用法和配置规则，帮助读者了解一般Nginx模块的用法，然后重点介绍了女口何开发HTTP模块(含HTTP过滤模块)来得到定制化的Nginx，其中包括开发—个功能复杂的模块所需要了解的各种知识，并对内存池的实现细节及TCP协议进行了详细介绍；接着，综合Nginx框架代码分析了Nginx架构的设计理念和技巧，此外，还新增了如何在模块中支持HTTP变量，以及与slab共享内存等相关的内容，相信通过完善，可进一步帮助读者更好地开发出功能丰富、性能—流的Nginx模块。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>陶辉，毕业于西安交通大学计算机科学与技术专业，曾就职于华为中央软件部、腾讯QQ空间、思科中国CRDC等公司，目前在阿里巴巴云计算公司的飞天团队工作，研究方向为介于Iaas和Paas间的弹性计算，多年以来专注于Nginx的定制化应用，对Nginx的设计与特性有深刻认识，实战经验丰富，编写过许多优秀的Nginx模块并应用于企业级产品中，同时撰写了大量关于Nginx的技术文章。擅长Linux下高性能服务器的开发，以及分布式环境下海量数据存储的设计开发。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　Nginx能帮我们做什么<br>第1章　研究Nginx前的准备工作2<br>1.1　Nginx是什么2<br>1.2　为什么选择Nginx5<br>1.3　准备工作7<br>1.3.1　Linux操作系统7<br>1.3.2　使用Nginx的必备软件7<br>1.3.3　磁盘目录8<br>1.3.4　Linux内核参数的优化9<br>1.3.5　获取Nginx源码10<br>1.4　编译安装Nginx11<br>1.5　configure详解11<br>1.5.1　configure的命令参数11<br>1.5.2　configure执行流程18<br>1.5.3　configure生成的文件21<br>1.6　Nginx的命令行控制23<br>1.7　小结27<br>第2章　Nginx的配置28<br>2.1　运行中的Nginx进程间的关系28<br>2.2　Nginx配置的通用语法31<br>2.2.1　块配置项31<br>2.2.2　配置项的语法格式32<br>2.2.3　配置项的注释33<br>2.2.4　配置项的单位33<br>2.2.5　在配置中使用变量33<br>2.3　Nginx服务的基本配置34<br>2.3.1　用于调试进程和定位问题的配置项34<br>2.3.2　正常运行的配置项36<br>2.3.3　优化性能的配置项37<br>2.3.4　事件类配置项39<br>2.4　用HTTP核心模块配置一个静态Web服务器40<br>2.4.1　虚拟主机与请求的分发41<br>2.4.2　文件路径的定义45<br>2.4.3　内存及磁盘资源的分配47<br>2.4.4　网络连接的设置49<br>2.4.5　MIME类型的设置52<br>2.4.6　对客户端请求的限制53<br>2.4.7　文件操作的优化54<br>2.4.8　对客户端请求的特殊处理56<br>2.4.9　ngx_http_core_module模块提供的变量57<br>2.5　用HTTPproxymodule配置一个反向代理服务器59<br>2.5.1　负载均衡的基本配置61<br>2.5.2　反向代理的基本配置63<br>2.6　小结66<br>第二部分　如何编写HTTP模块<br>第3章　开发一个简单的HTTP模块68<br>3.1　如何调用HTTP模块68<br>3.2　准备工作70<br>3.2.1　整型的封装71<br>3.2.2　ngx_str_t数据结构71<br>3.2.3　ngx_list_t数据结构71<br>3.2.4　ngx_table_elt_t数据结构75<br>3.2.5　ngx_buf_t数据结构75<br>3.2.6　ngx_chain_t数据结构77<br>3.3　如何将自己的HTTP模块编译进Nginx77<br>3.3.1　config文件的写法77<br>3.3.2　利用configure脚本将定制的模块加入到Nginx中78<br>3.3.3　直接修改Makefile文件81<br>3.4　HTTP模块的数据结构82<br>3.5　定义自己的HTTP模块86<br>3.6　处理用户请求89<br>3.6.1　处理方法的返回值89<br>3.6.2　获取URI和参数92<br>3.6.3　获取HTTP头部94<br>3.6.4　获取HTTP包体97<br>3.7　发送响应99<br>3.7.1　发送HTTP头部99<br>3.7.2　将内存中的字符串作为包体发送101<br>3.7.3　经典的“HelloWorld”示例102<br>3.8　将磁盘文件作为包体发送103<br>3.8.1　如何发送磁盘中的文件104<br>3.8.2　清理文件句柄106<br>3.8.3　支持用户多线程下载和断点续传107<br>3.9　用C++语言编写HTTP模块108<br>3.9.1　编译方式的修改108<br>3.9.2　程序中的符号转换109<br>3.10　小结110<br>第4章　配置、error日志和请求上下文111<br>4.1　http配置项的使用场景111<br>4.2　怎样使用http配置113<br>4.2.1　分配用于保存配置参数的数据结构113<br>4.2.2　设定配置项的解析方式115<br>4.2.3　使用14种预设方法解析配置项121<br>4.2.4　自定义配置项处理方法131<br>4.2.5　合并配置项133<br>4.3　HTTP配置模型135<br>4.3.1　解析HTTP配置的流程136<br>4.3.2　HTTP配置模型的内存布局139<br>4.3.3　如何合并配置项142<br>4.3.4　预设配置项处理方法的工作原理144<br>4.4　error日志的用法145<br>4.5　请求的上下文149<br>4.5.1　上下文与全异步Web服务器的关系149<br>4.5.2　如何使用HTTP上下文151<br>4.5.3　HTTP框架如何维护上下文结构152<br>4.6　小结153<br>第5章　访问第三方服务154<br>5.1　upstream的使用方式155<br>5.1.1　ngx_http_upstream_t结构体158<br>5.1.2　设置upstream的限制性参数159<br>5.1.3　设置需要访问的第三方服务器地址160<br>5.1.4　设置回调方法161<br>5.1.5　如何启动upstream机制161<br>5.2　回调方法的执行场景162<br>5.2.1　create_request回调方法162<br>5.2.2　reinit_request回调方法164<br>5.2.3　finalize_request回调方法165<br>5.2.4　process_header回调方法165<br>5.2.5　rewrite_redirect回调方法167<br>5.2.6　input_filter_init与input_filter回调方法167<br>5.3　使用upstream的示例168<br>5.3.1　upstream的各种配置参数168<br>5.3.2　请求上下文170<br>5.3.3　在create_request方法中构造请求170<br>5.3.4　在process_header方法中解析包头171<br>5.3.5　在finalize_request方法中释放资源175<br>5.3.6　在ngx_http_mytest_handler方法中启动upstream175<br>5.4　subrequest的使用方式177<br>5.4.1　配置子请求的处理方式177<br>5.4.2　实现子请求处理完毕时的回调方法178<br>5.4.3　处理父请求被重新激活后的回调方法179<br>5.4.4　启动subrequest子请求179<br>5.5　subrequest执行过程中的主要场景180<br>5.5.1　如何启动subrequest180<br>5.5.2　如何转发多个子请求的响应包体182<br>5.5.3　子请求如何激活父请求185<br>5.6　subrequest使用的例子187<br>5.6.1　配置文件中子请求的设置187<br>5.6.2　请求上下文188<br>5.6.3　子请求结束时的处理方法188<br>5.6.4　父请求的回调方法189<br>5.6.5　启动subrequest190<br>5.7　小结191<br>第6章　开发一个简单的HTTP过滤模块192<br>6.1　过滤模块的意义192<br>6.2　过滤模块的调用顺序193<br>6.2.1　过滤链表是如何构成的194<br>6.2.2　过滤链表的顺序196<br>6.2.3　官方默认HTTP过滤模块的功能简介197<br>6.3　HTTP过滤模块的开发步骤198<br>6.4　HTTP过滤模块的简单例子200<br>6.4.1　如何编写config文件201<br>6.4.2　配置项和上下文201<br>6.4.3　定义HTTP过滤模块203<br>6.4.4　初始化HTTP过滤模块204<br>6.4.5　处理请求中的HTTP头部204<br>6.4.6　处理请求中的HTTP包体206<br>6.5　小结206<br>第7章　Nginx提供的高级数据结构207<br>7.1　Nginx提供的高级数据结构概述207<br>7.2　ngx_queue_t双向链表209<br>7.2.1　为什么设计ngx_queue_t双向链表209<br>7.2.2　双向链表的使用方法209<br>7.2.3　使用双向链表排序的例子212<br>7.2.4　双向链表是如何实现的213<br>7.3　ngx_array_t动态数组215<br>7.3.1　为什么设计ngx_array_t动态数组215<br>7.3.2　动态数组的使用方法215<br>7.3.3　使用动态数组的例子217<br>7.3.4　动态数组的扩容方式218<br>7.4　ngx_list_t单向链表219<br>7.5　ngx_rbtree_t红黑树219<br>7.5.1　为什么设计ngx_rbtree_t红黑树219<br>7.5.2　红黑树的特性220<br>7.5.3　红黑树的使用方法222<br>7.5.4　使用红黑树的简单例子225<br>7.5.5　如何自定义添加成员方法226<br>7.6　ngx_radix_tree_t基数树228<br>7.6.1　ngx_radix_tree_t基数树的原理228<br>7.6.2　基数树的使用方法230<br>7.6.3　使用基数树的例子231<br>7.7　支持通配符的散列表232<br>7.7.1　ngx_hash_t基本散列表232<br>7.7.2　支持通配符的散列表235<br>7.7.3　带通配符散列表的使用例子241<br>7.8　小结245<br>第三部分　深入Nginx<br>第8章　Nginx基础架构248<br>8.1　Web服务器设计中的关键约束249<br>8.2　Nginx的架构设计251<br>8.2.1　优秀的模块化设计251<br>8.2.2　事件驱动架构254<br>8.2.3　请求的多阶段异步处理256<br>8.2.4　管理进程、多工作进程设计259<br>8.2.5　平台无关的代码实现259<br>8.2.6　内存池的设计259<br>8.2.7　使用统一管道过滤器模式的HTTP过滤模块260<br>8.2.8　其他一些用户模块260<br>8.3　Nginx框架中的核心结构体ngx_cycle_t260<br>8.3.1　ngx_listening_t结构体261<br>8.3.2　ngx_cycle_t结构体262<br>8.3.3　ngx_cycle_t支持的方法264<br>8.4　Nginx启动时框架的处理流程266<br>8.5　worker进程是如何工作的269<br>8.6　master进程是如何工作的271<br>8.7　ngx_pool_t内存池276<br>8.8　小结284<br>第9章　事件模块285<br>9.1　事件处理框架概述286<br>9.2　Nginx事件的定义288<br>9.3　Nginx连接的定义291<br>9.3.1　被动连接292<br>9.3.2　主动连接295<br>9.3.3　ngx_connection_t连接池296<br>9.4　ngx_events_module核心模块297<br>9.4.1　如何管理所有事件模块的配置项299<br>9.4.2　管理事件模块300<br>9.5　ngx_event_core_module事件模块302<br>9.6　epoll事件驱动模块308<br>9.6.1　epoll的原理和用法308<br>9.6.2　如何使用epoll310<br>9.6.3　ngx_epoll_module模块的实现312<br>9.7　定时器事件320<br>9.7.1　缓存时间的管理320<br>9.7.2　缓存时间的精度323<br>9.7.3　定时器的实现323<br>9.8　事件驱动框架的处理流程324<br>9.8.1　如何建立新连接325<br>9.8.2　如何解决“惊群”问题327<br>9.8.3　如何实现负载均衡329<br>9.8.4　post事件队列330<br>9.8.5　ngx_process_events_and_timers流程331<br>9.9　文件的异步I&#x2F;O334<br>9.9.1　Linux内核提供的文件异步I&#x2F;O335<br>9.9.2　ngx_epoll_module模块中实现的针对文件的异步I&#x2F;O337<br>9.10　TCP协议与Nginx342<br>9.11　小结347<br>第10章　HTTP框架的初始化348<br>10.1　HTTP框架概述349<br>10.2　管理HTTP模块的配置项352<br>10.2.1　管理main级别下的配置项353<br>10.2.2　管理server级别下的配置项355<br>10.2.3　管理location级别下的配置项358<br>10.2.4　不同级别配置项的合并364<br>10.3　监听端口的管理367<br>10.4　server的快速检索370<br>10.5　location的快速检索370<br>10.6　HTTP请求的11个处理阶段372<br>10.6.1　HTTP处理阶段的普适规则374<br>10.6.2　NGX_HTTP_POST_READ_PHASE阶段375<br>10.6.3　NGX_HTTP_SERVER_REWRITE_PHASE阶段378<br>10.6.4　NGX_HTTP_FIND_CONFIG_PHASE阶段378<br>10.6.5　NGX_HTTP_REWRITE_PHASE阶段378<br>10.6.6　NGX_HTTP_POST_REWRITE_PHASE阶段379<br>10.6.7　NGX_HTTP_PREACCESS_PHASE阶段379<br>10.6.8　NGX_HTTP_ACCESS_PHASE阶段379<br>10.6.9　NGX_HTTP_POST_ACCESS_PHASE阶段380<br>10.6.10　NGX_HTTP_TRY_FILES_PHASE阶段380<br>10.6.11　NGX_HTTP_CONTENT_PHASE阶段380<br>10.6.12　NGX_HTTP_LOG_PHASE阶段382<br>10.7　HTTP框架的初始化流程382<br>10.8　小结384<br>第11章　HTTP框架的执行流程385<br>11.1　HTTP框架执行流程概述386<br>11.2　新连接建立时的行为387<br>11.3　第一次可读事件的处理388<br>11.4　接收HTTP请求行394<br>11.5　接收HTTP头部398<br>11.6　处理HTTP请求400<br>11.6.1　ngx_http_core_generic_phase406<br>11.6.2　ngx_http_core_rewrite_phase408<br>11.6.3　ngx_http_core_access_phase409<br>11.6.4　ngx_http_core_content_phase412<br>11.7　subrequest与post请求415<br>11.8　处理HTTP包体417<br>11.8.1　接收包体419<br>11.8.2　放弃接收包体425<br>11.9　发送HTTP响应429<br>11.9.1　ngx_http_send_header430<br>11.9.2　ngx_http_output_filter432<br>11.9.3　ngx_http_writer435<br>11.10　结束HTTP请求437<br>11.10.1　ngx_http_close_connection438<br>11.10.2　ngx_http_free_request439<br>11.10.3　ngx_http_close_request440<br>11.10.4　ngx_http_finalize_connection441<br>11.10.5　ngx_http_terminate_request443<br>11.10.6　ngx_http_finalize_request443<br>11.11　小结446<br>第12章　upstream机制的设计与实现447<br>12.1　upstream机制概述448<br>12.1.1　设计目的448<br>12.1.2　ngx_http_upstream_t数据结构的意义450<br>12.1.3　ngx_http_upstream_conf_t配置结构体453<br>12.2　启动upstream455<br>12.3　与上游服务器建立连接457<br>12.4　发送请求到上游服务器460<br>12.5　接收上游服务器的响应头部463<br>12.5.1　应用层协议的两段划分方式463<br>12.5.2　处理包体的3种方式464<br>12.5.3　接收响应头部的流程465<br>12.6　不转发响应时的处理流程469<br>12.6.1　input_filter方法的设计469<br>12.6.2　默认的input_filter方法470<br>12.6.3　接收包体的流程472<br>12.7　以下游网速优先来转发响应473<br>12.7.1　转发响应的包头474<br>12.7.2　转发响应的包体477<br>12.8　以上游网速优先来转发响应481<br>12.8.1　ngx_event_pipe_t结构体的意义481<br>12.8.2　转发响应的包头485<br>12.8.3　转发响应的包体487<br>12.8.4　ngx_event_pipe_read_upstream方法489<br>12.8.5　ngx_event_pipe_write_to_downstream方法494<br>12.9　结束upstream请求496<br>12.10　小结499<br>第13章　邮件代理模块500<br>13.1　邮件代理服务器的功能500<br>13.2　邮件模块的处理框架503<br>13.2.1　一个请求的8个独立处理阶段503<br>13.2.2　邮件类模块的定义504<br>13.2.3　邮件框架的初始化506<br>13.3　初始化请求506<br>13.3.1　描述邮件请求的ngx_mail_session_t结构体506<br>13.3.2　初始化邮件请求的流程509<br>13.4　接收并解析客户端请求509<br>13.5　邮件认证510<br>13.5.1　ngx_mail_auth_http_ctx_t结构体510<br>13.5.2　与认证服务器建立连接511<br>13.5.3　发送请求到认证服务器513<br>13.5.4　接收并解析响应514<br>13.6　与上游邮件服务器间的认证交互514<br>13.6.1　ngx_mail_proxy_ctx_t结构体516<br>13.6.2　向上游邮件服务器发起连接516<br>13.6.3　与邮件服务器认证交互的过程518<br>13.7　透传上游邮件服务器与客户端间的流520<br>13.8　小结524<br>第14章　进程间的通信机制525<br>14.1　概述525<br>14.2　共享内存526<br>14.3　原子操作530<br>14.3.1　不支持原子库下的原子操作530<br>14.3.2　x86架构下的原子操作531<br>14.3.3　自旋锁533<br>14.4　Nginx频道535<br>14.5　信号538<br>14.6　信号量540<br>14.7　文件锁541<br>14.8　互斥锁544<br>14.8.1　文件锁实现的ngx_shmtx_t锁546<br>14.8.2　原子变量实现的ngx_shmtx_t锁548<br>14.9　小结553<br>第15章　变量554<br>15.1　使用内部变量开发模块555<br>15.1.1　定义模块556<br>15.1.2　定义http模块加载方式557<br>15.1.3　解析配置中的变量558<br>15.1.4　处理请求560<br>15.2　内部变量工作原理561<br>15.2.1　何时定义变量561<br>15.2.2　相关数据结构详述564<br>15.2.3　定义变量的方法572<br>15.2.4　使用变量的方法572<br>15.2.5　如何解析变量573<br>15.3　定义内部变量576<br>15.4　外部变量与脚本引擎577<br>15.4.1　相关数据结构578<br>15.4.2　编译“set”脚本581<br>15.4.3　脚本执行流程586<br>15.5　小结589<br>第16章　slab共享内存590<br>16.1　操作slab共享内存的方法590<br>16.2　使用slab共享内存池的例子592<br>16.2.1　共享内存中的数据结构593<br>16.2.2　操作共享内存中的红黑树与链表595<br>16.2.3　解析配置文件600<br>16.2.4　定义模块603<br>16.3　slab内存管理的实现原理605<br>16.3.1　内存结构布局607<br>16.3.2　分配内存流程613<br>16.3.3　释放内存流程617<br>16.3.4　如何使用位操作619<br>16.3.5　slab内存池间的管理624<br>16.4　小结624</p><h3 id="深入理解Nginx（第2版）-PDF-下载地址"><a href="#深入理解Nginx（第2版）-PDF-下载地址" class="headerlink" title="深入理解Nginx（第2版） PDF 下载地址:"></a>深入理解Nginx（第2版） PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/159c8gslfQfbKwUM0wFB53A?pwd=v3ae">https://pan.baidu.com/s/159c8gslfQfbKwUM0wFB53A?pwd=v3ae</a> </p><p>提取码：v3ae</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Docker容器与容器云（第2版）》</title>
      <link href="/2023/05/24/Docker%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%91%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/24/Docker%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%91%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/39k8ibvr7xj60m8z1o8qxwl8gfprwc3f.png" alt="《Docker容器与容器云（第2版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书根据Docker 1.10版和Kubernetes 1.2版对第1版进行了全面更新，从实践者的角度出发，以Docker和Kubernetes为重点，沿着“基本用法介绍”到“核心原理解读”到“高级实践技巧”的思路，一本书讲透当前主流的容器和容器云技术，有助于读者在实际场景中利用Docker容器和容器云解决问题并启发新的思考。全书包括两部分，第一部分深入解读Docker容器技术，包括Docker架构与设计、核心源码解读和高级实践技巧；第二部分归纳和比较了三类基于Docker的主流容器云项目，包括专注Docker容器编排与部署的容器云、专注应用支撑的容器云以及一切皆容器的Kubernetes，进而详细解读了Kubernetes核心源码的设计与实现，最后介绍了几种典型场景下的Kubernetes最佳实践。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>浙江大学软件工程实验室（Software Engineering Lab，SEL）</p><p>云计算团队组建于2011年，组织博士和硕士研究生搭建、分析和钻研开源的云计算技术，包括Docker、Kubernetes、Cloud Foundry、OpenStack、CloudStack、Eucalyptus、Convirt、OpenShift等，积极为开源社区贡献代码，管理和参与线上线下讨论社区，参加国内外云计算技术峰会并发言。以开源社区为技术交流研发平台，浙江大学SEL实验室在几年的时间里成长为一个充满热情、富有能力的云计算研发团队，也在国内外开源云计算社区，尤其是在Docker、Kubernetes和Cloud Foundry社区得到了广泛认可。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　Docker深入解读<br>第1章　从容器到容器云　　2<br>1.1　云计算平台　　2<br>1.2　容器，新的革命　　3<br>1.3　进化：从容器到容器云　　7<br>第2章　Docker 基础　　8<br>2.1　Docker的安装　　8<br>2.2　Docker操作参数解读　　9<br>2.3　搭建你的第一个Docker应用栈　　16<br>2.3.1　Docker集群部署　　16<br>2.3.2　第一个Hello World　　17<br>2.3.3　开发、测试和发布一体化　　27<br>第3章　Docker核心原理解读　　28<br>3.1　Docker背后的内核知识　　28<br>3.1.1　namespace资源隔离　　28<br>3.1.2　cgroups资源限制　　45<br>3.2　Docker架构概览　　53<br>3.2.1　Docker daemon　　54<br>3.2.2　Docker client　　54<br>3.2.3　镜像管理　　54<br>3.2.4　execdriver、volumedriver、graphdriver　　55<br>3.2.5　network　　55<br>3.3　client和daemon　　56<br>3.3.1　client模式　　56<br>3.3.2　daemon模式　　58<br>3.3.3　从client到daemon　　64<br>3.4　libcontainer　　67<br>3.4.1　libcontainer的工作方式　　69<br>3.4.2　libcontainer实现原理　　70<br>3.4.3　使用runC与libcontainer进行交互　　75<br>3.5　Docker镜像管理　　77<br>3.5.1　什么是Docker镜像　　77<br>3.5.2　Docker镜像关键概念　　80<br>3.5.3　Docker镜像构建操作　　81<br>3.5.4　Docker镜像的分发方法　　84<br>3.6　Docker存储管理　　87<br>3.6.1　Docker镜像元数据管理　　87<br>3.6.2　Docker存储驱动　　89<br>3.7　Docker数据卷　　99<br>3.7.1　数据卷的使用方式　　100<br>3.7.2　数据卷原理解读　　105<br>3.8　Docker网络管理　　108<br>3.8.1　Docker网络基础　　108<br>3.8.2　Docker daemon网络配置原理　　116<br>3.8.3　libcontainer网络配置原理　　119<br>3.8.4　传统的link原理解析　　125<br>3.8.5　新的link介绍　　127<br>3.9　Docker与容器安全　　129<br>3.9.1　Docker的安全机制　　129<br>3.9.2　Docker安全问题　　135<br>3.9.3　Docker安全的解决方案　　139<br>第4章　Docker 高级实践技巧　　151<br>4.1　容器化思维　　151<br>4.1.1　SSH服务器的替代方案　　151<br>4.1.2　Docker内应用日志管理方案　　152<br>4.1.3　容器化思维及更多　　153<br>4.2　Docker高级网络实践　　153<br>4.2.1　玩转Linux networknamespace　　154<br>4.2.2　pipework原理解析　　159<br>4.2.3　pipework跨主机通信　　165<br>4.2.4　OVS划分VLAN　　170<br>4.2.5　OVS隧道模式　　174<br>4.3　Dockerfile最佳实践　　187<br>4.3.1　Dockerfile的使用　　187<br>4.3.2　Dockerfile实践心得　　191<br>4.4　Docker容器的监控手段　　193<br>4.4.1　Docker容器监控维度　　194<br>4.4.2　容器监控命令　　195<br>4.4.3　常用的容器监控工具　　197<br>4.5　容器化应用构建的基础：高可用配置中心　　201<br>4.5.1　etcd经典应用场景　　201<br>4.5.2　etcd实现原理　　206<br>第二部分　Docker云平台解读<br>第5章　构建自己的容器云　　222<br>5.1　再谈云平台的层次架构　　222<br>5.2　从小工到专家　　225<br>第6章　专注编排与部署：三剑客与Fleet　　230<br>6.1　编排小神器Fig&#x2F;Compose　　230<br>6.1.1　再谈容器编排与部署　　230<br>6.1.2　Compose原理：一探究竟　　233<br>6.2　跨平台宿主环境管理工具Machine　　237<br>6.2.1　Machine与虚拟机软件　　237<br>6.2.2　Machine与IaaS平台　　238<br>6.2.3　Machine小结　　239<br>6.3　集群抽象工具Swarm　　240<br>6.3.1　Swarm简介　　240<br>6.3.2　试用Swarm　　241<br>6.3.3　Swarm集群的多种创建方式　　243<br>6.3.4　Swarm对请求的处理　　245<br>6.3.5　Swarm集群的调度策略　　245<br>6.3.6　Swarm集群高可用（HA）　　246<br>6.3.7　Swarm与Machine　　247<br>6.3.8　Swarm小结　　248<br>6.4　编排之秀Fleet　　248<br>6.4.1　旧问题新角度：Docker distro　　249<br>6.4.2　Fleet的原理剖析　　252<br>第7章　专注应用支撑和运行时：Flynn和Deis　　258<br>7.1　Flynn，一个小而美的两层架构　　258<br>7.1.1　第0层：容器云的基础设施　　259<br>7.1.2　第1层：容器云的功能框架　　259<br>7.1.3　Flynn体系架构与实现原理　　260<br>7.2　谈谈Deis与Flynn　　270<br>7.2.1　应用发布上的比较　　271<br>7.2.2　关于Deis的一些思考　　273<br>第8章　一切皆容器：Kubernetes　　274<br>8.1　Kubernetes是个什么样的项目　　274<br>8.2　Kubernetes的设计解读　　275<br>8.2.1　一个典型案例：Guestbook　　275<br>8.2.2　pod设计解读　　277<br>8.2.3　replication controller设计解读　　288<br>8.2.4　service的设计解读　　294<br>8.2.5　新一代副本控制器replica set　　306<br>8.2.6　Deployment　　307<br>8.2.7　DaemonSet　　312<br>8.2.8　ConfigMap　　312<br>8.2.9　Job　　317<br>8.2.10　Horizontal Pod Autoscaler　　318<br>8.3　Kubernetes核心组件解读　　320<br>8.3.1　Kubernetes的整体架构　　320<br>8.3.2　APIServer　　321<br>8.3.3　scheduler　　328<br>8.3.4　controller manager　　338<br>8.3.5　kubelet　　346<br>8.3.6　kube-proxy　　352<br>8.3.7　核心组件协作流程　　362<br>8.4　Kubernetes存储核心原理　　366<br>8.4.1　volume设计解读　　366<br>8.4.2　volume实现原理分析　　367<br>8.4.3　volume使用案例　　368<br>8.4.4　persistent volume　　371<br>8.5　Kubernetes网络核心原理　　372<br>8.5.1　单pod单IP模型　　373<br>8.5.2　pod和网络容器　　374<br>8.5.3　实现Kubernetes的网络模型　　377<br>8.6　Kubernetes多租户管理与资源控制　　381<br>8.6.1　namespace设计解读　　381<br>8.6.2　Kubernetes用户认证机制　　385<br>8.6.3　Kubernetes用户授权机制　　387<br>8.6.4　Kubernetes多维资源管理机制admission control　　390<br>8.7　Kubernetes高级实践　　402<br>8.7.1　应用健康检查　　402<br>8.7.2　高可用性　　405<br>8.7.3　日志　　408<br>8.7.4　集成DNS　　410<br>8.7.5　容器上下文环境　　412<br>8.8　Kubernetes未来动向　　414<br>8.8.1　Ubernetes　　414<br>8.8.2　petSet　　415<br>8.8.3　performance　　417<br>8.8.4　rescheduler　　417<br>8.8.5　OCI标准　　419<br>8.9　不要停止思考　　419<br>第三部分　附录<br>附录A　Docker的安装　　424<br>附录B　阅读Docker源代码的神兵利器　　432<br>附录C　快速熟悉开源项目　　441<br>附录D　cgroups的测试与使用　　444<br>附录E　cgroups子系统配置参数介绍　　448<br>附录F　Kubernetes的安装　　453<br>后记　　457</p><h3 id="Docker容器与容器云（第2版）-PDF-下载地址"><a href="#Docker容器与容器云（第2版）-PDF-下载地址" class="headerlink" title="Docker容器与容器云（第2版） PDF 下载地址:"></a>Docker容器与容器云（第2版） PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1lm06EAwpZeyUPXR2ksFFAA?pwd=hg7b">https://pan.baidu.com/s/1lm06EAwpZeyUPXR2ksFFAA?pwd=hg7b</a> </p><p>提取码：hg7b</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go专家编程》</title>
      <link href="/2023/05/24/Go%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/24/Go%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cq7yazwp20b5ozt21mt39tu5a0y0olui.jpg" alt="《Go专家编程》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松地了解Go语言的内部运作机制。</p><p>本书首先介绍Go语言常见的数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者可以借此测验自身对该知识点的掌握程度。接着介绍了Go语言最基础的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了一些标准库、异常处理和依赖管理等非语法相关但非常重要的内容。最后结合作者的见闻，整理了一些发生在真实项目中的编程陷阱。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>任洪彩，华为云原生团队核心成员，开源爱好者，深度参与CNCF（云原生计算基金会）旗下Kubernetes、Prometheus等项目贡献，Kubernetes资深成员，担任Kubernetes SIG-Instrumentation Approver，敏捷软件思想深度实践者，在Nokia、华为等公司参与过多个大型项目的研发与重构，对Go、C&#x2F;C++、Python、Swift等语言均有深入的研究与实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　常见数据结构的实现原理<br>1.1　管道<br>1.1.1　热身测验<br>1.1.2　特性速览<br>1.1.3　实现原理<br>1.2　slice<br>1.2.1　热身测验<br>1.2.2　特性速览<br>1.2.3　实现原理<br>1.2.4　切片表达式<br>1.3　map<br>1.3.1　热身测验<br>1.3.2　特性速览<br>1.3.3　实现原理<br>1.4　struct<br>1.4.1　热身测验<br>1.4.2　内嵌字段<br>1.4.3　方法受体<br>1.4.4　字段标签<br>1.5　iota<br>1.5.1　热身测验<br>1.5.2　特性速览<br>1.5.3　实现原理<br>1.6　string<br>1.6.1　热身测验<br>1.6.2　特性速览<br>1.6.3　实现原理<br>第2章　控制结构<br>2.1　select<br>2.1.1　热身测验<br>2.1.2　特性速览<br>2.1.3　实现原理<br>2.2　for-range<br>2.2.1　热身测验<br>2.2.2　特性速览<br>2.2.3　实现原理<br>第3章　协程<br>3.1　协程的概念<br>3.2　调度模型<br>3.3　调度策略<br>第4章　内存管理<br>4.1　内存分配<br>4.2　垃圾回收<br>4.3　逃逸分析<br>第5章　并发控制<br>5.1　channel<br>5.2　WaitGroup<br>5.3　context<br>5.4　Mutex<br>5.5　RWMutex<br>5.5.1　读写锁的数据结构<br>5.5.2　场景分析<br>第6章　反射<br>6.1　热身测验<br>6.2　接口<br>6.3　反射定律<br>第7章　测试<br>7.1　快速开始<br>7.1.1　单元测试<br>7.1.2　基准测试<br>7.1.3　示例测试<br>7.2　进阶测试<br>7.2.1　子测试<br>7.2.2　Main测试<br>7.3　实现原理<br>7.3.1　testing.common<br>7.3.2　testing.TB接口<br>7.3.3　单元测试的实现原理<br>7.3.4　性能测试的实现原理<br>7.3.5　示例测试的实现原理<br>7.3.6　Main测试的实现原理<br>7.3.7　gotest的工作机制<br>7.4　扩展阅读<br>7.4.1　测试参数<br>7.4.2　benchstat<br>第8章　异常处理<br>8.1　error<br>8.1.1　热身测验<br>8.1.2　基础error<br>8.1.3　链式error<br>8.1.4　工程迁移<br>8.2　defer<br>8.2.1　热身测验<br>8.2.2　约法三章<br>8.2.3　实现原理<br>8.2.4　性能优化<br>8.3　panic<br>8.3.1　热身测验<br>8.3.2　工作机制<br>8.3.3　源码剖析<br>8.4　recover<br>8.4.1　热身测验<br>8.4.2　工作机制<br>8.4.3　源码剖析<br>第9章　定时器<br>9.1　一次性定时器（Timer）<br>9.1.1　快速开始<br>9.1.2　实现原理<br>9.2　周期性定时器（Ticker）<br>9.2.1　快速开始<br>9.2.2　实现原理<br>9.3　runtimeTimer<br>9.3.1　实现原理<br>9.3.2　性能优化<br>9.4　案例分享<br>第10章　语法糖<br>10.1　简短变量声明符<br>10.1.1　热身测验<br>10.1.2　规则<br>10.2　可变参函数<br>第11章　版本管理<br>11.1　安装Go<br>11.2　删除Go<br>11.3　升级Go<br>11.4　Go版本管理器<br>11.4.1　快速开始<br>11.4.2　工作机制<br>11.4.3　小结<br>11.5　源码编译<br>11.5.1　源码下载<br>11.5.2　源码编译过程<br>第12章　Go语言依赖管理<br>12.1　GOPATH<br>12.1.1　GOROOT是什么<br>12.1.2　GOPATH是什么<br>12.1.3　依赖查找<br>12.1.4　GOPATH的缺点<br>12.2　vendor<br>12.2.1　vendor目录位置<br>12.2.2　搜索顺序<br>12.2.3　vendor的不足<br>12.3　GoModule<br>12.3.1　GoModule基础<br>12.3.2　快速实践<br>12.3.3　replace指令<br>12.3.4　exclude指令<br>12.3.5　indirect指令<br>12.3.6　版本选择机制<br>12.3.7　incompatible<br>12.3.8　伪版本<br>12.3.9　依赖包存储<br>12.3.10　go.sum<br>12.3.11　模块代理<br>12.3.12　GOSUMDB的工作机制<br>12.3.13　GOSUMDB的实现原理<br>12.3.14　第三方代理<br>12.3.15　私有模块<br>12.3.16　GoModule的演进<br>第13章　编程陷阱<br>13.1　切片扩容<br>13.2　空切片<br>13.3　append的本质<br>13.4　循环变量引用<br>13.5　协程引用循环变量<br>13.6　recover失效</p><h3 id="Go专家编程-PDF-下载地址"><a href="#Go专家编程-PDF-下载地址" class="headerlink" title="Go专家编程 PDF 下载地址:"></a>Go专家编程 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1sdur-j2y9Exf3V3TAGZ_Rw?pwd=mp19">https://pan.baidu.com/s/1sdur-j2y9Exf3V3TAGZ_Rw?pwd=mp19</a> </p><p>提取码：mp19</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Go语言编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言高级编程》</title>
      <link href="/2023/05/24/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/24/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/o6fkcz9f5pj28fedxj7l7biszkbb6cvf.png" alt="《Go语言高级编程》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书从实践出发讲解Go语言编程的进阶知识。本书共6章，第1章简单回顾Go语言的发展历史；第2章和第3章系统介绍CGO编程和Go汇编语言的用法；第4章对RPC和Protobuf技术进行深入介绍，并讲述如何打造一个自己的RPC系统；第5章介绍工业级环境的Web系统的设计和相关技术；第6章介绍Go语言在分布式领域的一些编程技术。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>柴树杉</p><p>国内第一批的Go语言爱好者，Go语言代码贡献者，CGO资深用户。同时对WebAssembly技术有一定研究，著有《WebAssembly标准入门》。Github账号为chai2010。</p><p>曹春晖</p><p>在Web领域工作多年，开源爱好者。对大型网站系统的架构和相关工具的实现很感兴趣，并且有一些研究成果。目前在滴滴平台技术部工作。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 语言基础<br>1.1 Go语言创世纪<br>1.2 Hello, World 的革命<br>1.3 数组、字符串和切片<br>1.4 函数、方法和接口<br>1.5 面向并发的内存模型<br>1.6 常见的并发模式<br>1.7 错误和异常<br>1.8 补充说明<br>第2章 CGO编程<br>2.1 快速入门<br>2.2 CGO基础<br>2.3 类型转换<br>2.4 函数调用<br>2.5 内部机制<br>2.6 实战: 封装qsort<br>2.7 CGO内存模型<br>2.8 C++类包装<br>2.9 静态库和动态库<br>2.10 编译和链接参数<br>2.11 补充说明<br>第3章 汇编语言<br>3.1 快速入门<br>3.2 计算机结构<br>3.3 常量和全局变量<br>3.4 函数<br>3.5 控制流<br>3.6 再论函数<br>3.7 汇编语言的威力<br>3.8 例子：Goroutine ID<br>3.9 Delve调试器<br>3.10 补充说明<br>第4章 RPC和Protobuf<br>4.1 RPC入门<br>4.2 Protobuf<br>4.3 玩转RPC<br>4.4 gRPC入门<br>4.5 gRPC进阶<br>4.6 gRPC和Protobuf扩展<br>4.7 pbgo: 基于Protobuf的框架<br>4.8 grpcurl工具<br>4.9 补充说明<br>第5章 Go和Web<br>5.1 Web开发简介<br>5.2 请求路由<br>5.3 中间件<br>5.4 请求校验<br>5.5 和数据库打交道<br>5.6 服务流量限制<br>5.7 大型Web项目分层<br>5.8 接口和表驱动开发<br>5.9 灰度发布和A&#x2F;B测试<br>5.10 补充说明<br>第6章 分布式系统<br>6.1 分布式 id 生成器<br>6.2 分布式锁<br>6.3 延时任务系统<br>6.4 分布式搜索引擎<br>6.5 负载均衡<br>6.6 分布式配置管理<br>6.7 分布式爬虫<br>6.8 补充说明<br>附录<br>附录A: Go语言常见坑<br>附录B: 有趣的代码片段</p><h3 id="Go语言高级编程-PDF-下载地址"><a href="#Go语言高级编程-PDF-下载地址" class="headerlink" title="Go语言高级编程 PDF 下载地址:"></a>Go语言高级编程 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Chsb8grxKKCd8CJNHG9lXg?pwd=1lli">https://pan.baidu.com/s/1Chsb8grxKKCd8CJNHG9lXg?pwd=1lli</a> </p><p>提取码：1lli</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Go语言编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kubernetes权威指南：从Docker到Kubernetes实践全接触》</title>
      <link href="/2023/05/24/Kubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6/"/>
      <url>/2023/05/24/Kubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/lorogawptmcytwkuacpqwzjp.png" alt="《Kubernetes权威指南：从Docker到Kubernetes实践全接触》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>Kubernetes是由谷歌开源的容器集群管理系统，为容器化应用提供了资源调度、部署运行、服务发现、扩缩容等一整套功能。Kubernetes也是将“一切以服务（Service）为中心，一切围绕服务运转”作为指导思想的创新型产品，它的功能和架构设计自始至终地遵循了这一指导思想。构建在Kubernetes上的系统不仅可以独立运行在物理机、虚拟机集群或者企业私有云上，也可以被托管在公有云上。</p><p>《Kubernetes权威指南：从Docker到Kubernetes实践全接触（第5版）》总计12章，分别讲解Kubernetes的基本概念、实践指南、核心原理、开发指南、网络与存储、运维指南、新特性演进等内容。全书图文并茂、内容丰富、由浅入深、讲解全面，并围绕在生产环境中可能出现的问题，给出了大量典型案例，比如安全配置方案、网络方案、共享存储方案、高可用方案及Trouble Shooting技巧等，有很强的实战指导意义。本书的内容也随着Kubernetes的版本更新不断完善，目前涵盖了Kubernetes从1.0到1.19版本的主要特性，努力为Kubernetes用户提供全方位的Kubernetes技术指南。</p><p>无论是对于软件工程师、软件架构师、测试工程师、运维工程师、技术经理，还是对于资深IT人士，本书都极具参考价值。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>·龚正·</p><p>HPE高级顾问，从事IT工作20余年，在云计算、大数据、大型企业级应用等领域有丰富的咨询规划、架构设计和实施经验，负责过多个大型云平台的规划和建设，是电信、金融、互联网等领域的资深专家，也是《Kubernetes权威指南：企业级容器云实战》等书的作者。</p><p>·吴治辉·</p><p>HPE资深架构师，从事软件研发工作20余年，专注于电信软件和云计算方面的软件研发，有丰富的大型项目架构设计经验，是业界少有的具备很强编程能力的资深架构师，也是《ZeroCIce权威指南》《架构解密：从分布式到微服务》《Kubernetes权威指南：企业级容器云实战》《区块链轻松上手》等书的作者。</p><p>·闫健勇·</p><p>HPE高级项目经理、总架构师，从事电信行业系统建设工作20余年，主导了多项电信大型系统的架构设计和管理，对云计算和大数据在电信行业中的应用有丰富的经验，也是《Kubernetes权威指南：企业级容器云实战》等书的作者。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 Kubernetes入门 1<br>1.1 了解Kubernetes 2<br>1.2 为什么要用Kubernetes 5<br>1.3 从一个简单的例子开始 7<br>1.3.1 环境准备 8<br>1.3.2 启动MySQL服务 8<br>1.3.3 启动Tomcat应用 11<br>1.3.4 通过浏览器访问网页 12<br>1.4 Kubernetes的基本概念和术语 14<br>1.4.1 资源对象概述 14<br>1.4.2 集群类 15<br>1.4.3 应用类 19<br>1.4.4 存储类 40<br>1.4.5 安全类 44<br>第2章 Kubernetes安装配置指南 47<br>2.1 系统要求 48<br>2.2 使用kubeadm工具快速安装Kubernetes集群 49<br>2.2.1 安装kubeadm 50<br>2.2.2 修改kubeadm的默认配置 50<br>2.2.3 下载Kubernetes的相关镜像 51<br>2.2.4 运行kubeadm init命令安装Master节点 52<br>2.2.5 将新的Node加入集群 57<br>2.2.6 安装CNI网络插件 59<br>2.2.7 验证Kubernetes集群是否工作正常 60<br>2.3 以二进制文件方式安装Kubernetes安全高可用集群 61<br>2.3.1 Master高可用部署架构 61<br>2.3.2 创建CA根证书 62<br>2.3.3 部署安全的etcd高可用集群 63<br>2.3.4 部署安全的Kubernetes Master高可用集群 68<br>2.3.5 部署Node的服务 85<br>2.3.6 kube-apiserver基于token的认证机制 89<br>2.4 使用私有镜像库的相关配置 90<br>2.5 Kubernetes的版本升级 91<br>2.5.1 二进制文件升级 91<br>2.5.2 使用kubeadm进行集群升级 92<br>2.6 CRI（容器运行时接口）详解 94<br>2.6.1 CRI概述 94<br>2.6.2 CRI的主要组件 94<br>2.6.3 Pod和容器的生命周期管理 95<br>2.6.4 面向容器级别的设计思路 96<br>2.6.5 尝试使用新的Docker-CRI来创建容器 97<br>2.6.6 CRI的进展 98<br>2.7 kubectl命令行工具用法详解 98<br>2.7.1 kubectl用法概述 99<br>2.7.2 kubectl子命令详解 99<br>2.7.3 kubectl可操作的资源对象详解 103<br>2.7.4 kubectl的公共参数说明 105<br>2.7.5 kubectl格式化输出 106<br>2.7.6 kubectl常用操作示例 108<br>第3章 深入掌握Pod 113<br>3.1 Pod定义详解 114<br>3.2 Pod的基本用法 120<br>3.3 静态Pod 125<br>3.4 Pod容器共享Volume 126<br>3.5 Pod的配置管理 129<br>3.5.1 ConfigMap概述 129<br>3.5.2 创建ConfigMap资源对象 129<br>3.5.3 在Pod中使用ConfigMap 137<br>3.5.4 使用ConfigMap的限制条件 143<br>3.6 在容器内获取Pod信息（Downward API） 144<br>3.6.1 环境变量方式 144<br>3.6.2 Volume挂载方式 148<br>3.6.3 Downward API支持设置的Pod和Container信息 153<br>3.7 Pod生命周期和重启策略 154<br>3.8 Pod健康检查和服务可用性检查 155<br>3.9 玩转Pod调度 159<br>3.9.1 Deployment或RC：全自动调度 162<br>3.9.2 NodeSelector：定向调度 163<br>3.9.3 NodeAffinity：Node亲和性调度 165<br>3.9.4 PodAffinity：Pod亲和与互斥调度策略 167<br>3.9.5 Taints和Tolerations（污点和容忍） 171<br>3.9.6 Pod Priority Preemption：Pod优先级调度 176<br>3.9.7 DaemonSet：在每个Node上都调度一个Pod 178<br>3.9.8 Job：批处理调度 181<br>3.9.9 Cronjob：定时任务 185<br>3.9.10 自定义调度器 188<br>3.9.11 Pod容灾调度 190<br>3.10 Init Container（初始化容器） 192<br>3.11 Pod的升级和回滚 196<br>3.11.1 Deployment的升级 196<br>3.11.2 Deployment的回滚 203<br>3.11.3 暂停和恢复Deployment的部署操作 205<br>3.11.4 其他管理对象的更新策略 207<br>3.12 Pod的扩缩容 209<br>3.12.1 手动扩缩容机制 209<br>3.12.2 自动扩缩容机制 211<br>3.13 使用StatefulSet搭建MongoDB集群 233<br>3.13.1 前提条件 234<br>3.13.2 部署StatefulSet 234<br>3.13.3 查看MongoDB集群的状态 238<br>3.13.4 StatefulSet的常见应用场景 241<br>第4章 深入掌握Service 245<br>4.1 Service定义详解 246<br>4.2 Service的概念和原理 248<br>4.2.1 Service的概念 248<br>4.2.2 Service的负载均衡机制 252<br>4.2.3 Service的多端口设置 254<br>4.2.4 将外部服务定义为Service 256<br>4.2.5 将Service暴露到集群外部 257<br>4.2.6 Service支持的网络协议 260<br>4.2.7 Kubernetes的服务发现机制 261<br>4.2.8 Headless Service的概念和应用 263<br>4.2.9 端点分片与服务拓扑 265<br>4.3 DNS服务搭建和配置指南 274<br>4.3.1 修改每个Node上kubelet的DNS启动参数 276<br>4.3.2 部署CoreDNS服务 276<br>4.3.3 服务名的DNS解析 280<br>4.3.4 CoreDNS的配置说明 282<br>4.4 Node本地DNS缓存 284<br>4.5 Pod的DNS域名相关特性 291<br>4.5.1 Pod的DNS域名 291<br>4.5.2 为Pod自定义hostname和subdomain 292<br>4.5.3 Pod的DNS策略 294<br>4.5.4 Pod中的自定义DNS配置 295<br>4.6 Ingress 7层路由机制 297<br>4.6.1 一个完整的例子（Ingress Controller+Ingress策略+客户端访问） 298<br>4.6.2 Ingress资源对象详解 309<br>4.6.3 Ingress策略配置详解 315<br>4.6.4 Ingress的TLS安全设置 319<br>第5章 核心组件的运行机制 326<br>5.1 Kubernetes API Server原理解析 327<br>5.1.1 Kubernetes API Server概述 327<br>5.1.2 API Server架构解析 330<br>5.1.3 独特的Kubernetes Proxy API接口 335<br>5.1.4 集群功能模块之间的通信 336<br>5.1.5 API Server网络隔离的设计 338<br>5.2 Controller Manager原理解析 339<br>5.2.1 副本调度控制器 340<br>5.2.2 Node Controller 342<br>5.2.3 ResourceQuota Controller 343<br>5.2.4 Namespace Controller 345<br>5.2.5 Service Controller与Endpoints Controller 345<br>5.3 Scheduler原理解析 346<br>5.3.1 Scheduler的调度流程 347<br>5.3.2 Scheduler Framework 349<br>5.3.3 多调度器特性 351<br>5.4 kubelet运行机制解析 352<br>5.4.1 节点管理 352<br>5.4.2 Pod管理 353<br>5.4.3 容器健康检查 354<br>5.4.4 cAdvisor资源监控 355<br>5.4.5 容器运行时 357<br>5.5 kube-proxy运行机制解析 359<br>5.5.1 第一代Proxy 360<br>5.5.2 第二代Proxy 361<br>5.5.2 第三代Proxy 362<br>第6章 深入分析集群安全机制 364<br>6.1 API Server认证管理 365<br>6.1.1 HTTPS证书认证 366<br>6.1.2 HTTP Bearer Token认证 367<br>6.1.3 OpenID Connect Token第三方认证 368<br>6.1.4 Authenticating Proxy（认证代理） 372<br>6.2 API Server授权管理 373<br>6.2.1 ABAC授权模式详解 374<br>6.2.2 Webhook授权模式详解 377<br>6.2.3 RBAC授权模式详解 380<br>6.2.4 Node授权模式详解 405<br>6.3 Admission Control 406<br>6.4 Service Account 410<br>6.5 Secret私密凭据 415<br>6.6 Pod安全策略 419<br>6.6.1 PodSecurityPolicy的工作机制 419<br>6.6.2 PodSecurityPolicy配置详解 421<br>6.6.3 PodSecurityPolicy策略示例 427<br>6.6.4 PodSecurityPolicy的RBAC授权 431<br>6.6.5 Pod安全设置（Security Context）详解 436<br>第7章 网络原理 445<br>7.1 Kubernetes网络模型 446<br>7.2 Docker网络基础 448<br>7.2.1 网络命名空间 448<br>7.2.2 Veth设备对 451<br>7.2.3 网桥 454<br>7.2.4 iptables和Netfilter 456<br>7.2.5 路由 459<br>7.3 Docker的网络实现 461<br>7.3.1 查看Docker启动后的系统情况 463<br>7.3.2 查看容器启动后的网络配置（容器无端口映射） 465<br>7.3.3 查看容器启动后的网络配置（容器有端口映射） 468<br>7.3.4 Docker的网络局限性 469<br>7.4 Kubernetes的网络实现 470<br>7.4.1 容器到容器的通信 470<br>7.4.2 Pod之间的通信 471<br>7.5 Pod和Service网络实战 474<br>7.5.1 部署一个RC&#x2F;Pod 476<br>7.5.2 发布一个服务 481<br>7.6 CNI网络模型 489<br>7.6.1 CNM网络模型简介 489<br>7.6.2 CNI网络模型详解 490<br>7.6.3 在Kubernetes中使用网络插件 507<br>7.7 开源容器网络方案 508<br>7.7.1 Flannel插件的原理和部署示例 508<br>7.7.2 Open vSwitch插件的原理和部署示例 513<br>7.7.3 直接路由的原理和部署示例 518<br>7.7.4 Calico插件的原理和部署示例 521<br>7.8 Kubernetes的网络策略 541<br>7.8.1 网络策略设置说明 542<br>7.8.2 Selector功能说明 544<br>7.8.3 为命名空间配置默认的网络策略 545<br>7.8.4 网络策略应用示例 547<br>7.8.5 NetworkPolicy的发展 550<br>7.9 Kubernetes对IPv4和IPv6双栈的支持 551<br>7.9.1 为Kubernetes集群启用IPv4和IPv6双栈 551<br>7.9.2 Pod双栈IP地址验证 554<br>7.9.3 Service双栈IP地址验证 557<br>第8章 存储原理和应用 560<br>8.1 Kubernetes存储机制概述 561<br>8.1.1 将资源对象映射为存储卷 562<br>8.1.2 Node本地存储卷 569<br>8.2 持久卷（Persistent Volume）详解 573<br>8.2.1 PV和PVC的工作原理 574<br>8.2.2 PV详解 581<br>8.2.3 PVC详解 587<br>8.2.4 Pod使用PVC 589<br>8.2.5 StorageClass详解 593<br>8.3 动态存储管理实战：GlusterFS 600<br>8.3.1 准备工作 600<br>8.3.2 创建GlusterFS管理服务容器集群 600<br>8.3.3 创建Heketi服务 603<br>8.3.4 通过Heketi管理GlusterFS集群 607<br>8.3.5 定义StorageClass 610<br>8.3.6 定义PVC 610<br>8.3.7 Pod使用PVC的存储资源 613<br>8.4 CSI存储机制详解 614<br>8.4.1 CSI的设计背景 614<br>8.4.2 CSI的核心组件和部署架构 615<br>8.4.3 CSI存储插件应用实战 617<br>8.4.4 CSI存储快照管理 632<br>8.4.5 CSI的发展 638<br>第9章 Kubernetes开发指南 647<br>9.1 REST简述 648<br>9.2 Kubernetes API详解 650<br>9.2.1 Kubernetes API概述 650<br>9.2.2 Kubernetes API版本的演进策略 658<br>9.2.3 API Groups（API组） 658<br>9.2.4 API REST的方法说明 661<br>9.2.5 API Server响应说明 663<br>9.3 使用Fabric8访问Kubernetes API 665<br>9.3.1 具体应用示例 666<br>9.3.2 其他客户端库 679<br>9.4 Kubernetes API的扩展 680<br>9.4.1 使用CRD扩展API资源 681<br>9.4.2 使用API聚合机制扩展API资源 692<br>第10章 Kubernetes运维管理 702<br>10.1 Node管理 703<br>10.1.1 Node的隔离与恢复 703<br>10.1.2 Node的扩容 704<br>10.2 更新资源对象的Label 705<br>10.3 Namespace：集群环境共享与隔离 706<br>10.3.1 创建Namespace 706<br>10.3.2 定义Context 707<br>10.3.3 设置工作组在特定Context中工作 708<br>10.4 Kubernetes资源管理 710<br>10.4.1 计算资源管理 712<br>10.4.2 资源配置范围管理（LimitRange） 722<br>10.4.3 资源服务质量管理（Resource QoS） 730<br>10.4.4 资源配额管理（Resource Quotas） 738<br>10.4.5 ResourceQuota和LimitRange实践 744<br>10.4.6 Pod中多个容器共享进程命名空间 754<br>10.4.7 PID资源管理 757<br>10.4.8 节点的CPU管理策略 757<br>10.4.9 拓扑管理器 761<br>10.5 资源紧缺时的Pod驱逐机制 766<br>10.5.1 驱逐时机 766<br>10.5.2 驱逐阈值 767<br>10.5.3 节点状态 768<br>10.5.4 节点状态的振荡 769<br>10.5.5 回收Node级别的资源 769<br>10.5.6 驱逐用户的Pod 770<br>10.5.7 资源最少回收量 771<br>10.5.8 节点资源紧缺情况下的系统行为 772<br>10.5.9 可调度的资源和驱逐策略实践 773<br>10.5.10 现阶段的问题 773<br>10.6 Pod Disruption Budget（主动驱逐保护） 774<br>10.7 Kubernetes集群监控 778<br>10.7.1 使用Metrics Server监控Node和Pod的CPU和内存使用数据 778<br>10.7.2 Prometheus+Grafana集群性能监控平台搭建 783<br>10.8 Kubernetes集群日志管理 803<br>10.8.1 容器应用和系统组件输出日志的各种场景 803<br>10.8.2 Fluentd+Elasticsearch+Kibana日志系统部署 807<br>10.8.3 部署日志采集sidecar工具采集容器日志 821<br>10.9 Kubernetes的审计机制 822<br>10.10 使用Web UI（Dashboard）管理集群 826<br>10.11 Helm：Kubernetes应用包管理工具 839<br>10.11.1 Helm的整体架构 840<br>10.11.2 Helm版本说明 840<br>10.11.3 Helm的安装 842<br>10.11.4 Helm的使用 843<br>10.11.5 Chart说明 857<br>10.11.6 搭建私有Chart仓库 858<br>第11章 Trouble Shooting指南 862<br>11.1 查看系统Event 863<br>11.2 查看容器日志 865<br>11.3 查看Kubernetes服务日志 866<br>11.4 常见问题 868<br>11.4.1 由于无法下载pause镜像导致Pod一直处于Pending状态 868<br>11.4.2 Pod创建成功，但RESTARTS数量持续增加 870<br>11.4.3 通过服务名无法访问服务 871<br>11.5 寻求帮助 872<br>第12章 Kubernetes开发中的新功能 875<br>12.1 对Windows容器的支持 876<br>12.1.1 在Windows Server上安装Docker 876<br>12.1.2 在Windows Server上部署Kubernetes Node组件 877<br>12.1.3 在Windows Server上部署容器应用和服务 886<br>12.1.4 Kubernetes支持的Windows容器特性、限制和发展趋势 892<br>12.2 对GPU的支持 896<br>12.2.1 环境准备 897<br>12.2.2 在容器中使用GPU资源 900<br>12.2.3 发展趋势 902<br>12.3 Pod的垂直扩缩容 902<br>12.3.1 VPA详解 903<br>12.3.2 安装Vertical Pod Autoscaler 906<br>12.3.3 为Pod设置垂直扩缩容 906<br>12.3.4 注意事项 907<br>12.4 Kubernetes生态系统与演进路线 908<br>12.4.1 Kubernetes与CNCF 908<br>12.4.2 Kubernetes的演进路线 910<br>12.4.3 Kubernetes的开发模式 914<br>附录A Kubernetes核心服务配置详解 915</p><h3 id="Kubernetes权威指南：从Docker到Kubernetes实践全接触-PDF-下载地址"><a href="#Kubernetes权威指南：从Docker到Kubernetes实践全接触-PDF-下载地址" class="headerlink" title="Kubernetes权威指南：从Docker到Kubernetes实践全接触 PDF 下载地址:"></a>Kubernetes权威指南：从Docker到Kubernetes实践全接触 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/10h6b_BpJcqYDBuhogOm_oA?pwd=5lqf">https://pan.baidu.com/s/10h6b_BpJcqYDBuhogOm_oA?pwd=5lqf</a> </p><p>提取码：5lqf</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go并发编程实战（第2版）》</title>
      <link href="/2023/05/24/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/24/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/fe6fe0ca4452413f25f54d4132c79620.png" alt="《Go并发编程实战（第2版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书首先介绍了Go语言的优秀特性、安装设置方法、工程结构、标准命令和工具、语法基础、数据类型以及流程控制方法，接着阐述了与多进程编程和多线程编程有关的知识，然后重点介绍了goroutine、channel以及Go提供的传统同步方法，最后通过一个完整实例——网络爬虫框架进一步阐述Go语言的哲学和理念，同时分享作者在多年编程生涯中的一些见解和感悟。</p><p>与上一版相比，本书不仅基于Go 1.8对上一版进行了全面更新，而且更深入地描绘了Go运行时系统的内部机理，并且大幅改进了示例代码。</p><p>本书适用于有一定计算机编程基础的从业者以及对Go语言编程感兴趣的爱好者，非常适合作为Go语言编程进阶教程。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>郝林 从业12年有余的软件工匠，国内知名的Go语言技术布道者，Go语言北京用户组和GoHackers社群的发起人和组织者，多套免费在线Go语言教程的作者，深信Go语言在人工智能时代和机器人时代也能大放异彩的科技信徒。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　初识Go语言　　1<br>1.1　语言特性　　1<br>1.2　安装和设置　　2<br>1.3　工程结构　　3<br>1.3.1　工作区　　3<br>1.3.2　GOPATH　　4<br>1.3.3　源码文件　　5<br>1.3.4　代码包　　8<br>1.4　标准命令简述　　11<br>1.5　问候程序　　13<br>1.6　小结　　14<br>第2章　语法概览　　15<br>2.1　基本构成要素　　15<br>2.1.1　标识符　　15<br>2.1.2　关键字　　16<br>2.1.3　字面量　　17<br>2.1.4　操作符　　17<br>2.1.5　表达式　　19<br>2.2　基本类型　　20<br>2.3　高级类型　　22<br>2.3.1　数组　　23<br>2.3.2　切片　　23<br>2.3.3　字典　　24<br>2.3.4　函数和方法　　25<br>2.3.5　接口　　28<br>2.3.6　结构体　　29<br>2.4　流程控制　　30<br>2.4.1　代码块和作用域　　30<br>2.4.2　if语句　　32<br>2.4.3　switch语句　　32<br>2.4.4　for语句　　34<br>2.4.5　defer语句　　36<br>2.4.6　panic和recover　　38<br>2.5　聊天机器人　　40<br>2.6　小结　　44<br>第3章　并发编程综述　　45<br>3.1　并发编程基础　　45<br>3.1.1　串行程序与并发程序　　46<br>3.1.2　并发程序与并行程序　　46<br>3.1.3　并发程序与并发系统　　47<br>3.1.4　并发程序的不确定性　　47<br>3.1.5　并发程序内部的交互　　47<br>3.2　多进程编程　　48<br>3.2.1　进程　　48<br>3.2.2　关于同步　　55<br>3.2.3　管道　　60<br>3.2.4　信号　　65<br>3.2.5　socket　　74<br>3.3　多线程编程　　97<br>3.3.1　线程　　98<br>3.3.2　线程的同步　　107<br>3.4　多线程与多进程　　125<br>3.5　多核时代的并发编程　　126<br>3.6　小结　　130<br>第4章　Go的并发机制　　131<br>4.1　原理探究　　131<br>4.1.1　线程实现模型　　132<br>4.1.2　调度器　　142<br>4.1.3　更多细节　　158<br>4.2　goroutine　　160<br>4.2.1　go语句与goroutine　　160<br>4.2.2　主goroutine的运作　　166<br>4.2.3　runtime包与goroutine　　166<br>4.3　channel　　169<br>4.3.1　channel的基本概念　　169<br>4.3.2　单向channel　　180<br>4.3.3　for语句与channel　　184<br>4.3.4　select语句　　185<br>4.3.5　非缓冲的channel　　190<br>4.3.6　time包与channel　　192<br>4.4　实战演练：载荷发生器　　198<br>4.4.1　参数和结果　　199<br>4.4.2　基本结构　　201<br>4.4.3　初始化　　206<br>4.4.4　启动和停止　　212<br>4.4.5　调用器和功能测试　　221<br>4.5　小结　　231<br>第5章　同　　步　　232<br>5.1　锁的使用　　232<br>5.1.1　互斥锁　　232<br>5.1.2　读写锁　　236<br>5.1.3　锁的完整示例　　238<br>5.2　条件变量　　244<br>5.3　原子操作　　247<br>5.3.1　增或减　　247<br>5.3.2　比较并交换　　249<br>5.3.3　载入　　250<br>5.3.4　存储　　251<br>5.3.5　交换　　251<br>5.3.6　原子值　　252<br>5.3.7　应用于实际　　256<br>5.4　只会执行一次　　257<br>5.5　WaitGroup　　258<br>5.6　临时对象池　　262<br>5.7　实战演练——ConcurrentMap　　265<br>5.8　小结　　280<br>第6章　网络爬虫框架设计和实现　　281<br>6.1　网络爬虫与框架　　281<br>6.2　功能需求和分析　　283<br>6.3　总体设计　　284<br>6.4　详细设计　　286<br>6.4.1　基本数据结构　　286<br>6.4.2　接口的设计　　293<br>6.5　工具的实现　　309<br>6.5.1　缓冲器　　309<br>6.5.2　缓冲池　　311<br>6.5.3　多重读取器　　317<br>6.6　组件的实现　　318<br>6.6.1　内部基础接口　　319<br>6.6.2　组件注册器　　321<br>6.6.3　下载器　　323<br>6.6.4　分析器　　325<br>6.6.5　条目处理管道　　328<br>6.7　调度器的实现　　329<br>6.7.1　基本结构　　329<br>6.7.2　初始化　　331<br>6.7.3　启动　　333<br>6.7.4　停止　　343<br>6.7.5　其他方法　　344<br>6.7.6　总结　　345<br>6.8　一个简单的图片爬虫　　346<br>6.8.1　概述　　346<br>6.8.2　命令参数　　346<br>6.8.3　初始化调度器　　348<br>6.8.4　监控调度器　　354<br>6.8.5　启动调度器　　364<br>6.9　扩展与思路　　365<br>6.10　本章小结　　368<br>附录A　Go语言的学习资源　　369</p><h3 id="Go并发编程实战（第2版）-PDF-下载地址"><a href="#Go并发编程实战（第2版）-PDF-下载地址" class="headerlink" title="Go并发编程实战（第2版） PDF 下载地址:"></a>Go并发编程实战（第2版） PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1FZjrtblTQGRnZDPxGo0WVg?pwd=7oo9">https://pan.baidu.com/s/1FZjrtblTQGRnZDPxGo0WVg?pwd=7oo9</a> </p><p>提取码：7oo9</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《DevOps实践指南》</title>
      <link href="/2023/05/23/DevOps%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/23/DevOps%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/c9c87291194e8042c6dd80f9f4756516.png" alt="《DevOps实践指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书共分为6个部分：第一部分概述DevOps的历史和三个基本原则，即“三步工作法”；第二部分介绍开启DevOps转型的过程；第三到五部分深入探讨“三步工作法”的各个要素；第六部分关注如何将安全性和合规性正确集成到日常工作中。全书涵盖40余个DevOps案例，以谷歌、亚马逊、Facebook等全球知名企业和组织的实际调查结果为依据，展示如何通过现代化的运维管理提升管理效率，进而为企业赢得更大市场、创造更多利润。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Gene Kim</p><p>Tripwire创始人、前CTO，IT Revolution创始人，DevOps企业峰会主办人，畅销书《凤凰项目》合著者。</p><p>Jez Humble</p><p>DevOps Research and Assessment公司CTO，加州大学伯克利分校信息学院讲师；曾任ThoughtWorks首席顾问。《精益企业》和Jolt大奖图书《持续交付》的合著者。</p><p>Patrick Debois</p><p>DevOps之父，致力于通过在开发、项目管理和系统管理之中应用敏捷技术来填补项目和运维之间的鸿沟。</p><p>John Willis</p><p>Chain Bridge System创始人，曾任Docker公司布道师，现就职于SJ Technologies公司。</p><p>译者简介：</p><p>刘征</p><p>Nutanix路坦力资深架构师，EXIN首批国内DevOps Master和DevOps Professional认证讲师，持有红帽RHCA认证和AWS高级架构师认证，谙熟企业数据中心的IT服务管理。目前致力于推广DevOps相关的理念和实践，在DevOps社区中积极地参与培训和研讨会等活动，是DevOpsDays大会社区在中国的核心组织者和志愿工作者。</p><p>王磊</p><p>前ThoughtWorks咨询师，EXIN首批国内DevOps Master认证讲师。拥有10多年软件行业经验，以及服务化架构、持续交付和DevOps转型等方面的丰富实践经验。国内较早倡导和实践微服务的先行者，著有国内首本微服务架构相关图书《微服务架构与实践》，是西安DevOps Meetup活动的联合发起人。</p><p>马博文</p><p>前ThoughtWorks咨询师，AWS认证助理架构师、开发者。拥有多年Web开发和DevOps经验，熟悉持续交付、微服务。曾参与翻译《Scala编程实战》《DevOps实践》等书，是西安DevOps Meetup活动的发起人。</p><p>曾朝京</p><p>Micro Focus资深解决方案顾问，曾参加EXIN首批国内Devops Master讲师认证培训。长期从事IT运维管理领域咨询工作，曾为能源、金融、航空运输、政府行业中的多个大型企业提供IT运维管理规划。目前致力于探索DevOps理念在企业IT部门的实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　DevOps介绍<br>第1章　敏捷、持续交付和三步法　　4<br>1.1　制造业价值流　　4<br>1.2　技术价值流　　4<br>1.2.1　聚焦于部署前置时间　　5<br>1.2.2　关注返工指标——%C&#x2F;A　　7<br>1.3　三步工作法：DevOps的基础原则　　7<br>1.4　小结　　8<br>第2章　第一步：流动原则　　9<br>2.1　使工作可见　　9<br>2.2　限制在制品数　　10<br>2.3　减小批量大小　　11<br>2.4　减少交接次数　　13<br>2.5　持续识别和改善约束点　　14<br>2.6　消除价值流中的困境和浪费　　15<br>2.7　小结　　16<br>第3章　第二步：反馈原则　　17<br>3.1　在复杂系统中安全地工作　　17<br>3.2　及时发现问题　　18<br>3.3　群策群力，战胜问题获取新知　　19<br>3.4　在源头保障质量　　21<br>3.5　为下游工作中心而优化　　22<br>3.6　小结　　22<br>第4章　第三步：持续学习与实验原则　　23<br>4.1　建立学习型组织和安全文化　　23<br>4.2　将日常工作的改进制度化　　25<br>4.3　把局部发现转化为全局优化　　26<br>4.4　在日常工作中注入弹性模式　　27<br>4.5　领导层强化学习文化　　27<br>4.6　小结　　29<br>4.7　第一部分总结　　29<br>第二部分　从何处开始<br>第5章　选择合适的价值流作为切入点　　32<br>5.1　绿地项目与棕地项目　　34<br>5.2　兼顾记录型系统和交互型系统　　35<br>5.3　从最乐于创新的团队开始　　36<br>5.4　扩大DevOps的范围　　37<br>5.5　小结　　38<br>第6章　理解、可视化和运用价值流　　39<br>6.1　确定创造客户价值所需的团队　　40<br>6.2　针对团队工作绘制价值流图　　40<br>6.3　组建专门的转型团队　　42<br>6.3.1　拥有共同的目标　　43<br>6.3.2　保持小跨度的改进计划　　44<br>6.3.3　为非功能性需求预留20%的<br>开发时间，减少技术债务　　44<br>6.3.4　提高工作的可视化程度　　47<br>6.4　用工具强化预期行为　　47<br>6.5　小结　　48<br>第7章　参考康威定律设计组织结构　　49<br>7.1　组织原型　　51<br>7.2　过度职能导向的危害（“成本优化”）　　51<br>7.3　组建以市场为导向的团队（“速度优化”）　　52<br>7.4　使职能导向有效　　53<br>7.5　将测试、运维和信息安全融入日常工作　　54<br>7.6　使团队成员都成为通才　　54<br>7.7　投资于服务和产品，而非项目　　56<br>7.8　根据康威定律设定团队边界　　56<br>7.9　创建松耦合架构，提高生产力和安全性　　57<br>7.10　小结　　60<br>第8章　将运维融入日常开发工作　　61<br>8.1　创建共享服务，提高开发生产力　　62<br>8.2　将运维工程师融入服务团队　　63<br>8.3　为每个服务团队分派运维联络人　　64<br>8.4　邀请运维工程师参加开发团队的会议　　65<br>8.4.1　邀请运维工程师参加每日站会　　65<br>8.4.2　邀请运维工程师参加回顾会议　　66<br>8.4.3　使用看板图展示运维工作　　66<br>8.5　小结　　67<br>8.6　第二部分总结　　67<br>第三部分　第一步：流动的技术实践<br>第9章　为部署流水线奠定基础　　70<br>9.1　按需搭建开发环境、测试环境和生产环境　　71<br>9.2　应用统一的代码仓库　　72<br>9.3　使基础设施的重建更容易　　74<br>9.4　运行在类生产环境里才算“完成”　　75<br>9.5　小结　　76<br>第10章　实现快速可靠的自动化测试　　77<br>10.1　对代码和环境做持续构建、测试和集成　　79<br>10.2　构建快速可靠的自动化测试套件　　81<br>10.2.1　在自动化测试中尽早发现<br>错误　　83<br>10.2.2　尽可能并行地快速执行测试　　84<br>10.2.3　先编写自动化测试　　84<br>10.2.4　尽量将手动测试自动化　　85<br>10.2.5　在测试套件中集成性能测试　　86<br>10.2.6　在测试套件中集成非功能性需求测试　　86<br>10.3　在部署流水线失败时拉下安灯绳　　87<br>10.4　小结　　89<br>第11章　应用和实践持续集成　　90<br>11.1　小批量开发与大批量合并　　92<br>11.2　应用基于主干的开发实践　　93<br>11.3　小结　　95<br>第12章　自动化和低风险发布　　96<br>12.1　自动化部署流程　　97<br>12.1.1　应用自动化的自助式部署　　100<br>12.1.2　在部署流水线中集成代码部署　　101<br>12.2　将部署与发布解耦　　104<br>12.2.1　基于环境的发布模式　　105<br>12.2.2　基于应用的发布模式更安全　　109<br>12.3　持续交付和持续部署实践的调查　　112<br>12.4　小结　　113<br>第13章　降低发布风险的架构　　114<br>13.1　能提高生产力、可测试性和安全性的架构　　115<br>13.2　架构原型：单体架构与微服务　　116<br>13.3　安全地演进企业架构　　118<br>13.4　小结　　121<br>13.5　第三部分总结　　121<br>第四部分　第二步：反馈的技术实践<br>第14章　建立能发现并解决问题的遥测系统　　125<br>14.1　建设集中式监控架构　　127<br>14.2　建立生产环境的应用程序日志遥测　　129<br>14.3　使用遥测指导问题的解决　　131<br>14.4　将建立生产遥测融入日常工作　　132<br>14.5　建立自助访问的遥测和信息辐射器　　133<br>14.6　发现和填补遥测的盲区　　135<br>14.6.1　应用程序和业务度量指标　　136<br>14.6.2　基础架构度量指标　　137<br>14.6.3　显示叠加的指标组合　　138<br>14.7　小结　　139<br>第15章　分析遥测数据以更好地预测故障和实现目标　　140<br>15.1　用均值和标准差识别潜在问题　　141<br>15.2　异常状态的处理和告警　　142<br>15.3　非高斯分布遥测数据的问题　　143<br>15.4　应用异常检测技术　　146<br>15.5　小结　　149<br>第16章　应用反馈实现安全部署　　150<br>16.1　通过遥测使部署更安全　　151<br>16.2　开发和运维共同承担值班工作　　153<br>16.3　让开发人员跟踪工作对下游的影响　　153<br>16.4　让开发人员自行管理生产服务　　155<br>16.5　小结　　159<br>第17章　将假设驱动的开发和A&#x2F;B测试融入日常工作　　160<br>17.1　A&#x2F;B测试简史　　161<br>17.2　在功能测试中集成A&#x2F;B测试　　162<br>17.3　在发布中集成A&#x2F;B测试　　162<br>17.4　在功能规划中集成A&#x2F;B测试　　163<br>17.5　小结　　165<br>第18章　建立评审和协作流程以提升当前工作的质量　　166<br>18.1　变更审批流程的危险　　168<br>18.2 “过度控制变更”的潜在危险　　168<br>18.3　变更的协调和排程　　170<br>18.4　变更的同行评审　　170<br>18.5　人工测试和变更冻结的潜在危害　　173<br>18.6　利用结对编程改进代码变更　　173<br>18.7　消除官僚流程　　176<br>18.8　小结　　177<br>18.9　第四部分总结　　178<br>第五部分　第三步：持续学习与实验的技术实践<br>第19章　将学习融入日常工作　　180<br>19.1　建立公正和学习的文化　　181<br>19.2　举行不指责的事后分析会议　　182<br>19.3　尽可能广泛地公开事后分析会议结果　　184<br>19.4　降低事故容忍度，寻找更弱的故障信号　　185<br>19.5　重新定义失败，鼓励评估风险　　186<br>19.6　在生产环境注入故障来恢复和学习　　186<br>19.7　创建故障演练日　　187<br>19.8　小结　　189<br>第20章　将局部经验转化为全局改进　　190<br>20.1　使用聊天室和聊天机器人自动积累组织知识　　190<br>20.2　软件中便于重用的自动化、标准化流程　　192<br>20.3　创建全组织共享的单一源代码库　　192<br>20.4　运用自动化测试记录和交流实践来传播知识　　194<br>20.5　通过确定非功能性需求来设计运维　　194<br>20.6　把可重用的运维用户故事纳入开发　　195<br>20.7　确保技术选型有助于实现组织目标　　195<br>20.8　小结　　197<br>第21章　预留组织学习和改进的时间　　198<br>21.1　偿还技术债务的制度化惯例　　199<br>21.2　让所有人教学相长　　200<br>21.3　在DevOps会议中分享经验　　201<br>21.4　传播实践的内部顾问和教练　　203<br>21.5　小结　　204<br>21.6　第五部分总结　　204<br>第六部分　集成信息安全、变更管理和合规性的技术实践<br>第22章　将信息安全融入每个人的日常工作　　207<br>22.1　将安全集成到开发迭代的演示中　　207<br>22.2　将安全集成到缺陷跟踪和事后分析会议中　　208<br>22.3　将预防性安全控制集成到共享源代码库及共享服务中　　208<br>22.4　将安全集成到部署流水线中　　209<br>22.5　保证应用程序的安全性　　210<br>22.6　确保软件供应链的安全　　214<br>22.7　确保环境的安全　　215<br>22.8　将信息安全集成到生产环境遥测中　　216<br>22.9　在应用程序中建立安全遥测系统　　217<br>22.10　在环境中建立安全遥测系统　　217<br>22.11　保护部署流水线　　219<br>22.12　小结　　219<br>第23章　保护部署流水线　　220<br>23.1　将安全和合规性集成到变更批准流程中　　220<br>23.2　将大量低风险变更重新归类为标准变更　　221<br>23.3　如何处理常规变更　　222<br>23.4　减少对职责分离的依赖　　224<br>23.5　确保为审计人员和合规人员留存文档和证据　　226<br>23.6　小结　　228<br>23.7　第六部分总结　　228行动起来——本书总结　　229<br>附加材料<br>附　　录　　232<br>附录1　DevOps的大融合　　232<br>附录2　约束理论和核心的长期<br>冲突　　234<br>附录3　恶性循环列表　　235<br>附录4　交接和队列的危害　　235<br>附录5　工业安全神话　　236<br>附录6　丰田安灯绳　　237<br>附录7　软件包产品　　238<br>附录8　事后分析会议　　238<br>附录9　猿猴军团　　239<br>附录10　上线时间透明化　　240<br>参考资源　　241<br>致　　谢　　243<br>EXIN DevOps Professional认证备考<br>指南 &amp; 模拟题①　　245</p><h3 id="DevOps实践指南-PDF-下载"><a href="#DevOps实践指南-PDF-下载" class="headerlink" title="DevOps实践指南 PDF 下载"></a>DevOps实践指南 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1eYoALGdGLUjHUPT4FGZS5A?pwd=znj0">https://pan.baidu.com/s/1eYoALGdGLUjHUPT4FGZS5A?pwd=znj0</a> </p><p>提取码：znj0</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> DevOps </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript开发实战》</title>
      <link href="/2023/05/23/JavaScript%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/23/JavaScript%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/ece758c279279d142e46b17df4f21c5a.png" alt="《JavaScript开发实战》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScript开发实战》是一本 JavaScript 开发入门指导书，主要介绍了变量、对象、函数、数组、构造函数、方括号运算符、作用域、条件语句、模块、模型、视图、控制器、构建网页、控件、模板、数据加载等内容。书中涉及的概念都附有简短示例。此外，还有一个贯穿全书的持续示例 — 冒险游戏 The Crypt。读者可以在一个交互式网站上直接运行书中的代码。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>作者约翰·拉尔森是一名有30多年经验的程序员，精通JavaScript，也是一位经验丰富的教师。因此他深知读者在学习新知识、新技能过程中的困难，知道如何调动读者的积极性，帮助他们克服困难，并且善于用简洁的语言解释计算机语言的难点。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 控制台上的核心概念<br>第 1 章 编程、JavaScript 和 JS Bin<br>1.1 编程<br>1.2 JavaScript<br>1.3 在实践和思考中学习<br>1.4 JS Bin<br>1.4.1 JS Bin 面板<br>1.4.2 在 JS Bin 上运行代码清单<br>1.4.3 输出到控制台<br>1.4.4 代码注释<br>1.4.5 Further Adventures——进阶练习<br>1.4.6 错误消息<br>1.4.7 行号<br>1.4.8 获取账户<br>1.5 游戏 The Crypt——本书的一个持续示例<br>1.5.1 运行 The Crypt<br>1.5.2 创建 The Crypt 的具体步骤<br>1.6 更多示例和练习<br>1.7 浏览器的兼容性<br>1.8 本章小结<br>第 2 章 变量：在程序中存储数据<br>2.1 什么是变量<br>2.2 变量的声明和赋值<br>2.2.1 变量声明<br>2.2.2 变量赋值<br>2.2.3 一步实现变量声明和赋值<br>2.2.4 先运算再赋值<br>2.3 选择合适的变量名<br>2.3.1 关键字和保留字<br>2.3.2 变量的命名规则<br>2.3.3 骆驼式命名法（camelCase）<br>2.3.4 使用描述性变量名<br>2.4 The Crypt——玩家变量<br>2.5 本章小结<br>第 3 章 对象：数据分组<br>3.1 变量需要分组<br>3.2 创建对象<br>3.2.1 创建一个空对象<br>3.2.2 属性“键?值对”<br>3.3 访问对象的属性<br>3.4 更新对象的属性<br>3.5 其他示例<br>3.5.1 撰写一条博客<br>3.5.2 创建一个日历<br>3.5.3 天气怎么样？<br>3.5.4 一个小测验<br>3.5.5 创建自己的程序<br>3.6 游戏 The Crypt——玩家对象<br>3.7 本章小结<br>第 4 章 函数：按需执行代码<br>4.1 重复问题<br>4.1.1 将对象的属性作为文本进行显示<br>4.1.2 加税算出总成本<br>4.2 定义函数和调用函数<br>4.2.1 定义新函数<br>4.2.2 函数表达式和函数声明<br>4.2.3 使用函数<br>4.2.4 使用函数的步骤<br>4.3 减少重复<br>4.3.1 函数可用于将对象的属性作为文本进行显示<br>4.3.2 加税并显示总成本的函数<br>4.4 使代码易于阅读和更新<br>4.4.1 更新 showMovieInfo 函数<br>4.5 游戏 The Crypt——显示玩家的信息<br>4.5.1 用函数显示玩家的信息<br>4.6 本章小结<br>第 5 章 参数：将数据传递给函数<br>5.1 函数重用<br>5.2 将信息传递给函数<br>5.2.1 将实参传递给函数<br>5.2.2 将多个实参传递给一个函数<br>5.3 The Crypt——显示玩家信息<br>5.3.1 显示玩家的姓名<br>5.3.2 显示玩家的健康值<br>5.3.3 显示玩家的位置<br>5.3.4 合并显示玩家的信息<br>5.4 本章小结<br>第 6 章 返回值：从函数获取数据<br>6.1 从函数返回数据<br>6.1.1 用返回值替代函数调用<br>6.1.2 关键字 return<br>6.1.3 使用参数来确定返回值<br>6.2 在控制台提示符下进行实验<br>6.2.1 调用函数<br>6.2.2 声明新的变量<br>6.3 The Crypt——构建玩家信息字符串<br>6.3.1 为玩家的姓名、健康值和位置构建字符串<br>6.3.2 用一个函数显示玩家的信息——把几个函数集合在一起<br>6.4 本章小结<br>第 7 章 对象参数：将对象传递给函数<br>7.1 使用对象作为参数<br>7.1.1 访问对象参数的属性<br>7.1.2 给对象参数添加属性<br>7.2 从函数返回对象<br>7.2.1 构建行星——对象创建函数<br>7.2.2 二维空间的点<br>7.3 方法——设置函数作为对象的属性<br>7.3.1 命名空间——将相关函数组织到一起<br>7.3.2 Math 方法<br>7.3.3 String 方法<br>7.3.4 spacer——将更多的方法收入命名空间<br>7.3.5 进一步探索命名空间<br>7.4 The Crypt——将玩家对象作为参数<br>7.5 本章小结<br>第 8 章 数组：将数据存入列表<br>8.1 创建数组并访问元素<br>8.1.1 创建数组<br>8.1.2 访问数组元素<br>8.2 数组方法<br>8.2.1 添加和删除元素<br>8.2.2 截取和拼接数组<br>8.2.3 使用 forEach 访问每一个元素<br>8.3 The Crypt——玩家的物品数组<br>8.4 本章小结<br>第 9 章 构造函数：构建带有函数的对象<br>9.1 使用函数构建对象<br>9.1.1 添加属性<br>9.1.2 添加方法<br>9.2 使用构造函数构建对象<br>9.2.1 构造函数<br>9.2.2 使用 Planet 构造函数创建一个新世界<br>9.2.3 使用 instanceof 运算符区分对象<br>9.3 建造大师——两个构造函数的示例<br>9.4 The Crypt——为玩家提供掠夺地<br>9.4.1 构建 Place 构造函数——名称标题和描述<br>9.4.2 构建 Place 构造函数——囤积物品<br>9.4.3 构建 Place 构造函数——探索出口<br>9.5 The Crypt——简化玩家创建代码<br>9.5.1 整理玩家属性<br>9.5.2 将函数转换为方法<br>9.5.3 为玩家分配位置<br>9.5.4 使用 null 作为对象的占位符<br>9.6 本章小结<br>第 10 章 方括号运算符：灵活的属性名称<br>10.1 用方括号运算符替代圆点运算符<br>10.1.1 使用方括号——人的姓名作为键<br>10.1.2 最大限度地利用方括号运算符——单词统计<br>10.2 The Crypt——使游戏出口更加刺激好玩<br>10.2.1 使用对象存放出口<br>10.2.2 创建一个添加并显示出口的函数<br>10.2.3 设置每个场所对象的出口集合<br>10.2.4 将 exits 对象添加到完整的 Place 构造函数<br>10.2.5 测试 Place 构造函数<br>10.3 The Crypt——开始游戏！<br>10.3.1 刷新显示——render<br>10.3.2 探索地图——go<br>10.3.3 收集物品——get<br>10.3.4 设计一个更大的冒险游戏——Jahver 的船<br>10.4 下一步目标<br>10.5 本章小结<br>第二部分 组 织 代 码<br>第 11 章 作用域：隐藏信息<br>11.1 全局变量的危险性<br>11.1.1 访问所有区域——偷窥和篡改<br>11.1.2 访问所有区域——借助于实现<br>11.1.3 命名冲突<br>11.1.4 难以查找的错误<br>11.2 局部变量的优势<br>11.3 接口——控制访问权限并提供可用功能<br>11.3.1 使用一个函数来隐藏变量<br>11.3.2 使用 getCount 创建多个独立计数器<br>11.3.3 用构造函数创建多个独立的计数器<br>11.4 创建一个简单的测验应用程序<br>11.4.1 将对象用作一个命名空间<br>11.4.2 隐藏问题数组<br>11.5 The Crypt——隐藏玩家信息<br>11.5.1 当前的 Player 构造函数——全部内容都公开<br>11.5.2 更新版的 Player 构造函数——某些变量被隐藏<br>11.6 The Crypt——隐藏地点信息<br>11.7 The Crypt——用户交互<br>11.7.1 接口——go 和 get<br>11.7.2 隐藏程序的实现<br>11.8 本章小结<br>第 12 章 条件：有选择地运行代码<br>12.1 有条件地执行代码<br>12.1.1 严格相等运算符<br>12.1.2 if 语句<br>12.1.3 else 子句<br>12.1.4 隐藏函数中的密码数字</p><h3 id="JavaScript开发实战-PDF-下载"><a href="#JavaScript开发实战-PDF-下载" class="headerlink" title="JavaScript开发实战 PDF 下载"></a>JavaScript开发实战 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1i_Cez12A3o5iZl7JfO6P_w?pwd=xisp">https://pan.baidu.com/s/1i_Cez12A3o5iZl7JfO6P_w?pwd=xisp</a> </p><p>提取码：xisp</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript高级程序设计（第4版）》</title>
      <link href="/2023/05/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC4%E7%89%88)/"/>
      <url>/2023/05/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC4%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/151a8998ee2c6caeba42f688e52f9f95.png" alt="《JavaScript高级程序设计（第4版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是JavaScript 超级畅销书的最新版。ECMAScript 5 和HTML5 在标准之争中双双胜出，使大量专有实现和客户端扩展正式进入规范，同时也为JavaScript 增添了很多适应未来发展的新特性。本书这一版除增加5 章全新内容外，其他章节也有较大幅度的增补和修订，新内容篇幅约占三分之一。全书从JavaScript 语言实现的各个组成部分——语言核心、DOM、BOM、事件模型讲起，深入浅出地探讨了面向对象编程、Ajax 与Comet 服务器端通信，HTML5 表单、媒体、Canvas（包括WebGL）及Web Workers、地理定位、跨文档传递消息、客户端存储（包括IndexedDB）等新API，还介绍了离线应用和与维护、性能、部署相关的最佳开发实践。本书附录展望了未来的API 和ECMAScript Harmony 规范。</p><p>本书适合有一定编程经验的Web 应用开发人员阅读，也可作为高校及社会实用技术培训相关专业课程的教材。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Nicholas C. Zakas（尼古拉斯•泽卡斯）世界顶级Web技术专家，现为雅虎公司界面呈现架构师，负责My Yahoo!和雅虎首页等大访问量站点的设计。尼古拉斯拥有丰富的Web开发和界面设计经验，曾经参与许多世界级大公司的Web解决方案开发。他还是High Performance JavaScript一书的作者，并与他人合作撰写了Professional Ajax和Even Faster Web Sites。尼古拉斯拥有梅里马克学院计算机科学学士学位和埃迪柯特学院的MBA学位。他的个人网站是<a href="http://www.nczonline.net%EF%BC%8C%E4%BB%96%E7%9A%84Twitter%E5%88%AB%E5%90%8D%E6%98%AF@slicknet./">www.nczonline.net，他的Twitter别名是@slicknet。</a></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　JavaScript简介　　1<br>1.1　JavaScript简史　　1<br>1.2　JavaScript实现　　2<br>1.2.1　ECMAScript　　3<br>1.2.2　文档对象模型（DOM）　　5<br>1.2.3　浏览器对象模型（BOM）　　8<br>1.3　JavaScript版本　　8<br>1.4　小结　　9<br>第2章　在HTML中使用JavaScript　　10<br>2.1　&lt;\script&gt;元素　　10<br>2.1.1　标签的位置　　12<br>2.1.2　延迟脚本　　13<br>2.1.3　异步脚本　　13<br>2.1.4　在XHTML中的用法　　14<br>2.1.5　不推荐使用的语法　　16<br>2.2　嵌入代码与外部文件　　16<br>2.3　文档模式　　16<br>2.4　&lt;\noscript&gt;元素　　18<br>2.5　小结　　18<br>第3章　基本概念　　19<br>3.1　语法　　19<br>3.1.1　区分大小写　　19<br>3.1.2　标识符　　19<br>3.1.3　注释　　20<br>3.1.4　严格模式　　20<br>3.1.5　语句　　20<br>3.2　关键字和保留字　　21<br>3.3　变量　　22<br>3.4　数据类型　　23<br>3.4.1　typeof操作符　　23<br>3.4.2　Undefined类型　　24<br>3.4.3　Null类型　　25<br>3.4.4　Boolean类型　　26<br>3.4.5　Number类型　　27<br>3.4.6　String类型　　32<br>3.4.7　Object类型　　35<br>3.5　操作符　　36<br>3.5.1　一元操作符　　36<br>3.5.2　位操作符　　39<br>3.5.3　布尔操作符　　44<br>3.5.4　乘性操作符　　47<br>3.5.5　加性操作符　　48<br>3.5.6　关系操作符　　50<br>3.5.7　相等操作符　　51<br>3.5.8　条件操作符　　53<br>3.5.9　赋值操作符　　53<br>3.5.10　逗号操作符　　54<br>3.6　语句　　54<br>3.6.1　if语句　　54<br>3.6.2　do-while语句　　55<br>3.6.3　while语句　　55<br>3.6.4　for语句　　56<br>3.6.5　for-in语句　　57<br>3.6.6　label语句　　58<br>3.6.7　break和continue语句　　58<br>3.6.8　with语句　　60<br>3.6.9　switch语句　　60<br>3.7　函数　　62<br>3.7.1　理解参数　　64<br>3.7.2　没有重载　　66<br>3.8　小结　　67<br>第4章　变量、作用域和内存问题　　68<br>4.1　基本类型和引用类型的值　　68<br>4.1.1　动态的属性　　68<br>4.1.2　复制变量值　　69<br>4.1.3　传递参数　　70<br>4.1.4　检测类型　　72<br>4.2　执行环境及作用域　　73<br>4.2.1　延长作用域链　　75<br>4.2.2　没有块级作用域　　76<br>4.3　垃圾收集　　78<br>4.3.1　标记清除　　78<br>4.3.2　引用计数　　79<br>4.3.3　性能问题　　80<br>4.3.4　管理内存　　81<br>4.4　小结　　81<br>第5章　引用类型　　83<br>5.1　Object类型　　83<br>5.2　Array类型　　86<br>5.2.1　检测数组　　88<br>5.2.2　转换方法　　89<br>5.2.3　栈方法　　90<br>5.2.4　队列方法　　91<br>5.2.5　重排序方法　　92<br>5.2.6　操作方法　　94<br>5.2.7　位置方法　　95<br>5.2.8　迭代方法　　96<br>5.2.9　缩小方法　　97<br>5.3　Date类型　　98<br>5.3.1　继承的方法　　100<br>5.3.2　日期格式化方法　　101<br>5.3.3　日期&#x2F;时间组件方法　　102<br>5.4　RegExp类型　　103<br>5.4.1　RegExp实例属性　　105<br>5.4.2　RegExp实例方法　　106<br>5.4.3　RegExp构造函数属性　　107<br>5.4.4　模式的局限性　　109<br>5.5　Function类型　　110<br>5.5.1　没有重载（深入理解）　　111<br>5.5.2　函数声明与函数表达式　　111<br>5.5.3　作为值的函数　　112<br>5.5.4　函数内部属性　　113<br>5.5.5　函数属性和方法　　116<br>5.6　基本包装类型　　118<br>5.6.1　Boolean类型　　120<br>5.6.2　Number类型　　120<br>5.6.3　String类型　　122<br>5.7　单体内置对象　　130<br>5.7.1　Global对象　　131<br>5.7.2　Math对象　　134<br>5.8　小结　　137<br>第6章　面向对象的程序设计　　138<br>6.1　理解对象　　138<br>6.1.1　属性类型　　139<br>6.1.2　定义多个属性　　142<br>6.1.3　读取属性的特性　　143<br>6.2　创建对象　　144<br>6.2.1　工厂模式　　144<br>6.2.2　构造函数模式　　144<br>6.2.3　原型模式　　147<br>6.2.4　组合使用构造函数模式和原型模式　　159<br>6.2.5　动态原型模式　　159<br>6.2.6　寄生构造函数模式　　160<br>6.2.7　稳妥构造函数模式　　161<br>6.3　继承　　162<br>6.3.1　原型链　　162<br>6.3.2　借用构造函数　　167<br>6.3.3　组合继承　　168<br>6.3.4　原型式继承　　169<br>6.3.5　寄生式继承　　171<br>6.3.6　寄生组合式继承　　172<br>6.4　小结　　174<br>第7章　函数表达式　　175<br>7.1　递归　　177<br>7.2　闭包　　178<br>7.2.1　闭包与变量　　181<br>7.2.2　关于this对象　　182<br>7.2.3　内存泄漏　　183<br>7.3　模仿块级作用域　　184<br>7.4　私有变量　　186<br>7.4.1　静态私有变量　　188<br>7.4.2　模块模式　　189<br>7.4.3　增强的模块模式　　191<br>7.5　小结　　192<br>第8章　BOM　　193<br>8.1　window对象　　193<br>8.1.1　全局作用域　　193<br>8.1.2　窗口关系及框架　　194<br>8.1.3　窗口位置　　197<br>8.1.4　窗口大小　　198<br>8.1.5　导航和打开窗口　　199<br>8.1.6　间歇调用和超时调用　　203<br>8.1.7　系统对话框　　205<br>8.2　location对象　　207<br>8.2.1　查询字符串参数　　207<br>8.2.2　位置操作　　208<br>8.3　navigator对象　　210<br>8.3.1　检测插件　　211<br>8.3.2　注册处理程序　　213<br>8.4　screen对象　　214<br>8.5　history对象　　215<br>8.6　小结　　216<br>第9章　客户端检测　　217<br>9.1　能力检测　　217<br>9.1.1　更可靠的能力检测　　218<br>9.1.2　能力检测，不是浏览器检测　　220<br>9.2　怪癖检测　　220<br>9.3　用户代理检测　　221<br>9.3.1　用户代理字符串的历史　　222<br>9.3.2　用户代理字符串检测技术　　228<br>9.3.3　完整的代码　　242<br>9.3.4　使用方法　　245<br>9.4　小结　　246<br>第10章　DOM　　247<br>10.1　节点层次　　247<br>10.1.1　Node类型　　248<br>10.1.2　Document类型　　253<br>10.1.3　Element类型　　261<br>10.1.4　Text类型　　270<br>10.1.5　Comment类型　　273<br>10.1.6　CDATASection类型　　274<br>10.1.7　DocumentType类型　　274<br>10.1.8　DocumentFragment类型　　275<br>10.1.9　Attr类型　　276<br>10.2　DOM操作技术　　277<br>10.2.1　动态脚本　　277<br>10.2.2　动态样式　　279<br>10.2.3　操作表格　　281<br>10.2.4　使用NodeList　　283<br>10.3　小结　　284<br>第11章　DOM扩展　　286<br>11.1　选择符API　　286<br>11.1.1　querySelector()方法　　286<br>11.1.2　querySelectorAll()<br>方法　　287<br>11.1.3　matchesSelector()<br>方法　　288<br>11.2　元素遍历　　288<br>11.3　HTML5　　289<br>11.3.1　与类相关的扩充　　289<br>11.3.2　焦点管理　　291<br>11.3.3　HTMLDocument的变化　　292<br>11.3.4　字符集属性　　293<br>11.3.5　自定义数据属性　　293<br>11.3.6　插入标记　　294<br>11.3.7　scrollIntoView()方法　　298<br>11.4　专有扩展　　298<br>11.4.1　文档模式　　298<br>11.4.2　children属性　　299<br>11.4.3　contains()方法　　300<br>11.4.4　插入文本　　301<br>11.4.5　滚动　　303<br>11.5　小结　　304<br>第12章　DOM2和DOM3　　305<br>12.1　DOM变化　　305<br>12.1.1　针对XML命名空间的变化　　306<br>12.1.2　其他方面的变化　　309<br>12.2　样式　　312<br>12.2.1　访问元素的样式　　313<br>12.2.2　操作样式表　　317<br>12.2.3　元素大小　　320<br>12.3　遍历　　326<br>12.3.1　NodeIterator　　328<br>12.3.2　TreeWalker　　330<br>12.4　范围　　332<br>12.4.1　DOM中的范围　　332<br>12.4.2　IE8及更早版本中的范围　　340<br>12.5　小结　　343<br>第13章　事件　　345<br>13.1　事件流　　345<br>13.1.1　事件冒泡　　346<br>13.1.2　事件捕获　　346<br>13.1.3　DOM事件流　　347<br>13.2　事件处理程序　　348<br>13.2.1　HTML事件处理程序　　348<br>13.2.2　DOM0级事件处理程序　　350<br>13.2.3　DOM2级事件处理程序　　351<br>13.2.4　IE事件处理程序　　352<br>13.2.5　跨浏览器的事件处理程序　　353<br>13.3　事件对象　　355<br>13.3.1　DOM中的事件对象　　355<br>13.3.2　IE中的事件对象　　358<br>13.3.3　跨浏览器的事件对象　　360<br>13.4　事件类型　　362<br>13.4.1　UI事件　　362<br>13.4.2　焦点事件　　367<br>13.4.3　鼠标与滚轮事件　　368<br>13.4.4　键盘与文本事件　　379<br>13.4.5　复合事件　　384<br>13.4.6　变动事件　　385<br>13.4.7　HTML5事件　　388<br>13.4.8　设备事件　　395<br>13.4.9　触摸与手势事件　　399<br>13.5　内存和性能　　402<br>13.5.1　事件委托　　402<br>13.5.2　移除事件处理程序　　404<br>13.6　模拟事件　　405<br>13.6.1　DOM中的事件模拟　　405<br>13.6.2　IE中的事件模拟　　410<br>13.7　小结　　411<br>第14章　表单脚本　　412<br>14.1　表单的基础知识　　412<br>14.1.1　提交表单　　413<br>14.1.2　重置表单　　414<br>14.1.3　表单字段　　414<br>14.2　文本框脚本　　419<br>14.2.1　选择文本　　420<br>14.2.2　过滤输入　　423<br>14.2.3　自动切换焦点　　426<br>14.2.4　HTML5约束验证API　　427<br>14.3　选择框脚本　　431<br>14.3.1　选择选项　　432<br>14.3.2　添加选项　　434<br>14.3.3　移除选项　　435<br>14.3.4　移动和重排选项　　435<br>14.4　表单序列化　　436<br>14.5　富文本编辑　　438<br>14.5.1　使用contenteditable<br>属性　　438<br>14.5.2　操作富文本　　439<br>14.5.3　富文本选区　　441<br>14.5.4　表单与富文本　　443<br>14.6　小结　　443<br>第15章　使用Canvas绘图　　445<br>15.1　基本用法　　445<br>15.2　2D上下文　　446<br>15.2.1　填充和描边　　446<br>15.2.2　绘制矩形　　447<br>15.2.3　绘制路径　　449<br>15.2.4　绘制文本　　451<br>15.2.5　变换　　453<br>15.2.6　绘制图像　　456<br>15.2.7　阴影　　457<br>15.2.8　渐变　　458<br>15.2.9　模式　　460<br>15.2.10　使用图像数据　　460<br>15.2.11　合成　　462<br>15.3　WebGL　　463<br>15.3.1　类型化数组　　463<br>15.3.2　WebGL上下文　　468<br>15.3.3　支持　　478<br>15.4　小结　　478<br>第16章　HTML5脚本编程　　480<br>16.1　跨文档消息传递　　480<br>16.2　原生拖放　　481<br>16.2.1　拖放事件　　482<br>16.2.2　自定义放置目标　　482<br>16.2.3　dataTransfer对象　　483<br>16.2.4　dropEffect与effectAllowed　　484<br>16.2.5　可拖动　　485<br>16.2.6　其他成员　　485<br>16.3　媒体元素　　486<br>16.3.1　属性　　487<br>16.3.2　事件　　488<br>16.3.3　自定义媒体播放器　　488<br>16.3.4　检测编解码器的支持情况　　489<br>16.3.5　Audio类型　　490<br>16.4　历史状态管理　　491<br>16.5　小结　　492<br>第17章　错误处理与调试　　493<br>17.1　浏览器报告的错误　　493<br>17.1.1　IE　　493<br>17.1.2　Firefox　　494<br>17.1.3　Safari　　496<br>17.1.4　Opera　　497<br>17.1.5　Chrome　　498<br>17.2　错误处理　　499<br>17.2.1　try-catch语句　　500<br>17.2.2　抛出错误　　503<br>17.2.3　错误（error）事件　　505<br>17.2.4　处理错误的策略　　506<br>17.2.5　常见的错误类型　　507<br>17.2.6　区分致命错误和非致命<br>错误　　510<br>17.2.7　把错误记录到服务器　　511<br>17.3　调试技术　　512<br>17.3.1　将消息记录到控制台　　512<br>17.3.2　将消息记录到当前页面　　515<br>17.3.3　抛出错误　　515<br>17.4　常见的IE错误　　516<br>17.4.1　操作终止　　516<br>17.4.2　无效字符　　518<br>17.4.3　未找到成员　　518<br>17.4.4　未知运行时错误　　519<br>17.4.5　语法错误　　519<br>17.4.6　系统无法找到指定资源　　519<br>17.5　小结　　520<br>第18章　JavaScript与XML　　521<br>18.1　浏览器对XML DOM的支持　　521<br>18.1.1　DOM2级核心　　521<br>18.1.2　DOMParser类型　　522<br>18.1.3　XMLSerializer类型　　523<br>18.1.4　IE8及之前版本中的XML　　523<br>18.1.5　跨浏览器处理XML　　527<br>18.2　浏览器对XPath的支持　　529<br>18.2.1　DOM3级XPath　　529<br>18.2.2　IE中的XPath　　534<br>18.2.3　跨浏览器使用XPath　　535<br>18.3　浏览器对XSLT的支持　　537<br>18.3.1　IE中的XSLT　　537<br>18.3.2　XSLTProcessor类型　　541<br>18.3.3　跨浏览器使用XSLT　　543<br>18.4　小结　　544<br>第19章　E4X　　546<br>19.1　E4X的类型　　546<br>19.1.1　XML类型　　546<br>19.1.2　XMLList类型　　547<br>19.1.3　Namespace类型　　548<br>19.1.4　QName类型　　549<br>19.2　一般用法　　550<br>19.2.1　访问特性　　551<br>19.2.2　其他节点类型　　552<br>19.2.3　查询　　553<br>19.2.4　构建和操作XML　　555<br>19.2.5　解析和序列化　　557<br>19.2.6　命名空间　　558<br>19.3　其他变化　　559<br>19.4　全面启用E4X　　560<br>19.5　小结　　561<br>第20章　JSON　　562<br>20.1　语法　　562<br>20.1.1　简单值　　562<br>20.1.2　对象　　563<br>20.1.3　数组　　564<br>20.2　解析与序列化　　565<br>20.2.1　JSON对象　　565<br>20.2.2　序列化选项　　566<br>20.2.3　解析选项　　569<br>20.3　小结　　570<br>第21章　Ajax与Comet　　571<br>21.1　XMLHttpRequest对象　　571<br>21.1.1　XHR的用法　　573<br>21.1.2　HTTP头部信息　　575<br>21.1.3　GET请求　　576<br>21.1.4　POST请求　　577<br>21.2　XMLHttpRequest 2级　　578<br>21.2.1　FormData　　578<br>21.2.2　超时设定　　579<br>21.2.3　overrideMimeType()<br>方法　　580<br>21.3　进度事件　　580<br>21.3.1　load事件　　580<br>21.3.2　progress事件　　581<br>21.4　跨源资源共享　　582<br>21.4.1　IE对CORS的实现　　582<br>21.4.2　其他浏览器对CORS的<br>实现　　584<br>21.4.3　Preflighted Reqeusts　　584<br>21.4.4　带凭据的请求　　585<br>21.4.5　跨浏览器的CORS　　585<br>21.5　其他跨域技术　　586<br>21.5.1　图像Ping　　586<br>21.5.2　JSONP　　587<br>21.5.3　Comet　　588<br>21.5.4　服务器发送事件　　590<br>21.5.5　Web Sockets　　591<br>21.5.6　SSE与Web Sockets　　593<br>21.6　安全　　593<br>21.7　小结　　594<br>第22章　高级技巧　　596<br>22.1　高级函数　　596<br>22.1.1　安全的类型检测　　596<br>22.1.2　作用域安全的构造函数　　597<br>22.1.3　惰性载入函数　　600<br>22.1.4　函数绑定　　602<br>22.1.5　函数柯里化　　604<br>22.2　防篡改对象　　606<br>22.2.1　不可扩展对象　　606<br>22.2.2　密封的对象　　607<br>22.2.3　冻结的对象　　608<br>22.3　高级定时器　　609<br>22.3.1　重复的定时器　　610<br>22.3.2　Yielding Processes　　612<br>22.3.3　函数节流　　614<br>22.4　自定义事件　　616<br>22.5　拖放　　618<br>22.5.1　修缮拖动功能　　620<br>22.5.2　添加自定义事件　　622<br>22.6　小结　　624<br>第23章　离线应用与客户端存储　　626<br>23.1　离线检测　　626<br>23.2　应用缓存　　627<br>23.3　数据存储　　628<br>23.3.1　Cookie　　629<br>23.3.2　IE用户数据　　637<br>23.3.3　Web存储机制　　638<br>23.3.4　IndexedDB　　643<br>23.4　小结　　654<br>第24章　最佳实践　　656<br>24.1　可维护性　　656<br>24.1.1　什么是可维护的代码　　656<br>24.1.2　代码约定　　657<br>24.1.3　松散耦合　　659<br>24.1.4　编程实践　　662<br>24.2　性能　　666<br>24.2.1　注意作用域　　666<br>24.2.2　选择正确方法　　667<br>24.2.3　最小化语句数　　672<br>24.2.4　优化DOM交互　　673<br>24.3　部署　　676<br>24.3.1　构建过程　　676<br>24.3.2　验证　　677<br>24.3.3　压缩　　679<br>24.4　小结　　681<br>第25章　新兴的API　　682<br>25.1　requestAnimationFrame()　　682<br>25.1.1　早期动画循环　　682<br>25.1.2　循环间隔的问题　　683<br>25.1.3　mozRequestAnimation-Frame　　683<br>25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685<br>25.2　Page Visibility API　　686<br>25.3　Geolocation API　　687<br>25.4　File API　　689<br>25.4.1　FileReader类型　　690<br>25.4.2　读取部分内容　　692<br>25.4.3　对象URL　　693<br>25.4.4　读取拖放的文件　　694<br>25.4.5　使用XHR上传文件　　695<br>25.5　Web计时　　696<br>25.6　Web Workers　　697<br>25.6.1　使用Worker　　697<br>25.6.2　Worker全局作用域　　698<br>25.6.3　包含其他脚本　　699<br>25.6.4　Web Workers的未来　　700<br>25.7　小结　　700<br>附录A　ECMAScript Harmony　　701<br>附录B　严格模式　　717<br>附录C　JavaScript库　　723<br>附录D　JavaScript工具　　727</p><h3 id="JavaScript高级程序设计（第4版）-PDF-下载"><a href="#JavaScript高级程序设计（第4版）-PDF-下载" class="headerlink" title="JavaScript高级程序设计（第4版） PDF 下载"></a>JavaScript高级程序设计（第4版） PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Ejf6rmDtITQH0eBtAqjkCA?pwd=8j6a">https://pan.baidu.com/s/1Ejf6rmDtITQH0eBtAqjkCA?pwd=8j6a</a> </p><p>提取码：8j6a</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java并发编程的艺术》</title>
      <link href="/2023/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2023/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/dcxonocjsjnrxrnqdsuhifnylcifmjbx.png" alt="《Java并发编程的艺术》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>并发编程领域的扛鼎之作，作者是阿里和1号店的资深Java技术专家，对并发编程有非常深入的研究，《Java并发编程的艺术》是他们多年一线开发经验的结晶。本书的部分内容在出版早期发表在Java并发编程网和InfoQ等技术社区，得到了非常高的评价。它选取了Java并发编程中最核心的技术进行讲解，从JDK源码、JVM、CPU等多角度全面剖析和讲解了Java并发编程的框架、工具、原理和方法，对Java并发编程进行了最为深入和透彻的阐述。</p><p>《Java并发编程的艺术》内容涵盖Java并发编程机制的底层实现原理、Java内存模型、Java并发编程基础、Java中的锁、并发容器和框架、原子类、并发工具类、线程池、Executor框架等主题，每个主题都做了深入的讲解，同时通过实例介绍了如何应用这些技术。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>方腾飞（花名清英，英文名kiral），</p><p>蚂蚁金服集团技术专家，从事Java开发近10年。5年以上的团队管理、项目管理和敏捷开发经验，崇尚团队合作。曾参与CMS、电子海图、SOC、ITIL、电子商务网站和信贷管理系统等项目。目前在蚂蚁金服网商银行贷款管理团队负责数据采集平台开发工作。与同事合作开发了tala code Review插件，深受阿里数千名工程师拥趸，并开发过开源工具jdbcutil（<a href="https://github.com/kiral/utils%EF%BC%89%E3%80%82%E5%88%9B%E5%8A%9E%E4%BA%86%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BD%91%EF%BC%8C%E7%BB%84%E7%BB%87%E7%BF%BB%E8%AF%91%E4%BA%86%E7%99%BE%E4%BD%99%E7%AF%87%E5%9B%BD%E5%A4%96%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E6%9B%BE%E4%B8%BAInfoQ%E6%92%B0%E5%86%99%E2%80%9C%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91%E2%80%9D%E4%B8%93%E6%A0%8F%EF%BC%8C%E5%9C%A8%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E3%80%8B%E6%9D%82%E5%BF%97%E6%92%B0%E5%86%99%E6%95%8F%E6%8D%B7%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0">https://github.com/kiral/utils）。创办了并发编程网，组织翻译了百余篇国外优秀技术文章，并曾为InfoQ撰写“聊聊并发”专栏，在《程序员》杂志撰写敏捷实践系列文章</a></p><p>魏　鹏，</p><p>阿里巴巴集团技术专家，在阿里巴巴中国网站技术部工作多年，曾担任中国网站交易平台架构师，主导了交易系统服务化工作，设计实现的数据迁移系统高效地完成了阿里巴巴中国网站交易数据到阿里巴巴集团的迁移工作。目前在阿里巴巴共享业务事业部从事Java应用容器Pandora和服务框架HSF的相关工作，其中Java应用容器Pandora是阿里巴巴中间件运行的基础，而服务框架HSF则是阿里巴巴集团实现服务化的主要解决方案，二者在阿里巴巴拥有最为广泛的使用量。个人平时喜欢阅读技术书籍，翻译一些国外优秀文档，喜欢总结、乐于分享，对Java应用容器、多线程编程以及分布式系统感兴趣。</p><p>程晓明，</p><p>1号店资深架构师，从事1号店交易平台系统的开发，技术上关注并发与NIO。因5年前遇到的一个线上故障，解决过程中对Java并发编程产生了浓厚的兴趣，从此开始了漫长的探索之旅：从底层实现机制、内存模型到Java同步。纵观我自己对Java并发的学习过程，是一个从高层到底层再到高层的一个反复迭代的过程，我估计很多读者的学习过程应该与我类似。文章多见诸《IBM developerWorks》、InfoQ和《程序员》杂志。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前　言<br>第1章　并发编程的挑战 1<br>1.1　上下文切换 1<br>1.1.1　多线程一定快吗 1<br>1.1.2　测试上下文切换次数和时长 3<br>1.1.3　如何减少上下文切换 3<br>1.1.4　减少上下文切换实战 4<br>1.2　死锁 5<br>1.3　资源限制的挑战 6<br>1.4　本章小结 7<br>第2章　Java并发机制的底层实现原理 8<br>2.1　volatile的应用 8<br>2.2　synchronized的实现原理与应用 11<br>2.2.1　Java对象头 12<br>2.2.2　锁的升级与对比 13<br>2.3　原子操作的实现原理 16<br>2.4　本章小结 20<br>第3章　Java内存模型 21<br>3.1　Java内存模型的基础 21<br>3.1.1　并发编程模型的两个关键问题 21<br>3.1.2　Java内存模型的抽象结构 22<br>3.1.3　从源代码到指令序列的重排序 23<br>3.1.4　并发编程模型的分类 24<br>3.1.5　happens-before简介 26<br>3.2　重排序 27<br>3.2.1　数据依赖性 28<br>3.2.2　as-if-serial语义 28<br>3.2.3　程序顺序规则 29<br>3.2.4　重排序对多线程的影响 29<br>3.3　顺序一致性 31<br>3.3.1　数据竞争与顺序一致性 31<br>3.3.2　顺序一致性内存模型 32<br>3.3.3　同步程序的顺序一致性效果 34<br>3.3.4　未同步程序的执行特性 35<br>3.4　volatile的内存语义 38<br>3.4.1　volatile的特性 38<br>3.4.2　volatile写-读建立的happens-before关系 39<br>3.4.3　volatile写-读的内存语义 40<br>3.4.4　volatile内存语义的实现 42<br>3.4.5　JSR-133为什么要增强volatile的内存语义 46<br>3.5　锁的内存语义 47<br>3.5.1　锁的释放-获取建立的<br>happens-before关系 47<br>3.5.2　锁的释放和获取的内存语义 48<br>3.5.3　锁内存语义的实现 50<br>3.5.4　concurrent包的实现 54<br>3.6　final域的内存语义 55<br>3.6.1　final域的重排序规则 55<br>3.6.2　写final域的重排序规则 56<br>3.6.3　读final域的重排序规则 57<br>3.6.4　final域为引用类型 58<br>3.6.5　为什么final引用不能从构造函数内“溢出” 59<br>3.6.6　final语义在处理器中的实现 61<br>3.6.7　JSR-133为什么要增强f?inal的语义 62<br>3.7　happens-before 62<br>3.7.1　JMM的设计 62<br>3.7.2　happens-before的定义 64<br>3.7.3　happens-before规则 65<br>3.8　双重检查锁定与延迟初始化 67<br>3.8.1　双重检查锁定的由来 67<br>3.8.2　问题的根源 69<br>3.8.3　基于volatile的解决方案 71<br>3.8.4　基于类初始化的解决方案 72<br>3.9　Java内存模型综述 78<br>3.9.1　处理器的内存模型 78<br>3.9.2　各种内存模型之间的关系 80<br>3.9.3　JMM的内存可见性保证 80<br>3.9.4　JSR-133对旧内存模型的修补 81<br>3.10　本章小结 82<br>第4章　Java并发编程基础 83<br>4.1　线程简介 83<br>4.1.1　什么是线程 83<br>4.1.2　为什么要使用多线程 84<br>4.1.3　线程优先级 85<br>4.1.4　线程的状态 87<br>4.1.5　Daemon线程 90<br>4.2　启动和终止线程 91<br>4.2.1　构造线程 91<br>4.2.2　启动线程 92<br>4.2.3　理解中断 92<br>4.2.4　过期的suspend()、resume()和stop() 93<br>4.2.5　安全地终止线程 95<br>4.3　线程间通信 96<br>4.3.1　volatile和synchronized关键字 96<br>4.3.2　等待&#x2F;通知机制 98<br>4.3.3　等待&#x2F;通知的经典范式 101<br>4.3.4　管道输入&#x2F;输出流 102<br>4.3.5　Thread.join()的使用 103<br>4.3.6　ThreadLocal的使用 105<br>4.4　线程应用实例 106<br>4.4.1　等待超时模式 106<br>4.4.2　一个简单的数据库连接池示例 106<br>4.4.3　线程池技术及其示例 110<br>4.4.4　一个基于线程池技术的简单Web服务器 114<br>4.5　本章小结 118<br>第5章　Java中的锁 119<br>5.1　Lock接口 119<br>5.2　队列同步器 121<br>5.2.1　队列同步器的接口与示例 121<br>5.2.2　队列同步器的实现分析 124<br>5.3　重入锁 136<br>5.4　读写锁 140<br>5.4.1　读写锁的接口与示例 141<br>5.4.2　读写锁的实现分析 142<br>5.5　LockSupport工具 146<br>5.6　Condition接口 147<br>5.6.1　Condition接口与示例 148<br>5.6.2　Condition的实现分析 150<br>5.7　本章小结 154<br>第6章　Java并发容器和框架 155<br>6.1　ConcurrentHashMap的实现原理与使用 155<br>6.1.1　为什么要使用ConcurrentHashMap 155<br>6.1.2　ConcurrentHashMap的结构 156<br>6.1.3　ConcurrentHashMap的初始化 157<br>6.1.4　定位Segment 159<br>6.1.5　ConcurrentHashMap的操作 160<br>6.2　ConcurrentLinkedQueue 161<br>6.2.1　ConcurrentLinkedQueue的结构 162<br>6.2.2　入队列 162<br>6.2.3　出队列 165<br>6.3　Java中的阻塞队列 167<br>6.3.1　什么是阻塞队列 167<br>6.3.2　Java里的阻塞队列 168<br>6.3.3　阻塞队列的实现原理 172<br>6.4　Fork&#x2F;Join框架 175<br>6.4.1　什么是Fork&#x2F;Join框架 175<br>6.4.2　工作窃取算法 176<br>6.4.3　Fork&#x2F;Join框架的设计 177<br>6.4.4　使用Fork&#x2F;Join框架 177<br>6.4.5　Fork&#x2F;Join框架的异常处理 179<br>6.4.6　Fork&#x2F;Join框架的实现原理 179<br>6.5　本章小结 181<br>第7章　Java中的13个原子操作类 182<br>7.1　原子更新基本类型类 182<br>7.2　原子更新数组 184<br>7.3　原子更新引用类型 185<br>7.4　原子更新字段类 187<br>7.5　本章小结 188<br>第8章　Java中的并发工具类 189<br>8.1　等待多线程完成的CountDownLatch 189<br>8.2　同步屏障CyclicBarrier 191<br>8.2.1　CyclicBarrier简介 191<br>8.2.2　CyclicBarrier的应用场景 193<br>8.2.3　CyclicBarrier和CountDownLatch的区别 195<br>8.3　控制并发线程数的Semaphore 196<br>8.4　线程间交换数据的Exchanger 198<br>8.5　本章小结 199<br>第9章　Java中的线程池 200<br>9.1　线程池的实现原理 200<br>9.2　线程池的使用 203<br>9.2.1　线程池的创建 203<br>9.2.2　向线程池提交任务 205<br>9.2.3　关闭线程池 205<br>9.2.4　合理地配置线程池 206<br>9.2.5　线程池的监控 206<br>9.3　本章小结 207<br>第10章　Executor框架 208<br>10.1　Executor框架简介 208<br>10.1.1　Executor框架的两级调度模型 208<br>10.1.2　Executor框架的结构与成员 208<br>10.2　ThreadPoolExecutor详解 213<br>10.2.1　FixedThreadPool详解 213<br>10.2.2　SingleThreadExecutor详解 214<br>10.2.3　CachedThreadPool详解 215<br>10.3　ScheduledThreadPoolExecutor详解 217<br>10.3.1　ScheduledThreadPoolExecutor的运行机制 217<br>10.3.2　ScheduledThreadPoolExecutor的实现 218<br>10.4　FutureTask详解 221<br>10.4.1　FutureTask简介 222<br>10.4.2　FutureTask的使用 222<br>10.4.3　FutureTask的实现 224<br>10.5　本章小结 227<br>第11章　Java并发编程实践 228<br>11.1　生产者和消费者模式 228<br>11.1.1　生产者消费者模式实战 229<br>11.1.2　多生产者和多消费者场景 231<br>11.1.3　线程池与生产消费者模式 234<br>11.2　线上问题定位 234<br>11.3　性能测试 236<br>11.4　异步任务池 238<br>11.5　本章小结 240</p><h3 id="Java并发编程的艺术-PDF-下载"><a href="#Java并发编程的艺术-PDF-下载" class="headerlink" title="Java并发编程的艺术 PDF 下载"></a>Java并发编程的艺术 PDF 下载</h3><hr><p>链接:<a href="https://pan.baidu.com/s/1gQ-AFPpz3m2lzu_O9UauLg?pwd=dwkg">https://pan.baidu.com/s/1gQ-AFPpz3m2lzu_O9UauLg?pwd=dwkg</a> </p><p>提取码:dwkg </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python深度学习》</title>
      <link href="/2023/05/23/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/05/23/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/gvluhmjxgnjunsufyklkcyjlgiylhynr.png" alt="《Python深度学习》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><ul><li><p>深度学习名著重磅升级，涵盖Transformer架构等开创性进展</p></li><li><p>流行深度学习框架Keras之父执笔，文字生动、见解深刻</p></li><li><p>不用一个数学公式，利用直觉自然入门深度学习</p></li></ul><p>近年来，深度学习在自然语言处理、计算机视觉等领域取得了非凡的进展。从机器翻译和文本生成到自动驾驶和虚拟助手，我们受益于深度学习技术的逐渐普及。然而，深度学习还远未发挥全部潜力。欢迎来到深度学习的世界！在这个规模呈爆发式增长的领域，仍有许多“宝藏”等待你去发掘。</p><p>本书由流行深度学习框架Keras之父弗朗索瓦·肖莱执笔，不用数学公式，而用Python代码帮助你直观理解深度学习的核心思想。本书在第1版的基础上进行了大幅更新和增补，以体现深度学习领域的快速发展。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>【作者简介】</p><p>弗朗索瓦·肖莱（François Chollet）</p><p>谷歌公司深度学习科学家，流行深度学习框架Keras之父。Keras的GitHub星标数近6万，用户数量已超100万。此外，他也是TensorFlow框架的贡献者，个人Kaggle竞赛全球排名曾获第17名。利用Keras，他致力于普及深度学习技术和实现通用人工智能。</p><p>【译者简介】</p><p>张亮（hysic）</p><p>毕业于北京大学物理学院，核安全高级工程师，深谙机器学习和数据分析，译有《Python机器学习基础教程》《Python数据处理》等。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　什么是深度学习 1<br>1.1　人工智能、机器学习和深度学习 1<br>1.1.1　人工智能 2<br>1.1.2　机器学习 2<br>1.1.3　从数据中学习规则与表示 3<br>1.1.4　深度学习之“深度” 5<br>1.1.5　用三张图理解深度学习的工作原理 7<br>1.1.6　深度学习已取得的进展 8<br>1.1.7　不要相信短期炒作 9<br>1.1.8　人工智能的未来 10<br>1.2　深度学习之前：机器学习简史 10<br>1.2.1　概率建模 11<br>1.2.2　早期神经网络 11<br>1.2.3　核方法 11<br>1.2.4　决策树、随机森林和梯度提升机 12<br>1.2.5　回到神经网络 13<br>1.2.6　深度学习有何不同 14<br>1.2.7　机器学习现状 14<br>1.3　为什么要用深度学习，为什么是现在 16<br>1.3.1　硬件 17<br>1.3.2　数据 17<br>1.3.3　算法 18<br>1.3.4　新一轮投资热潮 18<br>1.3.5　深度学习的普及 19<br>1.3.6　这种趋势会持续下去吗 20<br>第2章　神经网络的数学基础 21<br>2.1　初识神经网络 21<br>2.2　神经网络的数据表示 25<br>2.2.1　标量（0阶张量） 25<br>2.2.2　向量（1阶张量） 25<br>2.2.3　矩阵（2阶张量） 26<br>2.2.4　3阶张量与更高阶的张量 26<br>2.2.5　关键属性 26<br>2.2.6　在NumPy中操作张量 28<br>2.2.7　数据批量的概念 28<br>2.2.8　现实世界中的数据张量实例 29<br>2.2.9　向量数据 29<br>2.2.10　时间序列数据或序列数据 29<br>2.2.11　图像数据 30<br>2.2.12　视频数据 31<br>2.3　神经网络的“齿轮”：张量运算 31<br>2.3.1　逐元素运算 32<br>2.3.2　广播 33<br>2.3.3　张量积 34<br>2.3.4　张量变形 36<br>2.3.5　张量运算的几何解释 37<br>2.3.6　深度学习的几何解释 40<br>2.4　神经网络的“引擎”：基于梯度的优化 40<br>2.4.1　什么是导数 41<br>2.4.2　张量运算的导数：梯度 42<br>2.4.3　随机梯度下降 44<br>2.4.4　链式求导：反向传播算法 46<br>2.5　回顾第一个例子 51<br>2.5.1　用TensorFlow 从头开始重新实现第一个例子 52<br>2.5.2　完成一次训练步骤 54<br>2.5.3　完整的训练循环 55<br>2.5.4　评估模型 55<br>2.6　本章总结 56<br>第3章　Keras 和TensorFlow 入门 57<br>3.1　TensorFlow 简介 57<br>3.2　Keras 简介 58<br>3.3　Keras 和TensorFlow 简史 59<br>3.4　建立深度学习工作区 60<br>3.4.1　Jupyter笔记本：运行深度学习实验的首选方法 60<br>3.4.2　使用Colaboratory 61<br>3.5　TensorFlow入门 63<br>3.5.1　常数张量和变量 64<br>3.5.2　张量运算：用TensorFlow进行数学运算 66<br>3.5.3　重温GradientTape API 66<br>3.5.4　一个端到端的例子：用TensorFlow编写线性分类器 67<br>3.6　神经网络剖析：了解核心Keras API 71<br>3.6.1　层：深度学习的基础模块 71<br>3.6.2　从层到模型 74<br>3.6.3　编译步骤：配置学习过程 75<br>3.6.4　选择损失函数 77<br>3.6.5　理解fit()方法 77<br>3.6.6　监控验证数据上的损失和指标 78<br>3.6.7　推断：在训练后使用模型 79<br>3.7　本章总结 80<br>第4章　神经网络入门：分类与回归 81<br>4.1　影评分类：二分类问题示例 82<br>4.1.1　IMDB 数据集 82<br>4.1.2　准备数据 83<br>4.1.3　构建模型 84<br>4.1.4　验证你的方法 87<br>4.1.5　利用训练好的模型对新数据进行预测 90<br>4.1.6　进一步实验 90<br>4.1.7　小结 90<br>4.2　新闻分类：多分类问题示例 91<br>4.2.1　路透社数据集 91<br>4.2.2　准备数据 92<br>4.2.3　构建模型 92<br>4.2.4　验证你的方法 93<br>4.2.5　对新数据进行预测 96<br>4.2.6　处理标签和损失的另一种方法 96<br>4.2.7　拥有足够大的中间层的重要性 96<br>4.2.8　进一步实验 97<br>4.2.9　小结 97<br>4.3　预测房价：标量回归问题示例 97<br>4.3.1　波士顿房价数据集 98<br>4.3.2　准备数据 98<br>4.3.3　构建模型 99<br>4.3.4　利用K折交叉验证来验证你的方法 99<br>4.3.5　对新数据进行预测 103<br>4.3.6　小结 103<br>4.4　本章总结 104<br>第5章　机器学习基础 105<br>5.1　泛化：机器学习的目标 105<br>5.1.1　欠拟合与过拟合 105<br>5.1.2　深度学习泛化的本质 110<br>5.2　评估机器学习模型 115<br>5.2.1　训练集、验证集和测试集 115<br>5.2.2　超越基于常识的基准 118<br>5.2.3　模型评估的注意事项 119<br>5.3　改进模型拟合 119<br>5.3.1　调节关键的梯度下降参数 119<br>5.3.2　利用更好的架构预设 121<br>5.3.3　提高模型容量 121<br>5.4　提高泛化能力 123<br>5.4.1　数据集管理 123<br>5.4.2　特征工程 124<br>5.4.3　提前终止 125<br>5.4.4　模型正则化 125<br>5.5　本章总结 132<br>第6章　机器学习的通用工作流程 133<br>6.1　定义任务 134<br>6.1.1　定义问题 134<br>6.1.2　收集数据集 135<br>6.1.3　理解数据 138<br>6.1.4　选择衡量成功的指标 139<br>6.2　开发模型 139<br>6.2.1　准备数据 139<br>6.2.2　选择评估方法 140<br>6.2.3　超越基准 141<br>6.2.4　扩大模型规模：开发一个过拟合的模型 142<br>6.2.5　模型正则化与调节超参数 142<br>6.3　部署模型 143<br>6.3.1　向利益相关者解释你的工作并设定预期 143<br>6.3.2　部署推断模型 143<br>6.3.3　监控模型在真实环境中的性能 146<br>6.3.4　维护模型 146<br>6.4　本章总结 147<br>第7章　深入Keras 148<br>7.1　Keras 工作流程 148<br>7.2　构建Keras 模型的不同方法 149<br>7.2.1　序贯模型 149<br>7.2.2　函数式API 152<br>7.2.3　模型子类化 157<br>7.2.4　混合使用不同的组件 159<br>7.2.5　用正确的工具完成工作 160<br>7.3　使用内置的训练循环和评估循环 160<br>7.3.1　编写自定义指标 161<br>7.3.2　使用回调函数 162<br>7.3.3　编写自定义回调函数 164<br>7.3.4　利用TensorBoard进行监控和可视化 165<br>7.4　编写自定义的训练循环和评估循环 167<br>7.4.1　训练与推断 168<br>7.4.2　指标的低阶用法 169<br>7.4.3　完整的训练循环和评估循环 169<br>7.4.4　利用tf.function加快运行速度 171<br>7.4.5　在fit()中使用自定义训练循环 172<br>7.5　本章总结 174<br>第8章　计算机视觉深度学习入门 175<br>8.1　卷积神经网络入门 176<br>8.1.1　卷积运算 178<br>8.1.2　最大汇聚运算 182<br>8.2　在小型数据集上从头开始训练一个卷积神经网络 184<br>8.2.1　深度学习对数据量很小的问题的适用性 184<br>8.2.2　下载数据 185<br>8.2.3　构建模型 . 187<br>8.2.4　数据预处理 189<br>8.2.5　使用数据增强 193<br>8.3　使用预训练模型 196<br>8.3.1　使用预训练模型做特征提取 197<br>8.3.2　微调预训练模型 204<br>8.4　本章总结 208<br>第9章　计算机视觉深度学习进阶 209<br>9.1　三项基本的计算机视觉任务 209<br>9.2　图像分割示例 210<br>9.3　现代卷积神经网络架构模式 218<br>9.3.1　模块化、层次结构和复用 218<br>9.3.2　残差连接 221<br>9.3.3　批量规范化 224<br>9.3.4　深度可分离卷积 226<br>9.3.5　综合示例：一个类似Xception的迷你模型 227<br>9.4　解释卷积神经网络学到的内容 229<br>9.4.1　中间激活值的可视化 230<br>9.4.2　卷积神经网络滤波器的可视化 235<br>9.4.3　类激活热力图的可视化 241<br>9.5　本章总结 246<br>第10章　深度学习处理时间序列 247<br>10.1　不同类型的时间序列任务 247<br>10.2　温度预测示例 248<br>10.2.1　准备数据 251<br>10.2.2　基于常识、不使用机器学习的基准 254<br>10.2.3　基本的机器学习模型 254<br>10.2.4　一维卷积模型 256<br>10.2.5　第一个RNN 基准 258<br>10.3　理解RNN 259<br>10.4　RNN 的高级用法 265<br>10.4.1　利用循环dropout 降低过拟合 265<br>10.4.2　循环层堆叠 268<br>10.4.3　使用双向RNN 269<br>10.4.4　进一步实验 271<br>10.5　本章总结 272<br>第11章　深度学习处理文本 273<br>11.1　自然语言处理概述 273<br>11.2　准备文本数据 274<br>11.2.1　文本标准化 275<br>11.2.2　文本拆分（词元化） 276<br>11.2.3　建立词表索引 277<br>11.2.4　使用TextVectorization层 278<br>11.3　表示单词组的两种方法：集合和序列 282<br>11.3.1　准备IMDB 影评数据 282<br>11.3.2　将单词作为集合处理：词袋方法 284<br>11.3.3　将单词作为序列处理：序列模型方法 289<br>11.4　Transformer架构 298<br>11.4.1　理解自注意力 298<br>11.4.2　多头注意力 302<br>11.4.3　Transformer编码器 303<br>11.4.4　何时使用序列模型而不是词袋模型 309<br>11.5　超越文本分类：序列到序列学习 310<br>11.5.1　机器翻译示例 312<br>11.5.2　RNN 的序列到序列学习 314<br>11.5.3　使用Transformer 进行序列到序列学习 318<br>11.6　本章总结 323<br>第12章　生成式深度学习 324<br>12.1　文本生成 325<br>12.1.1　生成式深度学习用于序列生成的简史 325<br>12.1.2　如何生成序列数据 326<br>12.1.3　采样策略的重要性 327<br>12.1.4　用Keras 实现文本生成 328<br>12.1.5　带有可变温度采样的文本生成回调函数 331<br>12.1.6　小结 334<br>12.2　DeepDream 334<br>12.2.1　用Keras 实现DeepDream 335<br>12.2.2　小结 341<br>12.3　　神经风格迁移 341<br>12.3.1　内容损失 342<br>12.3.2　风格损失 342<br>12.3.3　用Keras 实现神经风格迁移 343<br>12.3.4　小结 348<br>12.4　用变分自编码器生成图像 348<br>12.4.1　从图像潜在空间中采样 348<br>12.4.2　图像编辑的概念向量 350<br>12.4.3　变分自编码器 350<br>12.4.4　用Keras 实现变分自编码器 352<br>12.4.5　小结 357<br>12.5　生成式对抗网络入门 358<br>12.5.1　简要实现流程 359<br>12.5.2　诸多技巧 360<br>12.5.3　CelebA 数据集 360<br>12.5.4　判别器 361<br>12.5.5　生成器 362<br>12.5.6　对抗网络 364<br>12.5.7　小结 366<br>12.6　本章总结 367<br>第13章　适合现实世界的最佳实践 368<br>13.1　将模型性能发挥到极致 368<br>13.1.1　超参数优化 368<br>13.1.2　模型集成 375<br>13.2　加速模型训练 376<br>13.2.1　使用混合精度加快GPU上的训练速度 377<br>13.2.2　多GPU训练 380<br>13.2.3　TPU训练 382<br>13.3　本章总结 384<br>第14章　总结 385<br>14.1　重点概念回顾 385<br>14.1.1　人工智能的多种方法 385<br>14.1.2　深度学习在机器学习领域中的特殊之处 386<br>14.1.3　如何看待深度学习 386<br>14.1.4　关键的推动技术 387<br>14.1.5　机器学习的通用工作流程 388<br>14.1.6　关键网络架构 388<br>14.1.7　可能性空间 392<br>14.2　深度学习的局限性 394<br>14.2.1　将机器学习模型拟人化的风险 394<br>14.2.2　自动机与智能体 396<br>14.2.3　局部泛化与极端泛化 397<br>14.2.4　智能的目的 399<br>14.2.5　逐步提高泛化能力 400<br>14.3　如何实现更加通用的人工智能 401<br>14.3.1　设定正确目标的重要性：捷径法则 401<br>14.3.2　新目标 402<br>14.4　实现智能：缺失的内容 403<br>14.4.1　智能是对抽象类比的敏感性 404<br>14.4.2　两种抽象 405<br>14.4.3　深度学习所缺失的那一半 407<br>14.5　深度学习的未来 408<br>14.5.1　模型即程序 408<br>14.5.2　将深度学习与程序合成融合 409<br>14.5.3　终身学习和模块化子程序复用 411<br>14.5.4　长期愿景 412<br>14.6　了解快速发展的领域的最新进展 413<br>14.6.1　在Kaggle 上练习解决现实世界的问题 413<br>14.6.2　在arXiv上了解最新进展 414<br>14.6.3　探索Keras 生态系统 414<br>14.7　结束语 414</p><h3 id="Python深度学习-PDF-下载"><a href="#Python深度学习-PDF-下载" class="headerlink" title="Python深度学习 PDF 下载"></a>Python深度学习 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1XjcQeZsDM7QF7bBRlWzNuw?pwd=8p9d">https://pan.baidu.com/s/1XjcQeZsDM7QF7bBRlWzNuw?pwd=8p9d</a></p><p>提取码: 8p9d</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《持续交付2.0：业务引领的DevOps精要》</title>
      <link href="/2023/05/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982.0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81/"/>
      <url>/2023/05/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982.0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1a3aea4bb6854e7de11011ef09cecc2b.png" alt="《持续交付2.0：业务引领的DevOps精要》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书重新定义了“持续交付”，增补了组织管理和系统架构两个维度，并辅助以真实案例，对诸多持续交付原则与实践加以解读，并对持续交付过程中的实践取舍之道加以论述。</p><p>本书分三个部分。第一部分作者根据自己近十年的工作及咨询经历，不断总结、提炼和反思，对原有的持续交付进行了修正，重新定义持续交付为实现组织战略目标的能力，并引入持续交付的能力模型；</p><p>第二部分阐述组织打造持续交付能力所需遵守的原则，包括基础原则、组织原则和架构原则；</p><p>第三部分通过多个互联网公司案例的解读，阐述如何根据组织的当前状况，应用原则，并对最佳实践进行取舍，快速达到组织能力目标。</p><p>本书适合大型互联网公司的技术VP、技术负责人，中小型互联网公司的CTO、技术VP、研发&#x2F;测试&#x2F;运维负责人、主管及骨干，以及组织变革者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>乔梁</p><p>敏思特咨询公司联合创始人，持续交付领域专家，著名敏捷与精益转型导师，腾讯外聘高级管理顾问。拥有多年IT从业经验，曾就职于百度、Nokia等国内外知名软件公司，并先后担任多个互联网公司的高级管理顾问，帮助多个产品线取得业务上的成功突破。曾为华为、上汽等非互联网软件企业提供敏捷转型咨询服务，指导解决组织转型与研发管理方面的相关问题。</p><p>乔梁是国内最早致力于通过敏捷开发与精益理论改善软件价值交付效率的实践者之一，精研各种软件工程方法论，2010年翻译《持续交付》一书，并将其融会贯通，成为持续交付和DevOps理念在国内的首批实践者和布道者，经过八年的管理实践，总结提炼，提出持续交付双环模型，并将工作心得整理成册，取名《持续交付2.0》，将关注点前移至业务价值的持续探索与快速验证方法。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　持续交付2.0 1<br>1.1　软件工程发展概述 1<br>1.1.1　瀑布软件开发方法 1<br>1.1.2　敏捷软件开发方法 2<br>1.1.3　DevOps运动 3<br>1.1.4　持续交付1.0 4<br>1.2　持续交付2.0 7<br>1.2.1　精益思想 8<br>1.2.2　双环模型 9<br>1.2.3　4个核心原则 11<br>1.2.4　持续交付七巧板 12<br>1.3　小结 13<br>第2章　价值探索环 14<br>2.1　探索环的意义 14<br>2.2　探索环的4个关键环节 15<br>2.2.1　提问 16<br>2.2.2　锚定 17<br>2.2.3　共创 19<br>2.2.4　精炼 22<br>2.3　工作原则 24<br>2.3.1　分解并快速试错 24<br>2.3.2　一次只验证一点 25<br>2.3.3　允许失败 26<br>2.4　共创与精炼的常用方法 27<br>2.4.1　装饰窗方法 27<br>2.4.2　最小可行特性法 29<br>2.4.3　特区法 30<br>2.4.4　定向探索法 30<br>2.4.5　稻草人法 31<br>2.4.6　最小可行产品法 32<br>2.5　实施注意事项 32<br>2.6　小结 35<br>第3章　快速验证环 36<br>3.1　验证环的目标 36<br>3.2　验证环的4个关键环节 37<br>3.2.1　构建 37<br>3.2.2　运行 38<br>3.2.3　监测 39<br>3.2.4　决策 39<br>3.3　工作原则 39<br>3.3.1　质量内建 39<br>3.3.2　消除等待 40<br>3.3.3　重复事务自动化 43<br>3.3.4　监测一切 43<br>3.4　小结 44<br>第4章　持续交付2.0的组织文化 45<br>4.1　安全、信任与持续改善 45<br>4.1.1　失败是安全的 45<br>4.1.2　相互信任 45<br>4.1.3　持续改善 46<br>4.2　文化塑造四步法 46<br>4.2.1　行为决定文化 46<br>4.2.2　谷歌的工程师质量文化 48<br>4.2.3　Etsy的持续试验文化 49<br>4.3　行动原则 50<br>4.3.1　价值导向 51<br>4.3.2　快速验证 51<br>4.3.3　持续学习 51<br>4.4　度量原则 55<br>4.4.1　度量指标的4类属性 56<br>4.4.2　度量的目标是改善 57<br>4.5　“改善套路”进行持续改进 57<br>4.6　小结 58<br>第5章　持续交付的软件系统架构 60<br>5.1　“大系统小做”原则 61<br>5.1.1　持续交付架构要求 61<br>5.1.2　系统拆分原则 61<br>5.2　常见架构模式 62<br>5.2.1　微核架构 62<br>5.2.2　微服务架构 63<br>5.2.3　巨石应用 64<br>5.3　架构改造实施模式 66<br>5.3.1　拆迁者模式 67<br>5.3.2　绞杀者模式 68<br>5.3.3　修缮者模式 68<br>5.3.4　数据库的拆分方法 70<br>5.4　小结 70<br>第6章　业务需求协作管理 72<br>6.1　产品版本周期概述 73<br>6.1.1　准备期 73<br>6.1.2　交付期 74<br>6.2　需求拆分的利与弊 75<br>6.2.1　需求拆分的收益 76<br>6.2.2　需求拆分的成本 78<br>6.3　需求拆分方法 79<br>6.3.1　需求的来源 80<br>6.3.2　技术债也是需求 80<br>6.3.3　参与需求拆分的角色 81<br>6.3.4　不平等的INVEST原则 82<br>6.3.5　五大拆分技法 82<br>6.3.6　七大组成部分 84<br>6.4　需求分析与管理工具集 85<br>6.4.1　用户故事地图 85<br>6.4.2　用户故事树 86<br>6.4.3　依赖关系图 87<br>6.4.4　需求管理数字化平台 87<br>6.5　团队协作管理工具 87<br>6.5.1　团队共享日历 88<br>6.5.2　团队回顾 89<br>6.5.3　可视化故事墙 90<br>6.5.4　明确“完成”的定义 90<br>6.5.5　持续集成 91<br>6.5.6　故事验证 91<br>6.6　小结 91<br>第7章　部署流水线原则与工具设计 92<br>7.1　简单的部署流水线 92<br>7.1.1　简单的产品研发流程 92<br>7.1.2　初始部署流水线 93<br>7.1.3　流水线执行状态解析 95<br>7.2　部署流水线的设计与使用 95<br>7.2.1　流水线的设计原则 95<br>7.2.2　团队的协作纪律 97<br>7.3　部署流水线平台的构成 97<br>7.3.1　工具链总体架构 97<br>7.3.2　平台应当具备的基本能力 99<br>7.3.3　工具链建设策略 100<br>7.4　基础支撑服务的云化 100<br>7.4.1　基础支撑服务的协作过程解析 101<br>7.4.2　编译构建管理服务 103<br>7.4.3　自动化测试管理服务 104<br>7.4.4　软件部署管理服务 105<br>7.4.5　基础环境管理服务 106<br>7.5　企业制品库的管理 107<br>7.5.1　制品库的分类 107<br>7.5.2　制品库的管理原则 108<br>7.6　多种多样的部署流水线 108<br>7.6.1　多组件的部署流水线 108<br>7.6.2　个人部署流水线 109<br>7.6.3　部署流水线的不断演进 110<br>7.7　为开发者构建自助式工具 111<br>7.8　小结 113<br>第8章　利于集成的分支策略 114<br>8.1　版本控制系统的使用目的 114<br>8.1.1　集中式版本控制系统 114<br>8.1.2　分布式版本控制系统 115<br>8.1.3　版本控制系统中的基本概念 117<br>8.2　常见分支开发模式 118<br>8.2.1　主干开发，主干发布 118<br>8.2.2　主干开发，分支发布 119<br>8.2.3　分支开发，主干发布 121<br>8.3　分支模式的演化 126<br>8.3.1　三驾马车分支模式 126<br>8.3.2　Gitflow分支模式 127<br>8.3.3　GitHubFlow分支模式 128<br>8.4　分支策略的选择 128<br>8.4.1　版本发布模式 128<br>8.4.2　分支策略与发布周期的关系 132<br>8.5　小结 133<br>第9章　持续集成 134<br>9.1　起源与定义 134<br>9.1.1　原始定义 135<br>9.1.2　一次集成过程 135<br>9.2　六步提交法 136<br>9.2.1　4个关键点 138<br>9.2.2　同步与异步模式 139<br>9.2.3　自查表 140<br>9.3　速度与质量的权衡 141<br>9.3.1　分级构建 142<br>9.3.2　多人同时提交的构建 142<br>9.3.3　云平台的威力 143<br>9.4　在团队中实施持续集成实践 145<br>9.4.1　快速建立团队的持续集成实践 146<br>9.4.2　分支策略与部署流水线 148<br>9.5　常见的实施问题 150<br>9.5.1　工程师的开发习惯 151<br>9.5.2　视而不见的扫描问题 151<br>9.5.3　自动化测试用例的缺乏 151<br>9.6　小结 152<br>第10章　自动化测试策略与方法 153<br>10.1　自动化测试的自身定位 153<br>10.1.1　自动化测试的优势 154<br>10.1.2　自动化测试所需的投入 155<br>10.2　突破传统自动化测试的困境 156<br>10.2.1　传统自动化测试的特点 157<br>10.2.2　自动化测试的分层 157<br>10.2.3　不同类型的测试金字塔 160<br>10.3　自动化测试的实施策略 163<br>10.3.1　增加自动化测试用例的着手点 163<br>10.3.2　提高自动化测试的执行次数 164<br>10.3.3　良好自动化测试的特征 165<br>10.3.4　共享自动化测试的维护职责 166<br>10.3.5　代码测试覆盖率 167<br>10.4　用户验收自动化测试要点 168<br>10.4.1　先搭建分层框架 168<br>10.4.2　测试用例数应保持低位 171<br>10.4.3　为自动化测试用例预留API 171<br>10.4.4　为调试做好准备 171<br>10.4.5　测试数据的准备 171<br>10.5　其他质量检查方法 173<br>10.5.1　差异批注测试方法 173<br>10.5.2　代码规范检查与代码动静态检测 174<br>10.5.3　AI在测试领域的应用 174<br>10.6　小结 175<br>第11章　软件配置管理 176<br>11.1　将一切纳入配置管理 176<br>11.1.1　配置管理目标 176<br>11.1.2　配置管理的范围 177<br>11.1.3　软件配置管理原则 177<br>11.2　软件包的版本管理 181<br>11.2.1　包管理的反模式 181<br>11.2.2　集中式包管理服务 182<br>11.2.3　软件包的元信息 183<br>11.3　包依赖管理 185<br>11.3.1　显式声明依赖 185<br>11.3.2　自动管理依赖 187<br>11.3.3　减少复杂依赖 188<br>11.4　环境基础设施管理 191<br>11.4.1　环境准备的4种状态 191<br>11.4.2　领域专属语言的应用 197<br>11.4.3　环境基础设施即代码 198<br>11.5　软件配置项的管理 199<br>11.5.1　二进制与配置项的分离 199<br>11.5.2　配置信息的版本管理 200<br>11.5.3　配置项的存储组织方式 201<br>11.5.4　配置漂移与治理 202<br>11.6　不可变基础设施与云应用 203<br>11.6.1　实现不可变基础设施 203<br>11.6.2　云原生应用 206<br>11.6.3　优势与挑战 206<br>11.7　数据的版本管理 208<br>11.7.1　数据库结构变更 208<br>11.7.2　数据文件 208<br>11.8　需求与源代码的版本关联 209<br>11.9　小结 209<br>第12章　低风险发布 211<br>12.1　高频发布是一种趋势 211<br>12.1.1　互联网企业的高频发布 212<br>12.1.2　收益与成本共存 214<br>12.2　降低发布风险的方法 215<br>12.2.1　蓝绿部署 215<br>12.2.2　滚动部署 216<br>12.2.3　金丝雀发布与灰度发布 217<br>12.2.4　暗部署 218<br>12.3　高频发布支撑技术 219<br>12.3.1　功能开关技术 220<br>12.3.2　数据迁移技术 222<br>12.3.3　抽象分支方法 225<br>12.3.4　升级替代回滚 226<br>12.4　影响发布频率的因素 227<br>12.5　小结 228<br>第13章　监测与决策 229<br>13.1　生产监测范围 230<br>13.1.1　后台服务的监测 230<br>13.1.2　分发软件的监测 230<br>13.2　数据监测体系 231<br>13.2.1　收集与处理 231<br>13.2.2　数据的标准化 232<br>13.2.3　监测数据体系及其能力衡量 233<br>13.3　问题处理体系 235<br>13.3.1　告警海洋与智能化管理 235<br>13.3.2　问题处理是一个学习过程 236<br>13.4　生产环境测试 237<br>13.4.1　测试活动扁平化趋势 237<br>13.4.2　生产环境中的测试 239<br>13.4.3　混沌工程 239<br>13.5　向东，还是向西 240<br>13.6　小结 241<br>第14章　大型互联网团队的FT化 242<br>14.1　简介 242<br>14.1.1　改进前状态 243<br>14.1.2　改进后状态 244<br>14.2　改进方法论 245<br>14.2.1　指导思想 245<br>14.2.2　改进步骤 245<br>14.3　改进的历程 246<br>14.3.1　架构解耦 246<br>14.3.2　组织解耦 248<br>14.3.3　研发流程再造 250<br>14.3.4　自动化一切 259<br>14.4　小结 260<br>第15章　小团队逆袭之旅 262<br>15.1　背景简介 262<br>15.1.1　改进前的“死亡行军”之旅 264<br>15.1.2　改进后的无缺陷交付 264<br>15.2　改进方法论 265<br>15.2.1　指导思想 265<br>15.2.2　试点团队的选择 265<br>15.3　第一阶段：研发准备期 266<br>15.3.1　功能简介与需求拆分 266<br>15.3.2　架构设计与需求依赖识别 267<br>15.3.3　工作量估算与排期 268<br>15.4　第二阶段：软件交付期 270<br>15.4.1　通过可视化看板改进工作流程 270<br>15.4.2　无缺陷交付 277<br>15.4.3　主干开发与持续集成 278<br>15.4.4　测试活动左移 279<br>15.4.5　代码评审 279<br>15.4.6　关注结果，更要关注过程 280<br>15.5　小结 281<br>第16章　研发推动的DevOps 283<br>16.1　改进的关键点 285<br>16.1.1　改进方法论 285<br>16.1.2　定义改进目标 285<br>16.2　第一阶段：敏捷101 287<br>16.2.1　做个靠谱的计划 287<br>16.2.2　开发阶段启航 291<br>16.2.3　对过程质量的约束 294<br>16.2.4　阶段性改进点 301<br>16.3　第二阶段：DevOps转型 302<br>16.3.1　与运维人员的“冲突” 303<br>16.3.2　高频部署发布中的具体障碍 304<br>16.3.3　整体解决方案的设计 304<br>16.3.4　DevOps阶段的团队改变 308<br>16.4　小结 308<br>附录A　软件工程的三次进化 310<br>附录B　排序法做相对估算 323</p><h3 id="持续交付2-0：业务引领的DevOps精要-PDF-下载"><a href="#持续交付2-0：业务引领的DevOps精要-PDF-下载" class="headerlink" title="持续交付2.0：业务引领的DevOps精要 PDF 下载"></a>持续交付2.0：业务引领的DevOps精要 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1U2alK_9N-AnB5pI-Kt9hZA?pwd=viff">https://pan.baidu.com/s/1U2alK_9N-AnB5pI-Kt9hZA?pwd=viff</a> </p><p>提取码：viff</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> 持续交付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Java虚拟机（第3版）》</title>
      <link href="/2023/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(%E7%AC%AC3%E7%89%88)/"/>
      <url>/2023/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(%E7%AC%AC3%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/e0e32b23ce83f43911565b8216a4c7e7.png" alt="《深入理解Java虚拟机（第3版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>这是一部从工作原理和工程实践两个维度深入剖析JVM的著作，是计算机领域公认的经典，繁体版在台湾也颇受欢迎。</p><p>自2011年上市以来，前两个版本累计印刷36次，销量超过30万册，两家主要网络书店的评论近90000条，内容上近乎零差评，是原创计算机图书领域不可逾越的丰碑。</p><p>第3版在第2版的基础上做了重大修订，内容更丰富、实战性更强：根据新版JDK对内容进行了全方位的修订和升级，围绕新技术和生产实践新增逾10万字，包含近50%的全新内容，并对第2版中含糊、瑕疵和错误内容进行了修正。</p><p>全书一共13章，分为五大部分：</p><p>第一部分（第1章）走近Java</p><p>系统介绍了Java的技术体系、发展历程、虚拟机家族，以及动手编译JDK，了解这部分内容能对学习JVM提供良好的指引。</p><p>第二部分（第2~5章）自动内存管理</p><p>详细讲解了Java的内存区域与内存溢出、垃圾收集器与内存分配策略、虚拟机性能监控与故障排除等与自动内存管理相关的内容，以及10余个经典的性能优化案例和优化方法；</p><p>第三部分（第6~9章）虚拟机执行子系统</p><p>深入分析了虚拟机执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎，以及多个类加载及其执行子系统的实战案例；</p><p>第四部分（第10~11章）程序编译与代码优化</p><p>详细讲解了程序的前、后端编译与优化，包括前端的易用性优化措施，如泛型、主动装箱拆箱、条件编译等的内容的深入分析；以及后端的性能优化措施，如虚拟机的热点探测方法、HotSpot 的即时编译器、提前编译器，以及各种常见的编译期优化技术；</p><p>第五部分（第12~13章）高效并发</p><p>主要讲解了Java实现高并发的原理，包括Java的内存模型、线程与协程，以及线程安全和锁优化。</p><p>全书以实战为导向，通过大量与实际生产环境相结合的案例分析和展示了解决各种Java技术难题的方案和技巧。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>资深Java技术、机器学习和企业级开发技术专家，现任远光软件研究院院长，人工智能博士在读，著有知名畅销书《深入理解Java虚拟机：JVM高级特性与最佳实践》。</p><p>开源技术的积极倡导者和推动者，对计算机科学和相关的多个领域都有深刻的见解，尤其是人工智能、Java开发和敏捷开发等领域。曾受邀在InfoQ和IBM DeveloperWorks等网站撰写技术专栏。</p><p>著作颇丰，著有《深入理解Java虚拟机》《深入理解OSGi》，翻译了《Java虚拟机规范》等著作。其中《深入理解Java虚拟机》第1版出版于2011年，已经出至第2版，不仅销量好，而且口碑更好，累计印刷超过30次，仍长销不衰，是中文计算机图书领域公认的、难得一见的佳作。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　走近Java<br>第1章　走近Java 2<br>1.1　概述 2<br>1.2　Java技术体系 3<br>1.3　Java发展史 4<br>1.4　Java虚拟机家族 12<br>1.4.1　虚拟机始祖：Sun Classic&#x2F;Exact VM 12<br>1.4.2　武林盟主：HotSpot VM 13<br>1.4.3　小家碧玉：Mobile&#x2F;Embedded VM 14<br>1.4.4　天下第二：BEA JRockit&#x2F;IBM J9 VM 15<br>1.4.5　软硬合璧：BEA Liquid VM&#x2F;Azul VM 16<br>1.4.6　挑战者：Apache Harmony&#x2F;Google Android Dalvik VM 17<br>1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18<br>1.4.8　百家争鸣 19<br>1.5　展望Java技术的未来 21<br>1.5.1　无语言倾向 21<br>1.5.2　新一代即时编译器 23<br>1.5.3　向Native迈进 24<br>1.5.4　灵活的胖子 26<br>1.5.5　语言语法持续增强 27<br>1.6　实战：自己编译JDK 29<br>1.6.1　获取源码 29<br>1.6.2　系统需求 31<br>1.6.3　构建编译环境 33<br>1.6.4　进行编译 34<br>1.6.5　在IDE工具中进行源码调试 36<br>1.7　本章小结 39<br>第二部分　自动内存管理<br>第2章　Java内存区域与内存溢出异常 42<br>2.1　概述 42<br>2.2　运行时数据区域 42<br>2.2.1　程序计数器 43<br>2.2.2　Java虚拟机栈 43<br>2.2.3　本地方法栈 44<br>2.2.4　Java堆 44<br>2.2.5　方法区 46<br>2.2.6　运行时常量池 47<br>2.2.7　直接内存 47<br>2.3　HotSpot虚拟机对象探秘 48<br>2.3.1　对象的创建 48<br>2.3.2　对象的内存布局 51<br>2.3.3　对象的访问定位 52<br>2.4　实战：OutOfMemoryError异常 53<br>2.4.1　Java堆溢出 54<br>2.4.2　虚拟机栈和本地方法栈溢出 56<br>2.4.3　方法区和运行时常量池溢出 61<br>2.4.4　本机直接内存溢出 65<br>2.5　本章小结 66<br>第3章　垃圾收集器与内存分配策略 67<br>3.1　概述 67<br>3.2　对象已死？ 68<br>3.2.1　引用计数算法 68<br>3.2.2　可达性分析算法 70<br>3.2.3　再谈引用 71<br>3.2.4　生存还是死亡？ 72<br>3.2.5　回收方法区 74<br>3.3　垃圾收集算法 75<br>3.3.1　分代收集理论 75<br>3.3.2　标记-清除算法 77<br>3.3.3　标记-复制算法 78<br>3.3.4　标记-整理算法 79<br>3.4　HotSpot的算法细节实现 81<br>3.4.1　根节点枚举 81<br>3.4.2　安全点 82<br>3.4.3　安全区域 83<br>3.4.4　记忆集与卡表 84<br>3.4.5　写屏障 85<br>3.4.6　并发的可达性分析 87<br>3.5　经典垃圾收集器 89<br>3.5.1　Serial收集器 90<br>3.5.2　ParNew收集器 92<br>3.5.3　Parallel Scavenge收集器 93<br>3.5.4　Serial Old收集器 94<br>3.5.5　Parallel Old收集器 95<br>3.5.6　CMS收集器 96<br>3.5.7　Garbage First收集器 98<br>3.6　低延迟垃圾收集器 104<br>3.6.1　Shenandoah收集器 105<br>3.6.2　ZGC收集器 112<br>3.7　选择合适的垃圾收集器 121<br>3.7.1　Epsilon收集器 121<br>3.7.2　收集器的权衡 121<br>3.7.3　虚拟机及垃圾收集器日志 122<br>3.7.4　垃圾收集器参数总结 127<br>3.8　实战：内存分配与回收策略 129<br>3.8.1　对象优先在Eden分配 130<br>3.8.2　大对象直接进入老年代 131<br>3.8.3　长期存活的对象将进入老年代 132<br>3.8.4　动态对象年龄判定 134<br>3.8.5　空间分配担保 135<br>3.9　本章小结 137<br>第4章　虚拟机性能监控、故障处理工具 138<br>4.1　概述 138<br>4.2　基础故障处理工具 138<br>4.2.1　jps：虚拟机进程状况工具 141<br>4.2.2　jstat：虚拟机统计信息监视工具 142<br>4.2.3　jinfo：Java配置信息工具 143<br>4.2.4　jmap：Java内存映像工具 144<br>4.2.5　jhat：虚拟机堆转储快照分析工具 145<br>4.2.6　jstack：Java堆栈跟踪工具 146<br>4.2.7　基础工具总结 148<br>4.3　可视化故障处理工具 151<br>4.3.1　JHSDB：基于服务性代理的调试工具 152<br>4.3.2　JConsole：Java监视与管理控制台 157<br>4.3.3　VisualVM：多合-故障处理工具 164<br>4.3.4　Java Mission Control：可持续在线的监控工具 171<br>4.4　HotSpot虚拟机插件及工具 175<br>4.5　本章小结 180<br>第5章　调优案例分析与实战 181<br>5.1　概述 181<br>5.2　案例分析 181<br>5.2.1　大内存硬件上的程序部署策略 182<br>5.2.2　集群间同步导致的内存溢出 184<br>5.2.3　堆外内存导致的溢出错误 185<br>5.2.4　外部命令导致系统缓慢 187<br>5.2.5　服务器虚拟机进程崩溃 187<br>5.2.6　不恰当数据结构导致内存占用过大 188<br>5.2.7　由Windows虚拟内存导致的长时间停顿 189<br>5.2.8　由安全点导致长时间停顿 190<br>5.3　实战：Eclipse运行速度调优 192<br>5.3.1　调优前的程序运行状态 193<br>5.3.2　升级JDK版本的性能变化及兼容问题 196<br>5.3.3　编译时间和类加载时间的优化 200<br>5.3.4　调整内存设置控制垃圾收集频率 203<br>5.3.5　选择收集器降低延迟 206<br>5.4　本章小结 209<br>第三部分　虚拟机执行子系统<br>第6章　类文件结构 212<br>6.1　概述 212<br>6.2　无关性的基石 212<br>6.3　Class类文件的结构 214<br>6.3.1　魔数与Class文件的版本 215<br>6.3.2　常量池 218<br>6.3.3　访问标志 224<br>6.3.4　类索引、父类索引与接口索引集合 225<br>6.3.5　字段表集合 226<br>6.3.6　方法表集合 229<br>6.3.7　属性表集合 230<br>6.4　字节码指令简介 251<br>6.4.1　字节码与数据类型 251<br>6.4.2　加载和存储指令 253<br>6.4.3　运算指令 254<br>6.4.4　类型转换指令 255<br>6.4.5　对象创建与访问指令 256<br>6.4.6　操作数栈管理指令 256<br>6.4.7　控制转移指令 257<br>6.4.8　方法调用和返回指令 257<br>6.4.9　异常处理指令 258<br>6.4.10　同步指令 258<br>6.5　公有设计，私有实现 259<br>6.6　Class文件结构的发展 260<br>6.7　本章小结 261<br>第7章　虚拟机类加载机制 262<br>7.1　概述 262<br>7.2　类加载的时机 263<br>7.3　类加载的过程 267<br>7.3.1　加载 267<br>7.3.2　验证 268<br>7.3.3　准备 271<br>7.3.4　解析 272<br>7.3.5　初始化 277<br>7.4　类加载器 279<br>7.4.1　类与类加载器 280<br>7.4.2　双亲委派模型 281<br>7.4.3　破坏双亲委派模型 285<br>7.5　Java模块化系统 287<br>7.5.1　模块的兼容性 288<br>7.5.2　模块化下的类加载器 290<br>7.6　本章小结 292<br>第8章　虚拟机字节码执行引擎 293<br>8.1　概述 293<br>8.2　运行时栈帧结构 294<br>8.2.1　局部变量表 294<br>8.2.2　操作数栈 299<br>8.2.3　动态连接 300<br>8.2.4　方法返回地址 300<br>8.2.5　附加信息 301<br>8.3　方法调用 301<br>8.3.1　解析 301<br>8.3.2　分派 303<br>8.4　动态类型语言支持 315<br>8.4.1　动态类型语言 316<br>8.4.2　Java与动态类型 317<br>8.4.3　java.lang.invoke包 318<br>8.4.4　invokedynamic指令 321<br>8.4.5　实战：掌控方法分派规则 324<br>8.5　基于栈的字节码解释执行引擎 326<br>8.5.1　解释执行 327<br>8.5.2　基于栈的指令集与基于寄存器的指令集 328<br>8.5.3　基于栈的解释器执行过程 329<br>8.6　本章小结 334<br>第9章　类加载及执行子系统的案例与实战 335<br>9.1　概述 335<br>9.2　案例分析 335<br>9.2.1　Tomcat：正统的类加载器架构 335<br>9.2.2　OSGi：灵活的类加载器架构 338<br>9.2.3　字节码生成技术与动态代理的实现 341<br>9.2.4　Backport工具：Java的时光机器 345<br>9.3　实战：自己动手实现远程执行功能 348<br>9.3.1　目标 348<br>9.3.2　思路 349<br>9.3.3　实现 350<br>9.3.4　验证 355<br>9.4　本章小结 356<br>第四部分　程序编译与代码优化<br>第10章　前端编译与优化 358<br>10.1　概述 358<br>10.2　Javac编译器 359<br>10.2.1　Javac的源码与调试 359<br>10.2.2　解析与填充符号表 362<br>10.2.3　注解处理器 363<br>10.2.4　语义分析与字节码生成 364<br>10.3　Java语法糖的味道 367<br>10.3.1　泛型 367<br>10.3.2　自动装箱、拆箱与遍历循环 375<br>10.3.3　条件编译 377<br>10.4　实战：插入式注解处理器 378<br>10.4.1　实战目标 379<br>10.4.2　代码实现 379<br>10.4.3　运行与测试 385<br>10.4.4　其他应用案例 386<br>10.5　本章小结 386<br>第11章　后端编译与优化 388<br>11.1　概述 388<br>11.2　即时编译器 389<br>11.2.1　解释器与编译器 389<br>11.2.2　编译对象与触发条件 392<br>11.2.3　编译过程 397<br>11.2.4　实战：查看及分析即时编译结果 398<br>11.3　提前编译器 404<br>11.3.1　提前编译的优劣得失 405<br>11.3.2　实战：Jaotc的提前编译 408<br>11.4　编译器优化技术 411<br>11.4.1　优化技术概览 411<br>11.4.2　方法内联 415<br>11.4.3　逃逸分析 417<br>11.4.4　公共子表达式消除 420<br>11.4.5　数组边界检查消除 421<br>11.5　实战：深入理解Graal编译器 423<br>11.5.1　历史背景 423<br>11.5.2　构建编译调试环境 424<br>11.5.3　JVMCI编译器接口 426<br>11.5.4　代码中间表示 429<br>11.5.5　代码优化与生成 432<br>11.6　本章小结 436<br>第五部分　高效并发<br>第12章　Java内存模型与线程 438<br>12.1　概述 438<br>12.2　硬件的效率与一致性 439<br>12.3　Java内存模型 440<br>12.3.1　主内存与工作内存 441<br>12.3.2　内存间交互操作 442<br>12.3.3　对于volatile型变量的特殊规则 444<br>12.3.4　针对long和double型变量的特殊规则 450<br>12.3.5　原子性、可见性与有序性 450<br>12.3.6　先行发生原则 452<br>12.4　Java与线程 455<br>12.4.1　线程的实现 455<br>12.4.2　Java线程调度 458<br>12.4.3　状态转换 460<br>12.5　Java与协程 461<br>12.5.1　内核线程的局限 461<br>12.5.2　协程的复苏 462<br>12.5.3　Java的解决方案 464<br>12.6　本章小结 465<br>第13章　线程安全与锁优化 466<br>13.1　概述 466<br>13.2　线程安全 466<br>13.2.1　Java语言中的线程安全 467<br>13.2.2　线程安全的实现方法 471<br>13.3　锁优化 479<br>13.3.1　自旋锁与自适应自旋 479<br>13.3.2　锁消除 480<br>13.3.3　锁粗化 481<br>13.3.4　轻量级锁 481<br>13.3.5　偏向锁 483<br>13.4　本章小结 485<br>附录A　在Windows系统下编译OpenJDK 6 486<br>附录B　展望Java技术的未来（2013年版） 493<br>附录C　虚拟机字节码指令表 499<br>附录D　对象查询语言（OQL）简介 506<br>附录E　JDK历史版本轨迹 512</p><h3 id="深入理解Java虚拟机（第3版）-PDF-下载"><a href="#深入理解Java虚拟机（第3版）-PDF-下载" class="headerlink" title="深入理解Java虚拟机（第3版） PDF 下载"></a>深入理解Java虚拟机（第3版） PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1516g8be4qA8OxZFXxA60Bw?pwd=zn83">https://pan.baidu.com/s/1516g8be4qA8OxZFXxA60Bw?pwd=zn83</a> </p><p>提取码：zn83</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习入门：基于Python的理论与实现》</title>
      <link href="/2023/05/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/05/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/QGDBW3TF02QM72D625UDAUEN26GTDMA8.png" alt="《深度学习入门：基于Python的理论与实现》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是深度学习真正意义上的入门书，深入浅出地剖析了深度学习的原理和相关技术。书中使用Python3，尽量不依赖外部库或工具，从基本的数学知识出发，带领读者从零创建一个经典的深度学习网络，使读者在此过程中逐步理解深度学习。书中不仅介绍了深度学习和神经网络的概念、特征等基础知识，对误差反向传播法、卷积神经网络等也有深入讲解，此外还介绍了深度学习相关的实用技巧，自动驾驶、图像生成、强化学习等方面的应用，以及为什么加深层可以提高识别精度等“为什么”的问题。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>作者简介：</p><p>斋藤康毅</p><p>东京工业大学毕业，并完成东京大学研究生院课程。现从事计算机视觉与机器学习相关的研究和开发工作。是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。</p><p>译者简介：</p><p>陆宇杰</p><p>众安科技NLP算法工程师。主要研究方向为自然语言处理及其应用，对图像识别、机器学习、深度学习等领域有密切关注。Python爱好者。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　Python入门　　1<br>1.1 Python是什么　　1<br>1.2 Python的安装　　2<br>1.2.1　Python版本　　2<br>1.2.2　使用的外部库　　2<br>1.2.3　Anaconda发行版　　3<br>1.3 Python解释器　　4<br>1.3.1　算术计算　　4<br>1.3.2　数据类型　　5<br>1.3.3　变量　　5<br>1.3.4　列表　　6<br>1.3.5　字典　　7<br>1.3.6　布尔型　　7<br>1.3.7　if 语句　　8<br>1.3.8　for 语句　　8<br>1.3.9　函数　　9<br>1.4 Python脚本文件　　9<br>1.4.1　保存为文件　　9<br>1.4.2　类　　10<br>1.5 NumPy　　11<br>1.5.1　导入NumPy　　11<br>1.5.2　生成NumPy数组　　12<br>1.5.3　NumPy 的算术运算　　12<br>1.5.4　NumPy的N维数组　　13<br>1.5.5　广播　　14<br>1.5.6　访问元素　　15<br>1.6 Matplotlib　　16<br>1.6.1　绘制简单图形　　16<br>1.6.2　pyplot 的功能　　17<br>1.6.3　显示图像　　18<br>1.7 小结　　19<br>第2章　感知机　　21<br>2.1 感知机是什么　　21<br>2.2 简单逻辑电路　　23<br>2.2.1　与门　　23<br>2.2.2　与非门和或门　　23<br>2.3 感知机的实现　　25<br>2.3.1　简单的实现　　25<br>2.3.2　导入权重和偏置　　26<br>2.3.3　使用权重和偏置的实现　　26<br>2.4 感知机的局限性　　28<br>2.4.1　异或门　　28<br>2.4.2　线性和非线性　　30<br>2.5 多层感知机　　31<br>2.5.1　已有门电路的组合　　31<br>2.5.2　异或门的实现　　33<br>2.6 从与非门到计算机　　35<br>2.7 小结　　36<br>第3章　神经网络　　37<br>3.1 从感知机到神经网络　　37<br>3.1.1　神经网络的例子　　37<br>3.1.2　复习感知机　　38<br>3.1.3　激活函数登场　　40<br>3.2 激活函数　　42<br>3.2.1　sigmoid 函数　　42<br>3.2.2　阶跃函数的实现　　43<br>3.2.3　阶跃函数的图形　　44<br>3.2.4　sigmoid 函数的实现　　45<br>3.2.5　sigmoid 函数和阶跃函数的比较　　46<br>3.2.6　非线性函数　　48<br>3.2.7　ReLU函数　　49<br>3.3 多维数组的运算　　50<br>3.3.1　多维数组　　50<br>3.3.2　矩阵乘法　　51<br>3.3.3　神经网络的内积　　55<br>3.4　　3 层神经网络的实现　　56<br>3.4.1　符号确认　　57<br>3.4.2　各层间信号传递的实现　　58<br>3.4.3　代码实现小结　　62<br>3.5 输出层的设计　　63<br>3.5.1　恒等函数和softmax 函数　　64<br>3.5.2　实现softmax 函数时的注意事项　　66<br>3.5.3　softmax 函数的特征　　67<br>3.5.4　输出层的神经元数量　　68<br>3.6 手写数字识别　　69<br>3.6.1　MNIST数据集　　70<br>3.6.2　神经网络的推理处理　　73<br>3.6.3　批处理　　75<br>3.7 小结　　79<br>第4章　神经网络的学习　　81<br>4.1 从数据中学习　　81<br>4.1.1　数据驱动　　82<br>4.1.2　训练数据和测试数据　　84<br>4.2 损失函数　　85<br>4.2.1　均方误差　　85<br>4.2.2　交叉熵误差　　87<br>4.2.3　mini-batch 学习　　88<br>4.2.4　mini-batch 版交叉熵误差的实现　　91<br>4.2.5　为何要设定损失函数　　92<br>4.3 数值微分　　94<br>4.3.1　导数　　94<br>4.3.2　数值微分的例子　　96<br>4.3.3　偏导数　　98<br>4.4 梯度　　100<br>4.4.1　梯度法　　102<br>4.4.2　神经网络的梯度　　106<br>4.5 学习算法的实现　　109<br>4.5.1　2 层神经网络的类　　110<br>4.5.2　mini-batch 的实现　　114<br>4.5.3　基于测试数据的评价　　116<br>4.6 小结　　118<br>第5章　误差反向传播法　　121<br>5.1 计算图　　121<br>5.1.1　用计算图求解　　122<br>5.1.2　局部计算　　124<br>5.1.3　为何用计算图解题　　125<br>5.2 链式法则　　126<br>5.2.1　计算图的反向传播　　127<br>5.2.2　什么是链式法则　　127<br>5.2.3　链式法则和计算图　　129<br>5.3 反向传播　　130<br>5.3.1　加法节点的反向传播　　130<br>5.3.2　乘法节点的反向传播　　132<br>5.3.3　苹果的例子　　133<br>5.4 简单层的实现　　135<br>5.4.1　乘法层的实现　　135<br>5.4.2　加法层的实现　　137<br>5.5 激活函数层的实现　　139<br>5.5.1　ReLU层　　139<br>5.5.2　Sigmoid 层　　141<br>5.6 AffineSoftmax层的实现　　144<br>5.6.1　Affine层　　144<br>5.6.2　批版本的Affine层　　148<br>5.6.3　Softmax-with-Loss 层　　150<br>5.7 误差反向传播法的实现　　154<br>5.7.1　神经网络学习的全貌图　　154<br>5.7.2　对应误差反向传播法的神经网络的实现　　155<br>5.7.3　误差反向传播法的梯度确认　　158<br>5.7.4　使用误差反向传播法的学习　　159<br>5.8 小结　　161<br>第6章　与学习相关的技巧　　163<br>6.1 参数的更新　　163<br>6.1.1　探险家的故事　　164<br>6.1.2　SGD　　164<br>6.1.3　SGD的缺点　　166<br>6.1.4　Momentum　　168<br>6.1.5　AdaGrad　　170<br>6.1.6　Adam　　172<br>6.1.7　使用哪种更新方法呢　　174<br>6.1.8　基于MNIST数据集的更新方法的比较　　175<br>6.2 权重的初始值　　176<br>6.2.1　可以将权重初始值设为0 吗　　176<br>6.2.2　隐藏层的激活值的分布　　177<br>6.2.3　ReLU的权重初始值　　181<br>6.2.4　基于MNIST数据集的权重初始值的比较　　183<br>6.3 Batch Normalization　　184<br>6.3.1　Batch Normalization 的算法　　184<br>6.3.2　Batch Normalization 的评估　　186<br>6.4 正则化　　188<br>6.4.1　过拟合　　189<br>6.4.2　权值衰减　　191<br>6.4.3　Dropout　　192<br>6.5 超参数的验证　　195<br>6.5.1　验证数据　　195<br>6.5.2　超参数的最优化　　196<br>6.5.3　超参数最优化的实现　　198<br>6.6 小结　　200<br>第7章　卷积神经网络　　201<br>7.1 整体结构　　201<br>7.2 卷积层　　202<br>7.2.1　全连接层存在的问题　　203<br>7.2.2　卷积运算　　203<br>7.2.3　填充　　206<br>7.2.4　步幅　　207<br>7.2.5　3 维数据的卷积运算　　209<br>7.2.6　结合方块思考　　211<br>7.2.7　批处理　　213<br>7.3 池化层　　214<br>7.4 卷积层和池化层的实现　　216<br>7.4.1　4 维数组　　216<br>7.4.2　基于im2col 的展开　　217<br>7.4.3　卷积层的实现　　219<br>7.4.4　池化层的实现　　222<br>7.5 CNN的实现　　224<br>7.6 CNN的可视化　　228<br>7.6.1　第1 层权重的可视化　　228<br>7.6.2　基于分层结构的信息提取　　230<br>7.7 具有代表性的CNN　　231<br>7.7.1　LeNet　　231<br>7.7.2　AlexNet　　232<br>7.8 小结　　233<br>第8章　深度学习　　235<br>8.1 加深网络　　235<br>8.1.1　向更深的网络出发　　235<br>8.1.2　进一步提高识别精度　　238<br>8.1.3　加深层的动机　　240<br>8.2 深度学习的小历史　　242<br>8.2.1　ImageNet　　243<br>8.2.2　VGG　　244<br>8.2.3　GoogLeNet　　245<br>8.2.4　ResNet　　246<br>8.3 深度学习的高速化　　248<br>8.3.1　需要努力解决的问题　　248<br>8.3.2　基于GPU的高速化　　249<br>8.3.3　分布式学习　　250<br>8.3.4　运算精度的位数缩减　　252<br>8.4 深度学习的应用案例　　253<br>8.4.1　物体检测　　253<br>8.4.2　图像分割　　255<br>8.4.3　图像标题的生成　　256<br>8.5 深度学习的未来　　258<br>8.5.1　图像风格变换　　258<br>8.5.2　图像的生成　　259<br>8.5.3　自动驾驶　　261<br>8.5.4　Deep Q-Network（强化学习）　　262<br>8.6 小结　　264<br>附录A　Softmax-with-Loss 层的计算图　　267<br>A.1 正向传播　　268<br>A.2 反向传播　　270<br>A.3 小结　　277<br>参考文献　　279</p><h3 id="深度学习入门：基于Python的理论与实现-PDF-下载"><a href="#深度学习入门：基于Python的理论与实现-PDF-下载" class="headerlink" title="深度学习入门：基于Python的理论与实现 PDF 下载"></a>深度学习入门：基于Python的理论与实现 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1B2DuBSu97N5ko2PRXd5Tag?pwd=dkex">https://pan.baidu.com/s/1B2DuBSu97N5ko2PRXd5Tag?pwd=dkex</a> </p><p>提取码: dkex </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Jenkins 2权威指南》</title>
      <link href="/2023/05/19/Jenkins%202%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/19/Jenkins%202%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/DCC8A35F0B25E6C033260746B89DAF45.png" alt="《Jenkins 2权威指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>设计、实现并且执行具有一定灵活性、可控性以及易于维护性的持续交付流水线，对于以前版本的Jenkins来说是不可能实现的。通过这本实用的书籍，构建管理人员、开发人员、测试人员以及其他专业人员将会学到如何利用Jenkins 2的新特性来定义流水线即代码、集成其他关键技术，以及创建自动化的、可靠的流水线，以便简化和加速DevOps环境的建设。</p><p>作者Brent Laster向你展示了Jenkins 2与这个流行的开源自动化平台基于Web的传统版本有着很大的不同。如果你熟悉Jenkins并且想利用这些新技术来改造老旧流水线或者构建现代的自动化持续交付环境，那么这本书适合你。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>郝树伟</p><p>《Jenkins权威指南》第一译者，阿里云高级研发工程师，主要负责开源集成和DevOps相关产品的研发，在CI&#x2F;CD领域有丰富经验，在Jenkins开源社区与相关书籍翻译、汉化方面有较多贡献和经验。</p><p>石雪峰</p><p>Jenkins全球推广大使、Certified Jenkins Engineer、Jenkins中文社区核心成员、Jenkins的狂热爱好者。目前就职于京东商城前台工程效率团队，负责公司级持续交付和DevOps平台体系建设。</p><p>雷涛</p><p>Jenkins全球推广大使、Certified Jenkins Engineer、DevOps标准核心编写专家。目前就职于百度工程效率部，曾先后就职于新浪网、摩托罗拉、诺基亚、爱立信、乐视致新等国内外知名企业，专注于互联网、电信、金融、无人驾驶汽车等行业的软件工程效率提升，DevOps解决方案，持续交付，ASPICE&#x2F;ISO 26262研发过程落地等领域。</p><p>李华强</p><p>乐融致新高级配置经理，软件配置管理（SCM）领域的一名老兵，先后就职于北电网络、爱立信、飞维美地、乐视、乐融等多家企业，从事与SCM、DevOps相关的工作。Jenkins的忠实粉丝、最佳实践的推广者，Jenkins官方Certified Jenkins Engineer（CJE）和Certified CloudBees Jenkins Platform Engineer（CCJE）认证者。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 Jenkins 2简介 1<br>Jenkins 2是什么 2<br>Jenkinsfile 3<br>声明式流水线 5<br>Blue Ocean界面 6<br>Jenkins 2的全新任务类型 7<br>做出转变的原因 10<br>DevOps理念的转变 10<br>装配流水线 11<br>可恢复性 11<br>可配置性 11<br>共享工作空间 11<br>专业知识 12<br>访问逻辑 12<br>流水线源管理 12<br>竞争 12<br>迎接挑战 13<br>兼容性 13<br>流水线兼容性 13<br>插件兼容性 15<br>检查兼容性 20<br>总结 21<br>第2章 基础知识 23<br>语法：脚本式流水线和声明式流水线 24<br>如何选择脚本式语法和声明式语法 25<br>系统（system）：主节点（master）、节点（node）、代理节点（agent）和执行器（executor）26<br>主节点 27<br>节点 27<br>代理节点 27<br>执行器 28<br>创建节点 29<br>结构：使用Jenkins DSL 31<br>节点 32<br>阶段 34<br>步骤 34<br>支持环境：开发一个流水线脚本 36<br>创建一个流水线项目 36<br>编辑器 38<br>使用代码片段生成器 39<br>运行一条流水线 43<br>回放 49<br>总结 52<br>第3章 流水线执行流程 53<br>触发任务 53<br>在其他项目构建后构建 54<br>周期性构建 54<br>使用GitHub钩子触发器进行GitSCM轮询 57<br>SCM轮询 57<br>静默期 58<br>远程触发构建 58<br>用户输入 58<br>输入 59<br>参数 62<br>多个输入参数的返回值 68<br>参数与声明式流水线 69<br>流程控制选项 74<br>超时（timeout） 74<br>重试（retry） 76<br>睡眠（sleep） 76<br>等待直到（waitUntil） 76<br>处理并发 78<br>使用lock步骤对资源加锁 78<br>使用milestone来控制并发构建 80<br>在多分支流水线中限制并发 82<br>并行地运行任务 82<br>有条件的执行功能 92<br>构建后处理 94<br>脚本式流水线构建后处理 94<br>声明式流水线与构建后处理 96<br>总结 97<br>第4章 通知与报告 99<br>通知 99<br>电子邮件 100<br>协作服务 110<br>报告 120<br>发布HTML报告 120<br>总结 123<br>第5章 访问与安全 125<br>安全加固Jenkins 125<br>启用安全性 126<br>其他全局安全配置 129<br>Jenkins中的凭证 133<br>凭证范围 134<br>凭证域 135<br>凭证提供者 135<br>凭证存储 136<br>管理凭证 136<br>选择凭证提供者 136<br>选择凭证类型 137<br>通过提供者指定凭证类型 138<br>创建和管理凭证 139<br>上下文链接 141<br>添加一个新域或者凭证 141<br>使用新域和凭证 144<br>高级凭证：基于角色的访问权限 145<br>基本用途 146<br>管理角色 147<br>分配角色 152<br>角色策略宏 155<br>在流水线中使用凭证 157<br>用户名和密码 157<br>SSH密钥 158<br>令牌凭证 159<br>控制脚本安全性 160<br>脚本检查 160<br>脚本批准 161<br>Groovy沙箱 162<br>Jenkins凭证与Vault配合使用 164<br>方法 164<br>安装 165<br>创建一个策略 165<br>身份验证 166<br>在Jenkins中使用Vault 168<br>总结 171<br>第6章 扩展你的流水线 173<br>可信库和不可信库 173<br>内部库与外部库 174<br>内部库 174<br>外部库 176<br>从代码仓库获取库 178<br>Modern SCM 178<br>Legacy SCM 178<br>在流水线脚本中使用库 179<br>从源码版本控制中自动下载库 180<br>加载库到脚本中 180<br>Jenkins项目中的库范围 182<br>库结构 183<br>样本库例程 183<br>共享库代码的结构 184<br>使用第三方库 195<br>直接加载代码 196<br>从外部SCM加载代码 196<br>回放外部代码和库 198<br>深入研究可信与不可信代码 200<br>总结 203<br>第7章 声明式流水线 205<br>动机 206<br>不直观 206<br>掌握Groovy 206<br>其他必需的装配 206<br>结构 207<br>代码块 208<br>部分 208<br>指令 209<br>步骤 209<br>条件 210<br>构建代码块 210<br>Pipeline 211<br>Agent 212<br>Environment 215<br>Tools 216<br>Options 219<br>Triggers 222<br>Parameters 224<br>Libraries 227<br>Stages 228<br>Post 231<br>处理非声明式的代码 232<br>检查你的插件 233<br>创建一个共享库 233<br>在pipeline代码块之外放置代码 233<br>script语句 234<br>在一个阶段中使用 parallel234<br>脚本检查与错误报告 235<br>声明式流水线与Blue Ocean接口 238<br>总结 238<br>第8章 理解项目类型 241<br>通用项目选项 241<br>基础设置 241<br>源码管理 247<br>构建触发器 249<br>构建环境 256<br>构建 266<br>构建后操作 266<br>项目类型 266<br>自由风格类型项目 267<br>Maven项目类型 267<br>流水线项目类型 270<br>外部任务项目类型 272<br>多配置项目类型 275<br>Ivy项目 280<br>文件夹 282<br>多分支流水线项目 287<br>GitHub组织项目 292<br>Bitbucket团队&#x2F;项目 296<br>总结 299<br>第9章 Blue Ocean用户界面 301<br>第一部分：管理已有的流水线 302<br>主界面 302<br>项目详情页面 305<br>运行页面 316<br>第二部分：使用Blue Ocean编辑器 325<br>不依赖现有Jenkinsfile创建一个全新的流水线 326<br>使用编辑器 330<br>编辑已有的流水线 340<br>导入和编辑已有的流水线 344<br>使用非GitHub仓库支持流水线 354<br>总结 356<br>第10章 转换 357<br>通用的准备 358<br>逻辑和准确性 358<br>项目类型 358<br>系统 358<br>访问 358<br>全局配置 359<br>插件 359<br>共享库 359<br>将自由风格类型的流水线转换为脚本式流水线 360<br>源码 364<br>编译 369<br>单元测试 373<br>集成测试 377<br>迁移流水线接下来的部分 380<br>从Jenkins流水线项目转换为Jenkinsfile 385<br>方法 388<br>最后的步骤 395<br>从脚本式流水线转换为声明式流水线 397<br>样本流水线 397<br>转换 399<br>完成转换 402<br>可用于转换的通用指南 403<br>总结 405<br>第11章 操作系统环境集成（shell、工作空间、环境和文件） 407<br>使用shell的步骤 407<br>sh步骤 408<br>bat步骤 413<br>powershell步骤 414<br>使用环境变量 415<br>withEnv步骤 416<br>使用工作空间 418<br>创建自定义工作空间 418<br>清理工作空间 420<br>文件和目录步骤 422<br>使用文件 422<br>使用目录 423<br>使用文件和目录的更多操作 424<br>总结 425<br>第12章 集成分析工具 427<br>SonarQube调查 427<br>使用个人规则 428<br>质量门和配置文件 432<br>扫描程序 434<br>将SonarQube与Jenkins一起使用 434<br>全局配置 434<br>在自由风格类型项目中使用SonarQube 436<br>在流水线项目中使用SonarQube 436<br>利用SonarQube分析的结果 437<br>在Jenkins中集成SonarQube的输出 441<br>代码覆盖率：与JaCoCo集成 442<br>关于JaCoCo 442<br>JaCoCo与流水线集成 443<br>在Jenkins中集成JaCoCo的输出 445<br>总结 446<br>第13章 集成制品管理 447<br>发布和获取制品 447<br>安装和全局配置 448<br>在脚本式流水线中使用Artifactory 449<br>执行其他任务 454<br>下载指定文件到指定目录 454<br>上传指定文件到指定路径 454<br>设置构建保留策略 455<br>构建提升 455<br>声明式流水线集成 455<br>Artifactory与Jenkins输出集成 456<br>制品归档和指纹 457<br>总结 462<br>第14章 集成容器 465<br>配置成一个云 465<br>全局配置 466<br>使用Docker镜像作为代理节点 469<br>在流水线中使用云镜像 473<br>在声明式流水线中动态创建的代理节点 477<br>Docker流水线全局变量 480<br>全局变量 480<br>Docker应用全局变量方法 481<br>Docker镜像全局变量方法 487<br>Docker容器全局变量方法 491<br>通过shell运行Docker 492<br>总结 493<br>第15章 其他接口 495<br>使用命令行接口 496<br>直接使用SSH接口 496<br>使用CLI客户端 499<br>使用Jenkins REST API 501<br>过滤结果 502<br>启动构建 504<br>使用脚本控制台 506<br>总结 508<br>第16章 故障处理 509<br>深入流水线步骤 509<br>处理序列化错误 512<br>连续传递风格 513<br>序列化流水线 513<br>NotSerializableException 513<br>处理非序列化错误 514<br>识别引发错误的脚本行 517<br>处理流水线异常 518<br>在声明式流水线中使用非声明式代码 518<br>未授权代码（脚本和方法授权） 522<br>不支持的操作 523<br>系统日志 523<br>时间戳 525<br>流水线耐用性设置 526<br>总结 527<br>关于作者 529<br>封面介绍 529<br>关于译者 530</p><h3 id="Jenkins-2权威指南-PDF-下载"><a href="#Jenkins-2权威指南-PDF-下载" class="headerlink" title="Jenkins 2权威指南 PDF 下载"></a>Jenkins 2权威指南 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1MjjGZ16iWq4MthUmeOe7uw?pwd=cg1r">https://pan.baidu.com/s/1MjjGZ16iWq4MthUmeOe7uw?pwd=cg1r</a> </p><p>提取码：cg1r</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kong网关：入门、实战与进阶》</title>
      <link href="/2023/05/19/Kong%E7%BD%91%E5%85%B3%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%81%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/05/19/Kong%E7%BD%91%E5%85%B3%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%81%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/9873662DB6DD82154A4484E46FD188A3.png" alt="《Kong网关：入门、实战与进阶》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>这是一本关于Kong网关开发和运维的集大成之作。作者基于自己在该领域的丰富实践经验，从零开始，不仅循序渐进地讲解了Kong网关的核心概念、使用方法、工作原理、工程实践和源码，而且还将微服务设计、分布式架构、DevOps等相关技术融入其中，帮助读者打通Kong网关的整个技术体系，轻松跨越从理论到项目实战的鸿沟。</p><p>全书共16章，分为4篇，具体内容如下。</p><p>入门篇（第1~4章）</p><p>首先对网关层和Kong网关做了整体性介绍，然后有针对性地讲解了Nginx、OpenResty和Lua语言等必备知识，为之后深入学习打下基础。</p><p>基础篇（第5~8章）</p><p>这部分围绕Kong网关的日常配置和操作展开，具体包括Kong网关配置文件、部署方案、命令行向导、代理、鉴权、负载均衡策略和健康检查机制等内容。</p><p>进阶篇（第9~12章）</p><p>主要介绍了Kong网关区别于其他传统网关的插件机制，以及Kong网关在整个架构体系中与其他系统之间的交互和联动。</p><p>应用篇（第13~16章）</p><p>主要结合当前日益成熟的云原生环境，给出Kong网关在不同场景下的整体解决方案，如与微服务、Service Mesh、Kubernetes、Serverless的结合等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>孔庆雍</p><p>毕业于同济大学，曾就职于华为、中国移动、数禾科技等多家公司，任职期间参与了多个大型系统设计、研发工作。现任上海珞瑾数据信息有限公司CTO、首席架构师，在现公司主导了内部自研DevOps平台的搭建及底层架构设计与规划。敏捷开发思想践行者，擅长利用技术推进项目管理与产品交付。</p><p>在企业级SaaS服务、大规模分布式架构、微服务治理、网关层设计研发等领域积累了丰富的经验，在现公司主导研发的酒店管理系统已累计覆盖10万家门店，日均请求量超1亿。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>入门篇<br>第1章 全面了解Kong网关 2<br>1.1 网关简介 2<br>1.1.1 网关的由来 3<br>1.1.2 网关的作用 3<br>1.2 Kong网关简介 6<br>1.2.1 Kong网关的发展历程 6<br>1.2.2 Kong网关与传统网关对比 6<br>1.2.3 其他主流网关 7<br>1.3 Kong网关基础组件 12<br>1.3.1 Kong服务器 12<br>1.3.2 数据库 13<br>1.3.3 Kong管理GUI 14<br>1.4 Kong网关安装指南 14<br>1.4.1 在Mac环境中安装Kong网关 15<br>1.4.2 在Linux环境中安装Kong网关 15<br>1.4.3 在Docker环境中安装Kong网关 15<br>1.5 使用Kong网关搭建Web应用 16<br>1.5.1 示例项目介绍 16<br>1.5.2 后端服务路由 18<br>1.5.3 静态页面代理 20<br>1.6 本章小结 24<br>第2章 Nginx必备知识 25<br>2.1 Nginx安装 25<br>2.1.1 在Mac环境中安装Nginx 25<br>2.1.2 在Linux环境中安装Nginx 26<br>2.1.3 在Docker环境中安装Nginx 26<br>2.2 Nginx详解 26<br>2.2.1 Nginx文件的目录结构 26<br>2.2.2 命令行参数 28<br>2.2.3 配置文件 29<br>2.2.4 依赖库 32<br>2.2.5 Nginx的工作原理 33<br>2.2.6 Nginx优化指南 35<br>2.3 项目实践 37<br>2.3.1 从Kong切换到Nginx 37<br>2.3.2 添加黑白名单 39<br>2.3.3 添加限流 39<br>2.3.4 从Nginx切换到Kong 41<br>2.3.5 小结 41<br>2.4 本章小结 42<br>第3章 Lua必备知识 43<br>3.1 Lua入门与规范 43<br>3.1.1 基础知识 43<br>3.1.2 安装指南 44<br>3.1.3 解释器 45<br>3.1.4 语法规范 46<br>3.2 数据类型 47<br>3.3 操作符 52<br>3.4 表达式语句 54<br>3.4.1 赋值语句 54<br>3.4.2 控制语句 55<br>3.5 Lua库 58<br>3.6 本章小结 62<br>第4章 OpenResty必备知识 63<br>4.1 OpenResty入门安装 63<br>4.1.1 在Mac环境中安装OpenResty 63<br>4.1.2 在Linux环境中安装OpenResty 64<br>4.1.3 在Docker环境中安装OpenResty 64<br>4.2 OpenResty详解 64<br>4.2.1 OpenResty服务器的目录结构 64<br>4.2.2 Resty CLI 65<br>4.2.3 OpenResty包管理工具 67<br>4.3 OpenResty工作原理 69<br>4.4 OpenResty性能优化 71<br>4.4.1 避免使用阻塞函数 72<br>4.4.2 巧用table组件 72<br>4.4.3 使用缓存 73<br>4.4.4 火焰图 73<br>4.5 项目实践 75<br>4.6 本章小结 82<br>基础篇<br>第5章 Kong网关配置与部署 84<br>5.1 Kong启动项配置 84<br>5.1.1 配置项加载流程 85<br>5.1.2 配置项详解 86<br>5.1.3 环境变量 89<br>5.1.4 配置文件示例 89<br>5.2 注入Nginx指令 90<br>5.2.1 注入单个Nginx指令 91<br>5.2.2 通过文件方式注入Nginx指令 92<br>5.3 个性化使用场景 92<br>5.3.1 自定义Nginx模板文件 93<br>5.3.2 在OpenResty实例中嵌入Kong 93<br>5.4 Kong网关部署 94<br>5.4.1 无数据库部署模式 94<br>5.4.2 数据库部署模式 97<br>5.4.3 混合部署模式 100<br>5.5 本章小结 102<br>第6章 Kong网关命令行 103<br>6.1 通用标志参数 104<br>6.2 Kong网关命令行详解 104<br>6.2.1 kong check 104<br>6.2.2 kong config 106<br>6.2.3 kong health 109<br>6.2.4 kong hybrid 109<br>6.2.5 kong migrations 110<br>6.2.6 kong prepare 112<br>6.2.7 kong quit 113<br>6.2.8 kong reload 113<br>6.2.9 kong restart 114<br>6.2.10 kong start 114<br>6.2.11 kong stop 115<br>6.2.12 kong version 116<br>6.3 本章小结 116<br>第7章 Kong网关代理及鉴权 117<br>7.1 Kong网关代理基础知识 117<br>7.1.1 Kong网关术语简介 117<br>7.1.2 Kong网关代理环境配置 118<br>7.2 Kong网关代理示例 118<br>7.3 路由匹配规则 121<br>7.3.1 通用匹配规则 121<br>7.3.2 paths属性 123<br>7.3.3 hosts属性 126<br>7.3.4 methods属性 128<br>7.3.5 headers属性（hosts除外） 129<br>7.3.6 sources &amp; destinations属性 129<br>7.3.7 snis属性 129<br>7.4 路由匹配优先级 130<br>7.4.1 优先级策略 130<br>7.4.2 后备路由策略 131<br>7.5 Kong网关代理行为 132<br>7.5.1 超时机制 132<br>7.5.2 错误重试机制 133<br>7.5.3 插件执行策略 133<br>7.5.4 响应内容 133<br>7.6 配置SSL协议 134<br>7.7 代理WebSocket流量 135<br>7.8 代理gRPC流量 138<br>7.9 Kong网关鉴权 140<br>7.9.1 通用鉴权流程 140<br>7.9.2 匿名接入流程 142<br>7.9.3 多重认证策略 143<br>7.10 本章小结 144<br>第8章 Kong网关负载均衡策略与健康检查 145<br>8.1 负载均衡 145<br>8.1.1 负载均衡简介 145<br>8.1.2 负载均衡解决方案 146<br>8.1.3 Kong网关中的负载均衡 146<br>8.2 基于DNS的负载均衡 146<br>8.2.1 A记录（包含AAAA记录） 147<br>8.2.2 SRV记录 147<br>8.2.3 DNS 记录优先级 147<br>8.2.4 其他注意事项 148<br>8.3 环状负载均衡器 148<br>8.3.1 基础概念 148<br>8.3.2 负载均衡策略 150<br>8.3.3 其他注意事项 151<br>8.4 负载均衡特性使用场景 151<br>8.4.1 蓝绿发布 151<br>8.4.2 金丝雀发布 155<br>8.5 健康检查 157<br>8.5.1 健康检查标准 157<br>8.5.2 健康检查类型 159<br>8.5.3 健康检查配置 160<br>8.6 本章小结 162<br>进阶篇<br>第9章 Kong网关插件 164<br>9.1 Kong网关插件简介 164<br>9.1.1 Kong网关插件概念 164<br>9.1.2 Kong网关插件原理 165<br>9.2 Kong官方插件 166<br>9.2.1 鉴权类插件 166<br>9.2.2 安全类插件 177<br>9.2.3 流量类插件 179<br>9.2.4 分析监控类插件 195<br>9.2.5 内容转换类插件 197<br>9.2.6 日志类插件 204<br>9.2.7 其他插件 210<br>9.3 自定义Kong网关插件 210<br>9.3.1 自定义插件开发流程和插件生命周期管理详解 210<br>9.3.2 插件开发套件 240<br>9.3.3 Go插件开发向导 241<br>9.3.4 自定义插件实例 243<br>9.4 本章小结 245<br>第10章 Kong网关日志 246<br>10.1 Kong网关日志简介 246<br>10.1.1 Kong网关日志分类 246<br>10.1.2 Kong网关日志级别 248<br>10.2 Kong网关结合日志平台 249<br>10.2.1 ELK方案简介 249<br>10.2.2 Kong网关结合ELK 253<br>10.2.3 日志系统使用场景 256<br>10.3 自定义日志 261<br>10.3.1 Kong网关定制日志 262<br>10.3.2 ELK定制日志 264<br>10.3.3 小结 265<br>10.4 本章小结 266<br>第11章 Kong网关运维 267<br>11.1 资源选型 267<br>11.1.1 服务器资源 267<br>11.1.2 数据库资源 268<br>11.1.3 弹性伸缩 269<br>11.1.4 性能参数 269<br>11.2 Kong网关监控 270<br>11.2.1 监控平台选型 270<br>11.2.2 搭建监控平台 271<br>11.2.3 Kong网关监控平台配置 272<br>11.2.4 Kong网关监控平台指标详解 278<br>11.2.5 Kong监控平台指标测试 279<br>11.2.6 Kong监控平台的预警功能 281<br>11.3 Kong网关运维 284<br>11.3.1 数据备份 284<br>11.3.2 软&#x2F;硬件维护 286<br>11.3.3 突发事件处理 288<br>11.4 本章小结 288<br>第12章 Kong网关安全与集群高可用 289<br>12.1 Kong网关安全配置 289<br>12.1.1 网络层访问限制 289<br>12.1.2 Kong API 回路 290<br>12.1.3 自定义Nginx配置 291<br>12.2 Kong集群 292<br>12.2.1 Kong集群简介 292<br>12.2.2 Kong集群缓存 293<br>12.3 Kong网关高可用 298<br>12.3.1 架构设计 298<br>12.3.2 引入HAProxy层 300<br>12.3.3 高可用方案测试 301<br>12.4 本章小结 308<br>应用篇<br>第13章 Kong网关结合微服务架构 310<br>13.1 微服务简介 310<br>13.1.1 微服务的优点 311<br>13.1.2 单体应用和微服务 311<br>13.1.3 微服务12要素 313<br>13.2 单体应用向微服务迁移 313<br>13.2.1 采用微服务的注意事项 314<br>13.2.2 迁移细节 314<br>13.3 使用CI&#x2F;CD流程促进微服务开发 316<br>13.3.1 CI&#x2F;CD流程基础组件 316<br>13.3.2 构建CI&#x2F;CD流程 318<br>13.4 基于Kong打造DevOps平台 320<br>13.4.1 场景描述 320<br>13.4.2 设计思路 321<br>13.4.3 DevOps平台使用指南 325<br>13.4.4 DevOps平台源码解析 329<br>13.4.5 DevOps平台扩展 335<br>13.5 本章小结 336<br>第14章 Kong网关结合Kubernetes架构方案 337<br>14.1 Kubernetes详解 337<br>14.1.1 Kubernetes简介 337<br>14.1.2 Kubernetes发展史 338<br>14.1.3 Kubernetes基本概念和术语 340<br>14.1.4 Kubernetes的HelloWorld示例 342<br>14.2 Kubernetes与Kong网关结合 350<br>14.2.1 概念描述 350<br>14.2.2 使用Kubernetes安装Kong 358<br>14.3 Kubernetes实战 359<br>14.3.1 安装Kong网关 359<br>14.3.2 使用Kong网关 360<br>14.3.3 配置Kong网关插件 361<br>14.4 本章小结 363<br>第15章 Service Mesh实践之Kuma 364<br>15.1 Service Mesh简介 364<br>15.2 Kuma简介 366<br>15.2.1 为什么使用Kuma 366<br>15.2.2 Kuma与其他Service Mesh方案的比较 366<br>15.2.3 Kuma系统组件 367<br>15.2.4 Kuma部署示例 368<br>15.3 Kuma策略概述 369<br>15.3.1 策略配置项描述 369<br>15.3.2 使用策略 370<br>15.3.3 策略匹配规则 371<br>15.4 Kuma内置策略详解 372<br>15.4.1 安全类策略 372<br>15.4.2 流量控制类策略 376<br>15.4.3 观测类策略 382<br>15.5 Kuma实战 388<br>15.5.1 适配Kuma架构 388<br>15.5.2 启动mTSL和TrafficPermission 390<br>15.6 本章小结 391<br>第16章 Serverless架构 392<br>16.1 Serverless简介 392<br>16.1.1 系统架构演化 392<br>16.1.2 部署方式演化 393<br>16.1.3 Serverless内核 395<br>16.2 Serverless实践 396<br>16.2.1 搭建开发环境 396<br>16.2.2 Web应用服务 402<br>16.3 本章小结 407<br>附录A Docker安装指南 408<br>附录B KONGA安装指南 412<br>附录C 数据库明细 417<br>附录D Admin API 422</p><h3 id="Kong网关：入门、实战与进阶-PDF-下载"><a href="#Kong网关：入门、实战与进阶-PDF-下载" class="headerlink" title="Kong网关：入门、实战与进阶 PDF 下载"></a>Kong网关：入门、实战与进阶 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1aSmiqNJZzFwMUko0RAIeZA?pwd=ox4u">https://pan.baidu.com/s/1aSmiqNJZzFwMUko0RAIeZA?pwd=ox4u</a> </p><p>提取码：ox4u</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> Kong </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python核心编程（第三版）》</title>
      <link href="/2023/05/19/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/19/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/F5IJPIEI1HLE85SBUSJ47UZ6GBJPQTX2.png" alt="《Python核心编程（第三版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是Python开发者的完全指南——针对 Python 2.5全面升级</p><p>·学习专业的Python风格、最佳实践和好的编程习惯；</p><p>·加强对Python对象、内存模型和Python面向对象特性的深入理解；</p><p>·构建更有效的Web、CGI、互联网、网络和其他客户端&#x2F;服务器架构应用程序及软件；</p><p>·学习如何使用Python中的Tkinter和其他工具来开发自己的GUI应用程序及软件；</p><p>·通过用C等语言编写扩展来提升Python应用程序的性能，或者通过使用多线程增强I&#x2F;0相关的应用程序的能力；</p><p>·学习Python中有关数据库的API，以及如何在Python中使用各种不同的数据库系统，包括MySQL、Postgres和 SQLite。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1部分　Python核心<br>第1章　欢迎来到Python世界<br>1.1　什么是Python<br>1.2　起源<br>1.3　特点<br>1.3.1　高级<br>1.3.2　面向对象<br>1.3.3　可升级<br>1.3.4　可扩展<br>1.3.5　可移植性<br>1.3.6　易学<br>1.3.7　易读<br>1.3.8　易维护<br>1.3.9　健壮性<br>1.3.10　高效的快速原型开发工具<br>1.3.11　内存管理器<br>1.3.12　解释性和（字节）编译性<br>1.4　下载和安装Python<br>1.5　运行Python<br>1.5.1　命令行上的交互式解释器<br>1.5.2　从命令行启动脚本<br>1.5.3　集成开发环境<br>1.5.4　其他的集成开发环境和执行环境<br>1.6　Python文档<br>1.7　比较Python（Python与其他语言的比较）<br>1.8　其他实现<br>1.9　练习<br>第2章　快速入门<br>2.1　程序输出，print语句及“Hello World!”<br>2.2　程序输入和raw_input（）内建函数<br>2.3　注释<br>2.4　操作符<br>2.5　变量和赋值<br>2.6　数字<br>2.7　字符串<br>2.8　列表和元组<br>2.9　字典<br>2.10　代码块及缩进对齐<br>2.11　if语句<br>2.12　while循环<br>2.13　for循环和range（）内建函数<br>2.14　列表解析<br>2.15　文件和内建函数open（）、file（）<br>2.16　错误和异常<br>2.17　函数<br>2.17.1　如何定义函数<br>2.17.2　如何调用函数<br>2.17.3　默认参数<br>2.18　类<br>2.19　模块<br>2.19.1　如何导入模块<br>2.19.2　如何访问一个模块函数或访问一个模块变量<br>2.20　实用的函数<br>2.21　练习<br>第3章　Python基础<br>3.1　语句和语法<br>3.1.1　注释（#）<br>3.1.2　继续（\）<br>3.1.3　多个语句构成代码组（:）<br>3.1.4　代码组由不同的缩进分隔<br>3.1.5　同一行书写多个语句（;）<br>3.1.6　模块<br>3.2　变量赋值<br>3.2.1　赋值操作符<br>3.2.2　增量赋值<br>3.2.3　多重赋值<br>3.2.4　“多元”赋值<br>3.3　标识符<br>3.3.1　合法的Python标识符<br>3.3.2　关键字<br>3.3.3　内建<br>3.3.4　专用下划线标识符<br>3.4　基本风格指南<br>3.4.1　模块结构和布局<br>3.4.2　在主程序中书写测试代码<br>3.5　内存管理<br>3.5.1　变量定义<br>3.5.2　动态类型<br>3.5.3　内存分配<br>3.5.4　引用计数<br>3.5.5　垃圾收集<br>3.6　第一个Python程序<br>3.7　相关模块和开发工具<br>3.8　练习<br>第4章　Python对象<br>4.1　Python 对象<br>4.2　标准类型<br>4.3　其他内建类型<br>4.3.1　类型对象和type类型对象<br>4.3.2　None–Python的Null对象<br>4.4　内部类型<br>4.4.1　代码对象<br>4.4.2　帧对象<br>4.4.3　跟踪记录对象<br>4.4.4　切片对象<br>4.4.5　省略对象<br>4.4.6　XRange 对象<br>4.5　标准类型操作符<br>4.5.1　对象值的比较<br>4.5.2　对象身份比较<br>4.5.3　布尔类型<br>4.6　标准类型内建函数<br>4.6.1　type（）<br>4.6.2　cmp（）<br>4.6.3　str（）和repr（）（及&#96;&#96;操作符）<br>4.6.4　type（）和isinstance（）<br>4.6.5　Python类型操作符和内建函数总结<br>4.7　类型工厂函数<br>4.8　标准类型的分类<br>4.8.1　存储模型<br>4.8.2　更新模型<br>4.8.3　访问模型<br>4.9　不支持的类型<br>4.10　练习<br>第5章　数字<br>5.1　数字简介<br>5.1.1　如何创建数值对象并用其赋值（数字对象）<br>5.1.2　如何更新数字对象<br>5.1.3　如何删除数字对象<br>5.2　整型<br>5.2.1　布尔型<br>5.2.2　标准整型<br>5.2.3　长整型<br>5.2.4　整型和长整型的统一<br>5.3　双精度浮点型<br>5.4　复数<br>5.5　操作符<br>5.5.1　混合模式操作符<br>5.5.2　标准类型操作符<br>5.5.3　算术操作符<br>5.5.4　*位操作符（只适用于整型）<br>5.6　内建函数与工厂函数<br>5.6.1　标准类型函数<br>5.6.2　数字类型函数<br>5.6.3　仅用于整型的函数<br>5.7　其他数字类型<br>5.7.1　布尔“数”<br>5.7.2　十进制浮点型<br>5.8　相关模块<br>5.9　练习<br>第6章　序列：字符串、列表和元组<br>6.1　序列<br>6.1.1　标准类型操作符<br>6.1.2　序列类型操作符<br>6.1.3　内建函数（BIF）<br>6.2　字符串<br>6.3　字符串和操作符<br>6.3.1　标准类型操作符<br>6.3.2　序列操作符切片（[]和[:]）<br>6.4　只适用于字符串的操作符<br>6.4.1　格式化操作符（％）<br>6.4.2　字符串模板: 更简单的替代品<br>6.4.3　原始字符串操作符（r&#x2F;R）<br>6.4.4　Unicode字符串操作符（u&#x2F;U）<br>6.5　内建函数<br>6.5.1　标准类型函数<br>6.5.2　序列类型函数<br>6.5.3　字符串类型函数<br>6.6　字符串内建函数<br>6.7　字符串的独特特性<br>6.7.1　特殊字符串和控制字符<br>6.7.2　三引号<br>6.7.3　字符串不变性<br>6.8　Unicode<br>6.8.1　术语<br>6.8.2　什么是Unicode<br>6.8.3　怎样使用Unicode<br>6.8.4　Codec是什么<br>6.8.5　编码解码<br>6.8.6　把Unicode应用到实际应用中<br>6.8.7　从现实中得来的教训<br>6.8.8　Python的Unicode支持<br>6.9　相关模块<br>6.10　字符串关键点总结<br>6.11　列表<br>6.12　操作符<br>6.12.1　标准类型操作符<br>6.12.2　序列类型操作符<br>6.12.3　列表类型操作符和列表解析<br>6.13　内建函数<br>6.13.1　标准类型函数<br>6.13.2　序列类型函数<br>6.13.3　列表类型内建函数<br>6.14　列表类型的内建函数<br>6.15　列表的特殊特性<br>6.16　元组<br>6.17　元组操作符和内建函数<br>6.17.1　标准类型操作符、序列类型操作符和内建函数<br>6.17.2　元组类型操作符和内建函数、内建方法<br>6.18　元组的特殊特性<br>6.18.1　不可变性给元组带来了什么影响<br>6.18.2　元组也不是那么“不可变”<br>6.18.3　默认集合类型<br>6.18.4　单元素元组<br>6.18.5　字典的关键字<br>6.19　相关模块<br>6.20　*拷贝Python对象、浅拷贝和深拷贝<br>6.21　序列类型小结<br>6.22　练习<br>第7章　映像和集合类型<br>7.1　映射类型：字典<br>7.1.1　如何创建字典和给字典赋值<br>7.1.2　如何访问字典中的值<br>7.1.3　如何更新字典<br>7.1.4　如何删除字典元素和字典<br>7.2　映射类型操作符<br>7.2.1　标准类型操作符<br>7.2.2　映射类型操作符<br>7.3　映射类型的内建函数和工厂函数<br>7.3.1　标准类型函数[type（）、str（）和cmp（）]<br>7.3.2　映射类型相关的函数<br>7.4　映射类型内建方法<br>7.5　字典的键<br>7.5.1　不允许一个键对应多个值<br>7.5.2　键必须是可哈希的<br>7.6　集合类型<br>7.6.1　如何创建集合类型和给集合赋值<br>7.6.2　如何访问集合中的值<br>7.6.3　如何更新集合<br>7.6.4　如何删除集合中的成员和集合<br>7.7　集合类型操作符<br>7.7.1　标准类型操作符（所有的集合类型）<br>7.7.2　集合类型操作符（所有的集合类型）<br>7.7.3　集合类型操作符（仅适用于可变集合）<br>7.8　内建函数<br>7.8.1　标准类型函数<br>7.8.2　集合类型工厂函数<br>7.9　集合类型内建方法<br>7.9.1　方法（所有的集合方法）<br>7.9.2　方法（仅适用于可变集合）<br>7.9.3　操作符和内建方法比较<br>7.10　集合类型总结表<br>7.11　相关模块<br>7.12　练习<br>第8章　条件和循环<br>8.1　if语句<br>8.1.1　多重条件表达式<br>8.1.2　单一语句的代码块<br>8.2　else语句<br>8.3　elif（即else-if）语句<br>8.4　条件表达式（即“三元操作符”）<br>8.5　while语句<br>8.5.1　一般语法<br>8.5.2　计数循环<br>8.5.3　无限循环<br>8.6　for语句<br>8.6.1　一般语法<br>8.6.2　用于序列类型<br>8.6.3　用于迭代器类型<br>8.6.4　range（）内建函数<br>8.6.5　xrange（） 内建函数<br>8.6.6　与序列相关的内建函数<br>8.7　break语句<br>8.8　continue语句<br>8.9　pass语句<br>8.10　再谈else语句<br>8.11　迭代器和iter（）函数<br>8.11.1　什么是迭代器<br>8.11.2　为什么要迭代器<br>8.11.3　如何迭代<br>8.11.4　使用迭代器<br>8.11.5　可变对象和迭代器<br>8.11.6　如何创建迭代器<br>8.12　列表解析<br>8.13　生成器表达式<br>8.14　相关模块<br>8.15　练习<br>第9章　文件和输入输出<br>9.1　文件对象<br>9.2　文件内建函数（open（）和file（））<br>9.2.1　工厂函数file（）<br>9.2.2　通用换行符支持（UNS）<br>9.3　文件内建方法<br>9.3.1　输入<br>9.3.2　输出<br>9.3.3　文件内移动<br>9.3.4　文件迭代<br>9.3.5　其他<br>9.3.6　文件方法杂项<br>9.4　文件内建属性<br>9.5　标准文件<br>9.6　命令行参数<br>9.7　文件系统<br>9.8　文件执行<br>9.9　永久存储模块<br>9.9.1　pickle和marshal模块<br>9.9.2　DBM风格的模块<br>9.9.3　shelve模块<br>9.10　相关模块<br>9.11　练习<br>第10章　错误和异常<br>10.1　什么是异常<br>10.1.1　错误<br>10.1.2　异常<br>10.2　Python 中的异常<br>10.3　检测和处理异常<br>10.3.1　try-except语句<br>10.3.2　包装内建函数<br>10.3.3　带有多个except的try语句<br>10.3.4　处理多个异常的except语句<br>10.3.5　捕获所有异常<br>10.3.6　“异常参数”<br>10.3.7　在应用使用我们封装的函数<br>10.3.8　else子句<br>10.3.9　finally子句<br>10.3.10　try-finally语句<br>10.3.11　try-except-else-finally：厨房一锅端<br>10.4　上下文管理<br>10.4.1　with语句<br>10.4.2　*上下文管理协议<br>10.5　*字符串作为异常<br>10.6　触发异常<br>10.7　断言<br>10.8　标准异常<br>10.9　*创建异常<br>10.10　（现在）为什么用异常<br>10.11　到底为什么要异常<br>10.12　异常和sys模块<br>10.13　相关模块<br>10.14　练习<br>第11章　函数和函数式编程<br>11.1　什么是函数？<br>11.1.1　函数vs过程<br>11.1.2　返回值与函数类型<br>11.2　调用函数<br>11.2.1　函数操作符<br>11.2.2　关键字参数<br>11.2.3　默认参数<br>11.2.4　参数组<br>11.3　创建函数<br>11.3.1　def语句<br>11.3.2　声明与定义比较<br>11.3.3　前向引用<br>11.3.4　函数属性<br>11.3.5　内部&#x2F;内嵌函数<br>11.3.6　*函数（与方法）装饰器<br>11.4　传递函数<br>11.5　Formal Arguments<br>11.5.1　位置参数<br>11.5.2　默认参数<br>11.6　可变长度的参数<br>11.6.1　非关键字可变长参数（元组）<br>11.6.2　关键字变量参数（字典）<br>11.6.3　调用带有可变长参数对象函数<br>11.7　函数式编程<br>11.7.1　匿名函数与lambda<br>11.7.2　内建函数apply（）、filter（）、map（）、reduce（）<br>11.7.3　偏函数应用<br>11.8　变量作用域<br>11.8.1　全局变量与局部变量<br>11.8.2　globa语句<br>11.8.3　作用域的数字<br>11.8.4　闭包<br>11.8.5　作用域和lambda<br>11.8.6　变量作用域和名称空间<br>11.9　<em>递归<br>11.10　生成器<br>11.10.1　简单的生成器特性<br>11.10.2　加强的生成器特性<br>11.11　练习<br>第12章　模块<br>12.1　什么是模块<br>12.2　模块和文件<br>12.2.1　模块名称空间<br>12.2.2　搜索路径和路径搜索<br>12.3　名称空间<br>12.3.1　名称空间与变量作用域比较<br>12.3.2　名称查找、确定作用域、覆盖<br>12.3.3　无限制的名称空间<br>12.4　导入模块<br>12.4.1　import语句<br>12.4.2　from-import语句<br>12.4.3　多行导入<br>12.4.4　扩展的import语句（as）<br>12.5　模块导入的特性<br>12.5.1　载入时执行模块<br>12.5.2　导入（import）和加载（load）<br>12.5.3　导入到当前名称空间的名称<br>12.5.4　被导入到导入者作用域的名字<br>12.5.5　关于__future__<br>12.5.6　警告框架<br>12.5.7　从ZIP文件中导入模块<br>12.5.8　“新的”导入钩子<br>12.6　模块内建函数<br>12.6.1　__import__（）<br>12.6.2　globals（）和locals（）<br>12.6.3　reload（）<br>12.7　包<br>12.7.1　目录结构<br>12.7.2　使用from-import导入包<br>12.8　模块的其他特性<br>12.8.1　自动载入的模块<br>12.8.2　阻止属性导入<br>12.8.3　不区分大小的导入<br>12.8.4　源代码编码<br>12.8.5　导入循环<br>12.8.6　模块执行<br>12.9　相关模块<br>12.10　练习<br>第13章　面向对象编程<br>13.1　引言<br>13.2　面向对象编程<br>13.2.1　面向对象设计与面向对象编程的关系<br>13.2.2　现实中的问题<br>13.2.3　<em>常用术语<br>13.3　类<br>13.3.1　创建类<br>13.3.2　声明与定义<br>13.4　类属性<br>13.4.1　类的数据属性<br>13.4.2　Methods<br>13.4.3　决定类的属性<br>13.4.4　特殊的类属性<br>13.5　实例<br>13.5.1　初始化：通过调用类对象来创建实例<br>13.5.2　__init__（）“构造器”方法<br>13.5.3　__new__（）“构造器”方法<br>13.5.4　__del__（）“解构器”方法<br>13.6　实例属性<br>13.6.1　“实例化”实例属性（或创建一个更好的构造器）<br>13.6.2　查看实例属性<br>13.6.3　特殊的实例属性<br>13.6.4　建类型属性<br>13.6.5　实例属性vs类属性<br>13.7　绑定和方法调用<br>13.7.1　调用绑定方法<br>13.7.2　调用非绑定方法<br>13.8　静态方法和类方法<br>13.8.1　staticmethod（）和classmethod（）内建函数<br>13.8.2　使用函数修饰符<br>13.9　组合<br>13.10　子类和派生<br>13.11　继承<br>13.11.1　__bases__类属性<br>13.11.2　通过继承覆盖方法<br>13.11.3　从标准类型派生<br>13.11.4　多重继承<br>13.12　类、实例和其他对象的内建函数<br>13.12.1　issubclass（）<br>13.12.2　isinstance（）<br>13.12.3　hasattr（）、getattr（）、setattr（）、delattr（）<br>13.12.4　dir（）<br>13.12.5　super（）<br>13.12.6　vars（）<br>13.13　用特殊方法定制类<br>13.13.1　简单定制（RoundFloat2）<br>13.13.2　数值定制（Time60）<br>13.13.3　迭代器（RandSeq和AnyIter）<br>13.13.4　<em>多类型定制（NumStr）<br>13.14　私有化<br>13.15　<em>授权<br>13.15.1　包装<br>13.15.2　实现授权<br>13.16　新式类的高级特性（Python 2.2+）<br>13.16.1　新式类的通用特性<br>13.16.2　__slots__类属性<br>13.16.3　<strong>getattribute__（）特殊方法<br>13.16.4　描述符<br>13.16.5　元类和__metaclass</strong><br>13.17　相关模块和文档<br>13.18　练习<br>第14章　执行环境<br>14.1　可调用对象<br>14.1.1　函数<br>14.1.2　方法<br>14.1.3　类<br>14.1.4　类的实例<br>14.2　代码对象<br>14.3　可执行的对象声明和内建函数<br>14.3.1　callable（）<br>14.3.2　compile（）<br>14.3.3　eval（）<br>14.3.4　exec<br>14.3.5　input（）<br>14.3.6　使用Python在运行时生成和执行Python代码<br>14.4　执行其他（Python）程序<br>14.4.1　导入<br>14.4.2　execfile（）<br>14.4.3　将模块作为脚本执行<br>14.5　执行其他（非Python）程序<br>14.5.1　os.system（）<br>14.5.2　os.popen（）<br>14.5.3　os.fork（）、os.exec</em>（）、os.wait</em>（）<br>14.5.4　os.spawn</em>（）<br>14.5.5　subprocess 模块<br>14.5.6　相关函数<br>14.6　受限执行<br>14.7　结束执行<br>14.7.1　sys.exit（） and SystemExit<br>14.7.2　sys.exitfunc（）<br>14.7.3　os._exit（） 函数<br>14.7.4　os.kill（） Function<br>14.8　各种操作系统接口<br>14.9　相关模块<br>14.10　练习<br>第2部分　高级主题<br>第15章　正则表达式<br>15.1　引言&#x2F;动机<br>15.2　正则表达式使用的特殊符号和字符<br>15.2.1　用管道符号（|）匹配多个正则表达式模式<br>15.2.2　匹配任意一个单个的字符（.）<br>15.2.3　从字符串的开头或结尾或单词边界开始匹配（^&#x2F;$ &#x2F;\b &#x2F;\B ）<br>15.2.4　创建字符类（[]）<br>15.2.5　指定范围（-）和否定（^）<br>15.2.6　使用闭包操作符（</em>，+，?，{}）实现多次出现&#x2F;重复匹配<br>15.2.7　特殊字符表示、字符集<br>15.2.8　用圆括号（（））组建组<br>15.3　正则表达式和Python语言<br>15.3.1　re模块：核心函数和方法<br>15.3.2　使用compile（）编译正则表达式<br>15.3.3　匹配对象和group（）、groups（）方法<br>15.3.4　用match（）匹配字符串<br>15.3.5　search（）在一个字符串中查找一个模式（搜索与匹配的比较）<br>15.3.6　匹配多个字符串（|）<br>15.3.7　匹配任意单个字符（.）<br>15.3.8　创建字符集合（[]）<br>15.3.9　重复、特殊字符和子组<br>15.3.10　从字符串的开头或结尾匹配及在单词边界上的匹配<br>15.3.11　用findall（）找到每个出现的匹配部分<br>15.3.12　用sub（）（和subn（））进行搜索和替换<br>15.3.13　用split（）分割（分隔模式）<br>15.4　正则表达式示例<br>15.4.1　匹配一个字符串<br>15.4.2　搜索与匹配的比较，“贪婪”匹配<br>15.5　练习<br>第16章　网络编程<br>16.1　引言<br>16.1.1　什么是客户端&#x2F;服务器架构<br>16.1.2　客户端&#x2F;服务器网络编程<br>16.2　套接字：通信端点<br>16.2.1　什么是套接字<br>16.2.2　套接字地址：主机与端口<br>16.2.3　面向连接与无连接<br>16.3　Python中的网络编程<br>16.3.1　socket（）模块函数<br>16.3.2　套接字对象（内建）方法<br>16.3.3　创建一个TCP服务器<br>16.3.4　创建TCP客户端<br>16.3.5　运行我们的客户端与TCP服务器<br>16.3.6　创建一个UDP服务器<br>16.3.7　创建一个UDP客户端<br>16.3.8　执行UDP服务器和客户端<br>16.3.9　Socket模块属性<br>16.4　*SocketServer模块<br>16.4.1　创建一个SocketServerTCP服务器<br>16.4.2　创建SocketServerTCP客户端<br>16.4.3　执行TCP服务器和客户端<br>16.5　Twisted框架介绍<br>16.5.1　创建一个Twisted Reactor TCP服务器<br>16.5.2　创建一个Twisted Reactor TCP客户端<br>16.5.3　执行TCP服务器和客户端<br>16.6　相关模块<br>16.7　练习<br>第17章　网络客户端编程<br>17.1　什么是因特网客户端<br>17.2　文件传输<br>17.2.1　文件传输网际协议<br>17.2.2　文件传输协议（FTP）<br>17.2.3　Python和FTP<br>17.2.4　ftplib.FTP类方法<br>17.2.5　交互式FTP示例<br>17.2.6　客户端FTP程序举例<br>17.2.7　FTP的其他方面<br>17.3　网络新闻<br>17.3.1　Usenet与新闻组<br>17.3.2　网络新闻传输协议（NNTP）<br>17.3.3　Python和NNTP<br>17.3.4　nntplib.NNTP类方法<br>17.3.5　交互式NNTP举例<br>17.3.6　客户端程序NNTP举例<br>17.3.7　NNTP的其他方面<br>17.4　电子邮件<br>17.4.1　电子邮件系统组件和协议<br>17.4.2　发送电子邮件<br>17.4.3　Python和SMTP<br>17.4.4　smtplib.SMTP类方法<br>17.4.5　交互式SMTP示例<br>17.4.6　SMTP的其他方面<br>17.4.7　接收电子邮件<br>17.4.8　POP和IMAP<br>17.4.9　Python和POP3<br>17.4.10　交互式POP3举例<br>17.4.11　poplib.POP3类方法<br>17.4.12　客户端程序SMTP和POP3举例<br>17.5　相关模块<br>17.5.1　电子邮件<br>17.5.2　其他网络协议<br>17.6　练习<br>第18章　多线程编程<br>18.1　引言&#x2F;动机<br>18.2　线程和进程<br>18.2.1　什么是进程<br>18.2.2　什么是线程<br>18.3　Python、线程和全局解释器锁<br>18.3.1　全局解释器锁（GIL）<br>18.3.2　退出线程<br>18.3.3　在Python中使用线程<br>18.3.4　没有线程支持的情况<br>18.3.5　Python的threading模块<br>18.4　thread模块<br>18.5　threading模块<br>18.5.1　Thread类<br>18.5.2　斐波那契、阶乘和累加和<br>18.5.3　threading模块中的其他函数<br>18.5.4　生产者-消费者问题和Queue模块<br>18.6　相关模块<br>18.7　练习<br>第19章　图形用户界面编程<br>19.1　简介<br>19.1.1　什么是Tcl、Tk和Tkinter<br>19.1.2　安装和使用Tkinter　533<br>19.1.3　客户端&#x2F;服务器架构　534<br>19.2　Tkinter与Python编程　534<br>19.2.1　Tkinter模块：把Tk引入你的程序<br>19.2.2　GUI程序开发简介<br>19.2.3　顶层窗口：Tkinter.Tk（）<br>19.2.4　Tk组件<br>19.3　Tkinter举例<br>19.3.1　标签组件<br>19.3.2　按钮组件<br>19.3.3　标签和按钮组件<br>19.3.4　标签、按钮和进度条组件<br>19.3.5　偏函数应用举例<br>19.3.6　中级Tkinter范例<br>19.4　其他GUI简介<br>19.4.1　Tk Interface eXtensions （Tix）<br>19.4.2　Python MegaWidgets （PMW）<br>19.4.3　wxWidgets和wxPython<br>19.4.4　GTK+和PyGTK<br>19.5　相关模块和其他GUI<br>19.6　练习<br>第20章　Web编程<br>20.1　介绍<br>20.1.1　Web应用：客户端&#x2F;服务器计算<br>20.1.2　因特网<br>20.2　使用Python进行Web应用：创建一个简单的Web客户端<br>20.2.1　统一资源定位符<br>20.2.2　urlparse模块<br>20.2.3　urllib模块<br>20.2.4　urllib2模块<br>20.3　高级Web客户端<br>20.4　CGI：帮助Web服务器处理客户端数据<br>20.4.1　CGI介绍<br>20.4.2　CGI应用程序<br>20.4.3　cgi模块<br>20.5　建立CGI应用程序<br>20.5.1　建立Web服务器<br>20.5.2　建立表单页<br>20.5.3　生成结果页<br>20.5.4　生成表单和结果页面<br>20.5.5　全面交互的Web站点<br>20.6　在CGI中使用Unicode编码<br>20.7　高级CGI<br>20.7.1　Mulitipart表单提交和文件的上传<br>20.7.2　多值字段<br>20.7.3　cookie<br>20.7.4　使用高级CGI<br>20.8　Web（HTTP）服务器<br>20.9　相关模块<br>20.10　练习<br>第21章　数据库编程<br>21.1　介绍<br>21.1.1　持久存储<br>21.1.2　基本的数据库操作和SQL语言<br>21.1.3　数据库和Python<br>21.2　Python数据库应用程序程序员接口（DB-API）<br>21.2.1　模块属性<br>21.2.2　连接对象<br>21.2.3　游标对象<br>21.2.4　类型对象和构造器<br>21.2.5　关系数据库<br>21.2.6　数据库和Python：接口程序<br>21.2.7　使用数据库接口程序举例<br>21.3　对象-关系管理器（ORM）<br>21.3.1　考虑对象，而不是SQL<br>21.3.2　Python和ORM<br>21.3.3　雇员数据库举例<br>21.3.4　总结<br>21.4　相关模块<br>21.5　练习<br>第22章　扩展Python　623<br>22.1　引言&#x2F;动机<br>22.1.1　什么是扩展<br>22.1.2　为什么要扩展Python<br>22.2　创建Python扩展<br>22.2.1　创建您的应用程序代码<br>22.2.2　用样板来包装你的代码<br>22.2.3　编译<br>22.2.4　导入和测试<br>22.2.5　引用计数<br>22.2.6　线程和全局解释器锁（GIL）<br>22.3　相关话题<br>22.4　练习<br>第23章　其他话题<br>23.1　Web服务<br>23.2　用Win32的COM来操作微软Office<br>23.2.1　客户端COM编程<br>23.2.2 微软Excel<br>23.2.3　微软Word　第1部分　Python核心<br>23.2.4　微软PowerPoint<br>23.2.5　微软Outlook<br>23.2.6　中等规模的例子<br>23.3　用Jython写Python和Java的程序<br>23.3.1　什么是Jython<br>23.3.2　Swing GUI开发（Java或者Python!）<br>23.4　练习<br>23.2.4　微软PowerPoint<br>23.2.5　微软Outlook<br>23.2.6　中等规模的例子<br>23.3　用Jython写Python和Java的程序<br>23.3.1　什么是Jython<br>23.3.2　Swing GUI开发（Java或者Python!）<br>23.4　练习</p><h3 id="Python核心编程（第三版）-PDF-下载地址"><a href="#Python核心编程（第三版）-PDF-下载地址" class="headerlink" title="Python核心编程（第三版） PDF 下载地址:"></a>Python核心编程（第三版） PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1HMIaAUXX_vJaCdTpNDtUfA?pwd=u62u">https://pan.baidu.com/s/1HMIaAUXX_vJaCdTpNDtUfA?pwd=u62u</a> </p><p>提取码: u62u </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python程序设计 人工智能案例实践》</title>
      <link href="/2023/05/19/Python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/05/19/Python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/GQ56ZXG5HPWS5N53DMH0LE4ZGIBDOOAM.png" alt="《Python程序设计 人工智能案例实践》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>通过学习本书提供的500多个实际示例，读者将学会使用交互式IPython解释器和Jupyter Notebook并快速掌握Python编码方法。在学习完第1<del>5章的Python基础知识以及第6和7章的一些关键内容之后，读者将能够处理第11</del>16章中有关人工智能案例的重要实操内容，包括自然语言处理，用于情感分析的Twitter数据挖掘，使用IBM Watson 的认知计算，利用分类和回归进行的有监督机器学习，通过聚类进行的无监督机器学习，基于深度学习和卷积神经网络的计算机视觉，基于递归神经网络的深度学习，基于Hadoop、Spark和NoSQL数据库的大数据处理，物联网等。读者还将直接或间接使用基于云的服务，如Twitter、Google Translate、IBM Watson、Microsoft Azure、OpenMapQuest、PubNub等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>保罗·戴特尔（Paul Deitel）</p><p>Deitel＆Associates公司首席执行官兼首席技术官，毕业于麻省理工学院，拥有38年的计算经验。保罗是世界上最有经验的编程语言培训师之一，自1992年以来一直针对软件开发人员教授专业课程。他服务过的国际客户包括思科、IBM、西门子、Oracle、戴尔、富达、美国国家航空航天局肯尼迪航天中心等。他也是国际上最畅销的编程语言经典图书的撰写者，如C++ How to program、C How to program、Java How to program、Visual C# How to Program，等等。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　Python基础知识快速入门<br>第1章　Python及大数据概述2<br>1.1　简介2<br>1.2　快速回顾面向对象技术的基础知识3<br>1.3　Python5<br>1.4　Python库7<br>1.4.1　Python标准库7<br>1.4.2　数据科学库8<br>1.5　试用IPython和Jupyter Notebook9<br>1.5.1　使用IPython交互模式作为计算器10<br>1.5.2　使用IPython 解释器执行Python程序11<br>1.5.3　在Jupyter Notebook中编写和执行代码12<br>1.6　云和物联网16<br>1.6.1　云16<br>1.6.2　物联网17<br>1.7　大数据有多大18<br>1.7.1　大数据分析22<br>1.7.2　数据科学和大数据正在带来改变：用例23<br>1.8　案例研究：大数据移动应用程序24<br>1.9　数据科学入门：人工智能——计算机科学与数据科学的交叉学科26<br>1.10　小结28<br>第2章　Python程序设计概述29<br>2.1　简介29<br>2.2　变量和赋值语句30<br>2.3　算术运算31<br>2.4　print函数、单引号和双引号34<br>2.5　三引号字符串36<br>2.6　从用户处获取输入37<br>2.7　决策：if语句和比较运算符39<br>2.8　对象和动态类型43<br>2.9　数据科学入门：基础的描述性统计44<br>2.10　小结46<br>第3章　控制语句48<br>3.1　简介48<br>3.2　控制语句概述49<br>3.3　if语句49<br>3.4　if…else和if…elif…else语句50<br>3.5　while语句53<br>3.6　for语句54<br>3.6.1　可迭代对象、列表和迭代器55<br>3.6.2　内置函数range55<br>3.7　增强赋值56<br>3.8　序列控制迭代和格式化字符串56<br>3.9　边界值控制的迭代57<br>3.10　内置函数range：深入讨论59<br>3.11　使用Decimal类型处理货币金额59<br>3.12　break和continue语句63<br>3.13　布尔运算符and、or和not63<br>3.14　数据科学入门：集中趋势度量—均值、中值和众数66<br>3.15　小结67<br>第4章　函数69<br>4.1　简介69<br>4.2　函数定义70<br>4.3　多参数函数72<br>4.4　随机数生成74<br>4.5　案例研究：一个运气游戏76<br>4.6　Python标准库79<br>4.7　math模块中的函数80<br>4.8　在IPython中使用制表符自动补全81<br>4.9　默认参数值82<br>4.10　关键字参数83<br>4.11　不定长参数列表83<br>4.12　方法：属于对象的函数84<br>4.13　作用域规则85<br>4.14　import：深入讨论87<br>4.15　向函数传递参数：深入讨论88<br>4.16　递归91<br>4.17　函数式编程93<br>4.18　数据科学入门：离中趋势度量95<br>4.19　小结96<br>第5章　序列：列表和元组97<br>5.1　简介97<br>5.2　列表98<br>5.3　元组102<br>5.4　序列解包104<br>5.5　序列切片106<br>5.6　使用del声明108<br>5.7　将列表传递给函数109<br>5.8　列表排序110<br>5.9　序列搜索111<br>5.10　列表的其他方法113<br>5.11　使用列表模拟堆栈115<br>5.12　列表推导式116<br>5.13　生成器表达式118<br>5.14　过滤、映射和归约118<br>5.15　其他的序列处理函数120<br>5.16　二维列表122<br>5.17　数据科学入门：模拟和静态可视化124<br>5.17.1　掷600、60,000、6,000,000次骰子的图例124<br>5.17.2　实现掷骰子中不同点数出现次数和百分比的可视化126<br>5.18　小结132<br>第二部分　Python数据结构、字符串和文件<br>第6章　字典和集合136<br>6.1　简介136<br>6.2　字典137<br>6.2.1　创建字典137<br>6.2.2　遍历字典138<br>6.2.3　基本的字典操作138<br>6.2.4　字典的keys和values方法140<br>6.2.5　字典的比较141<br>6.2.6　示例：学生成绩字典142<br>6.2.7　示例：单词计数143<br>6.2.8　字典的update方法144<br>6.2.9　字典推导式145<br>6.3　集合146<br>6.3.1　集合的比较147<br>6.3.2　集合的数学运算148<br>6.3.3　集合的可变运算符和方法150<br>6.3.4　集合推导式151<br>6.4　数据科学入门：动态可视化151<br>6.4.1　动态可视化的工作原理152<br>6.4.2　实现动态可视化154<br>6.5　小结156<br>第7章　使用NumPy进行面向数组的编程158<br>7.1　简介158<br>7.2　从现有数据创建数组159<br>7.3　数组属性160<br>7.4　用特定值填充数组162<br>7.5　从范围创建数组162<br>7.6　列表与数组的性能比较：引入%timeit164<br>7.7　数组运算符165<br>7.8　NumPy计算方法167<br>7.9　通用函数168<br>7.10　索引和切片170<br>7.11　视图：浅拷贝171<br>7.12　视图：深拷贝173<br>7.13　重塑和转置174<br>7.14　数据科学入门：pandas Series和DataFrame176<br>7.14.1　Series177<br>7.14.2　DataFrame181<br>7.15　小结188<br>第8章　字符串：深入讨论190<br>8.1　简介190<br>8.2　格式化字符串191<br>8.2.1　表示类型191<br>8.2.2　字段宽度和对齐方式193<br>8.2.3　数字格式化193<br>8.2.4　字符串的format方法194<br>8.3　拼接和重复字符串195<br>8.4　去除字符串中的空白字符196<br>8.5　字符大小写转换196<br>8.6　字符串的比较运算符197<br>8.7　查找子字符串197<br>8.8　替换子字符串199<br>8.9　字符串拆分和连接199<br>8.10　字符串测试方法201<br>8.11　原始字符串202<br>8.12　正则表达式介绍202<br>8.12.1　re模块与fullmatch函数203<br>8.12.2　替换子字符串和拆分字符串207<br>8.12.3　其他搜索功能、访问匹配207<br>8.13　数据科学入门：pandas、正则表达式和数据治理210<br>8.14　小结214<br>第9章　文件和异常215<br>9.1　简介215<br>9.2　文件216<br>9.3　文本文件处理217<br>9.3.1　向文本文件中写入数据：with语句的介绍217<br>9.3.2　从文本文件中读取数据218<br>9.4　更新文本文件220<br>9.5　使用JSON进行序列化221<br>9.6　关注安全：pickle序列化和反序列化224<br>9.7　关于文件的附加说明224<br>9.8　处理异常225<br>9.8.1　被零除和无效输入226<br>9.8.2　try语句226<br>9.8.3　在一条except子句中捕获多个异常229<br>9.8.4　一个函数或方法引发了什么异常229<br>9.8.5　try子句的语句序列中应该书写什么代码229<br>9.9　finally子句229<br>9.10　显式地引发一个异常231<br>9.11　（选学）堆栈展开和回溯232<br>9.12　数据科学入门：使用CSV文件234<br>9.12.1　Python标准库模块csv234<br>9.12.2　将CSV文件数据读入pandas DataFrame中236<br>9.12.3　读取泰坦尼克号灾难数据集237<br>9.12.4　用泰坦尼克号灾难数据集做简单的数据分析238<br>9.12.5　乘客年龄直方图239<br>9.13　小结240<br>第三部分　Python高级主题<br>第10章　面向对象编程242<br>10.1　简介242<br>10.2　自定义Account类244<br>10.2.1　试用Account类245<br>10.2.2　Account类的定义246<br>10.2.3　组合：对象引用作为类的成员248<br>10.3　属性访问控制248<br>10.4　用于数据访问的property249<br>10.4.1　试用Time类249<br>10.4.2　Time类的定义251<br>10.4.3　Time类定义的设计说明254<br>10.5　模拟“私有”属性255<br>10.6　案例研究：洗牌和分牌模拟257<br>10.6.1　试用Card类和DeckOfCards类257<br>10.6.2　Card类：引入类属性258<br>10.6.3　DeckOfCards类260<br>10.6.4　利用Matplotlib显示扑克牌图像262<br>10.7　继承：基类和子类265<br>10.8　构建继承层次结构：引入多态性267<br>10.8.1　基类CommissionEmployee267<br>10.8.2　子类SalariedCommission-Employee270<br>10.8.3　以多态方式处理Commission-Employee和SalariedComm-issionEmployee273<br>10.8.4　关于基于对象和面向对象编程的说明274<br>10.9　鸭子类型和多态性274<br>10.10　运算符重载276<br>10.10.1　试用Complex类277<br>10.10.2　Complex类的定义278<br>10.11　异常类层次结构和自定义异常279<br>10.12　具名元组280<br>10.13　Python 3.7的新数据类简介281<br>10.13.1　创建Card数据类282<br>10.13.2　使用Card数据类284<br>10.13.3　数据类相对于具名元组的优势286<br>10.13.4　数据类相对于传统类的优势286<br>10.14　使用文档字符串和doctest进行单元测试286<br>10.15　命名空间和作用域290<br>10.16　数据科学入门：时间序列和简单线性回归293<br>10.17　小结300<br>第四部分　人工智能、云和大数据案例研究<br>第11章　自然语言处理304<br>11.1　简介304<br>11.2　TextBlob305<br>11.2.1　创建一个TextBlob对象307<br>11.2.2　将文本标记为句子和单词307<br>11.2.3　词性标注308<br>11.2.4　提取名词短语309<br>11.2.5　使用TextBlob的默认情感分析器进行情感分析309<br>11.2.6　使用NaiveBayesAnalyzer进行情感分析310<br>11.2.7　语言检测与翻译311<br>11.2.8　变形：复数化和单数化312<br>11.2.9　拼写检查和拼写校正313<br>11.2.10　规范化：词干提取和词形还原314<br>11.2.11　词频314<br>11.2.12　从WordNet中获取单词定义、同义词和反义词315<br>11.2.13　删除停用词317<br>11.2.14　n元318<br>11.3　使用柱状图和词云可视化词频319<br>11.3.1　使用pandas可视化词频319<br>11.3.2　使用词云可视化词频321<br>11.4　使用Textatistic库进行可读性评估324<br>11.5　使用spaCy命名实体识别326<br>11.6　使用spaCy进行相似性检测327<br>11.7　其他NLP库和工具328<br>11.8　机器学习和深度学习自然语言应用328<br>11.9　自然语言数据集329<br>11.10　小结329<br>第12章　Twitter数据挖掘331<br>12.1　简介331<br>12.2　Twitter API概况333<br>12.3　创建一个Twitter账户334<br>12.4　获取Twitter凭据，创建应用程序334<br>12.5　什么是推文336<br>12.6　Tweepy339<br>12.7　通过Tweepy进行Twitter身份验证340<br>12.8　获取一个Twitter账户的相关信息341<br>12.9　Tweepy Cursor简介：获得一个账户的关注者和朋友343<br>12.9.1　确定一个账户的关注者343<br>12.9.2　确定一个账户的关注对象345<br>12.9.3　获取一个用户的最新推文345<br>12.10　搜索最新的推文346<br>12.11　热门话题发现：Twitter热门话题API348<br>12.11.1　有热门话题的地点348<br>12.11.2　获取热门话题列表349<br>12.11.3　根据热门话题创建词云351<br>12.12　推文分析前的清理或预处理352<br>12.13　Twitter流API353<br>12.13.1　创建StreamListener的子类353<br>12.13.2　启动流处理356<br>12.14　推文情感分析357<br>12.15　地理编码和映射361<br>12.15.1　获取和映射推文362<br>12.15.2　tweetutilities.py中的实用函数366<br>12.15.3　LocationListener类367<br>12.16　存储推文的方法368<br>12.17　Twitter和时间序列369<br>12.18　小结369<br>第13章　IBM Watson和认知计算370<br>13.1　简介370<br>13.2　IBM云账户和云控制台372<br>13.3　Watson服务372<br>13.4　额外的服务和工具375<br>13.5　Watson开发者云Python SDK377<br>13.6　案例研究：旅行者翻译伴侣APP377<br>13.6.1　准备工作378<br>13.6.2　运行APP379<br>13.6.3　SimpleLanguageTranslator.py脚本代码分析380<br>13.7　Watson资源390<br>13.8　小结391<br>第14章　机器学习：分类、回归和聚类392<br>14.1　简介392<br>14.1.1　scikit-learn393<br>14.1.2　机器学习的类别394<br>14.1.3　scikit-learn中内置的数据集396<br>14.1.4　典型的数据科学研究的步骤396<br>14.2　案例研究：用k近邻算法和Digits数据集进行分类（第1部分）397<br>14.2.1　k近邻算法398<br>14.2.2　加载数据集399<br>14.2.3　可视化数据402<br>14.2.4　拆分数据以进行训练和测试404<br>14.2.5　创建模型405<br>14.2.6　训练模型405<br>14.2.7　预测数字类别406<br>14.3　案例研究：利用k近邻算法和Digits数据集进行分类（第2部分）407<br>14.3.1　模型准确性指标407<br>14.3.2　k折交叉验证410<br>14.3.3　运行多个模型以找到最佳模型411<br>14.3.4　超参数调整413<br>14.4　案例研究：时间序列和简单线性回归413<br>14.5　案例研究：基于加利福尼亚房价数据集的多元线性回归418<br>14.5.1　加载数据集418<br>14.5.2　使用pandas探索数据420<br>14.5.3　可视化特征422<br>14.5.4　拆分数据以进行训练和测试426<br>14.5.5　训练模型426<br>14.5.6　测试模型427<br>14.5.7　可视化预测房价和期望房价427<br>14.5.8　回归模型指标428<br>14.5.9　选择最佳模型429<br>14.6　案例研究：无监督学习（第1部分）—降维430<br>14.7　案例研究：无监督学习（第2部分）—k均值聚类433<br>14.7.1　加载Iris数据集435<br>14.7.2　探索Iris数据集：使用pandas进行描述性统计436<br>14.7.3　使用Seaborn的pairplot可视化数据集438<br>14.7.4　使用KMeans估计器440<br>14.7.5　主成分分析降维442<br>14.7.6　选择最佳聚类估计器444<br>14.8　小结445<br>第15章　深度学习447<br>15.1　简介447<br>15.1.1　深度学习应用449<br>15.1.2　深度学习演示450<br>15.1.3　Keras资源450<br>15.2　Keras内置数据集450<br>15.3　自定义Anaconda环境451<br>15.4　神经网络452<br>15.5　张量454<br>15.6　用于视觉的卷积神经网络：使用MNIST数据集进行多分类455<br>15.6.1　加载MNIST数据集457<br>15.6.2　数据探索457<br>15.6.3　数据准备459<br>15.6.4　创建神经网络模型461<br>15.6.5　训练和评价模型468<br>15.6.6　保存和加载模型472<br>15.7　用TensorBoard可视化神经网络的训练过程473<br>15.8　ConvnetJS：基于浏览器的深度学习训练和可视化476<br>15.9　针对序列的递归神经网络：使用IMDb数据集进行情感分析477<br>15.9.1　加载IMDb影评数据集478<br>15.9.2　数据探索478<br>15.9.3　数据准备480<br>15.9.4　创建神经网络481<br>15.9.5　训练和评价模型483<br>15.10　调整深度学习模型484<br>15.11　在ImageNet上预训练的CNN模型485<br>15.12　小结486<br>第16章　大数据：Hadoop、Spark、NoSQL和IoT488<br>16.1　简介488<br>16.2　关系数据库和结构化查询语言492<br>16.2.1　books数据库493<br>16.2.2　SELECT查询497<br>16.2.3　WHERE子句497<br>16.2.4　ORDER BY子句498<br>16.2.5　从多个表中合并数据：INNER JOIN499<br>16.2.6　INSERT INTO语句500<br>16.2.7　UPDATE语句501<br>16.2.8　DELETE FROM语句502<br>16.3　NoSQL和NewSQL大数据数据库简述502<br>16.3.1　NoSQL键-值数据库503<br>16.3.2　NoSQL文档数据库503<br>16.3.3　NoSQL列式数据库504<br>16.3.4　NoSQL图数据库504<br>16.3.5　NewSQL数据库505<br>16.4　案例研究：MongoDB JSON文档数据库506<br>16.4.1　创建MongoDB Atlas集群506<br>16.4.2　将推文存入MongoDB中507<br>16.5　Hadoop515<br>16.5.1　概述516<br>16.5.2　通过MapReduce汇总Romeo-AndJuliet.txt中的单词长度518<br>16.5.3　在Microsoft Azure HDInsight中创建Apache Hadoop集群518<br>16.5.4　Hadoop流520<br>16.5.5　实现映射器520<br>16.5.6　实现归约器521<br>16.5.7　准备运行MapReduce示例522<br>16.5.8　运行MapReduce作业523<br>16.6　Spark525<br>16.6.1　概述525<br>16.6.2　Docker和Jupyter Docker堆栈526<br>16.6.3　使用Spark的单词计数529<br>16.6.4　Microsoft Azure上的Spark单词计数532<br>16.7　Spark流：使用pyspark-notebookDocker堆栈计算Twitter主题标签535<br>16.7.1　将推文流式传输到套接字535<br>16.7.2　总结推文主题标签，介绍Spark SQL538<br>16.8　物联网和仪表板543<br>16.8.1　发布和订阅545<br>16.8.2　使用Freeboard仪表板可视化PubNub示例实时流545<br>16.8.3　用Python模拟一个连接互联网的恒温器547<br>16.8.4　使用freeboard.io创建仪表板549<br>16.8.5　创建一个Python PubNub订阅服务器550<br>16.9　小结554<br>索引556</p><h3 id="Python程序设计-人工智能案例实践-PDF-下载地址"><a href="#Python程序设计-人工智能案例实践-PDF-下载地址" class="headerlink" title="Python程序设计 人工智能案例实践 PDF 下载地址:"></a>Python程序设计 人工智能案例实践 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1HsVD-Pc4mTAsmrbFWFwKEg?pwd=e9hm">https://pan.baidu.com/s/1HsVD-Pc4mTAsmrbFWFwKEg?pwd=e9hm</a> </p><p>提取码: e9hm </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python编程：从入门到实践》</title>
      <link href="/2023/05/19/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/05/19/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/031C7413E5CDC918603FDAB290074F33.png" alt="《Python编程：从入门到实践》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是针对所有层次Python读者而作的Python入门书。全书分两部分：第一部分介绍用Python编程所必须了解的基本概念，包括Matplotlib等强大的Python库和工具，以及列表、字典、if语句、类、文件与异常、代码测试等内容；第二部分将理论付诸实践，讲解如何开发三个项目，包括简单的2D游戏、利用数据生成交互式的信息图以及创建和定制简单的Web应用，并帮助读者解决常见编程问题和困惑。第2版进行了全面修订，简化了Python安装流程，新增了f字符串、get()方法等内容，并且在项目中使用了Plotly库以及新版本的Django和Bootstrap，等等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>埃里克·马瑟斯（Eric Matthes）</p><p>高中科学和数学老师，现居住在阿拉斯加，在当地讲授Python入门课程。他从5岁开始就一直在编写程序。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 基础知识<br>第1章 起步　　2<br>1.1 搭建编程环境　　2<br>1.1.1 Python版本　　2<br>1.1.2 运行Python代码片段　　2<br>1.1.3 Sublime Text简介　　3<br>1.2 在不同操作系统中搭建Python编程环境　　3<br>1.2.1 在Windows系统中搭建Python编程环境　　4<br>1.2.2 在macOS系统中搭建Python编程环境　　5<br>1.2.3 在Linux 系统中搭建Python编程环境　　7<br>1.3 运行Hello World 程序　　8<br>1.3.1 配置Sublime Text以使用正确的Python版本　　8<br>1.3.2 运行程序hello_world.py　　8<br>1.4 解决安装问题　　9<br>1.5 从终端运行Python程序　　9<br>1.5.1 在Windows系统中从终端运行Python 程序　　10<br>1.5.2 在Linux和macOS系统中从终端运行Python程序　　10<br>1.6 小结　　11<br>第2章 变量和简单数据类型　　12<br>2.1 运行hello_world.py时发生的情况　　12<br>2.2 变量　　13<br>2.2.1 变量的命名和使用　　13<br>2.2.2 使用变量时避免命名错误　　14<br>2.2.3 变量是标签　　15<br>2.3 字符串　　16<br>2.3.1 使用方法修改字符串的大小写　　17<br>2.3.3 使用制表符或换行符来添加空白　　18<br>2.3.4 删除空白　　19<br>2.3.5 使用字符串时避免语法错误　　20<br>2.4 数　　21<br>2.4.1 整数　　22<br>2.4.2 浮点数　　22<br>2.4.3 整数和浮点数　　23<br>2.4.4 数中的下划线　　23<br>2.4.5 同时给多个变量赋值　　24<br>2.4.6 常量　　24<br>2.5 注释　　25<br>2.5.1 如何编写注释　　25<br>2.5.2 该编写什么样的注释　　25<br>2.6 Python之禅　　26<br>2.7 小结　　27<br>第3章 列表简介　　28<br>3.1 列表是什么　　28<br>3.1.1 访问列表元素　　29<br>3.1.2 索引从0而不是1开始　　29<br>3.1.3 使用列表中的各个值　　30<br>3.2 修改、添加和删除元素　　31<br>3.2.1 修改列表元素　　31<br>3.2.2 在列表中添加元素　　31<br>3.2.3 从列表中删除元素　　32<br>3.3 组织列表　　36<br>3.3.1 使用方法sort()对列表永久排序　　37<br>3.3.2 使用函数sorted()对列表临时排序　　37<br>3.3.3 倒着打印列表　　38<br>3.3.4 确定列表的长度　　38<br>3.4 使用列表时避免索引错误　　39<br>3.5 小结　　41<br>第4章 操作列表　　42<br>4.1 遍历整个列表　　42<br>4.1.1 深入研究循环　　43<br>4.1.2 在for 循环中执行更多操作　　44<br>4.1.3 在for 循环结束后执行一些操作　　45<br>4.2 避免缩进错误　　45<br>4.2.1 忘记缩进　　46<br>4.2.2 忘记缩进额外的代码行　　46<br>4.2.3 不必要的缩进　　47<br>4.2.4 循环后不必要的缩进　　47<br>4.2.5 遗漏了冒号　　48<br>4.3 创建数值列表　　49<br>4.3.1 使用函数range()　　49<br>4.3.2 使用range()创建数字列表　　50<br>4.3.3 对数字列表执行简单的统计计算　　51<br>4.3.4 列表解析　　52<br>4.4 使用列表的一部分　　53<br>4.4.1 切片　　53<br>4.4.2 遍历切片　　54<br>4.4.3 复制列表　　55<br>4.5 元组　　57<br>4.5.1 定义元组　　57<br>4.5.2 遍历元组中的所有值　　58<br>4.5.3 修改元组变量　　59<br>4.6 设置代码格式　　60<br>4.6.1 格式设置指南　　60<br>4.6.2 缩进　　60<br>4.6.3 行长　　60<br>4.6.4 空行　　61<br>4.6.5 其他格式设置指南　　61<br>4.7 小结　　62<br>第5章 if语句　　63<br>5.1 一个简单示例　　63<br>5.2 条件测试　　64<br>5.2.1 检查是否相等　　64<br>5.2.2 检查是否相等时忽略大小写　　64<br>5.2.3 检查是否不相等　　65<br>5.2.4 数值比较　　66<br>5.2.5 检查多个条件　　66<br>5.2.6 检查特定值是否包含在列表中　　68<br>5.2.8 布尔表达式　　68<br>5.3 if语句　　69<br>5.3.1 简单的if语句　　69<br>5.3.2 if-else语句　　70<br>5.3.3 if-elif-else结构　　71<br>5.3.4 使用多个elif代码块　　72<br>5.3.5 省略else代码块　　73<br>5.3.6 测试多个条件　　73<br>5.4 使用if语句处理列表　　76<br>5.4.1 检查特殊元素　　76<br>5.4.2 确定列表不是空的　　77<br>5.4.3 使用多个列表　　77<br>5.5 设置if语句的格式　　79<br>5.6 小结　　80<br>第6章 字典　　81<br>6.1 一个简单的字典　　81<br>6.2 使用字典　　82<br>6.2.1 访问字典中的值　　82<br>6.2.2 添加键值对　　83<br>6.2.3 先创建一个空字典　　83<br>6.2.4 修改字典中的值　　84<br>6.2.5 删除键值对　　85<br>6.2.6 由类似对象组成的字典　　86<br>6.2.7 使用get()来访问值　　87<br>6.3 遍历字典　　88<br>6.3.1 遍历所有键值对　　88<br>6.3.2 遍历字典中的所有键　　90<br>6.3.3 按特定顺序遍历字典中的所有键　　92<br>6.3.4 遍历字典中的所有值　　92<br>6.4 嵌套　　94<br>6.4.1 字典列表　　94<br>6.4.2 在字典中存储列表　　97<br>6.4.3 在字典中存储字典　　98<br>6.5 小结　　100<br>第7章 用户输入和while循环　　101<br>7.1 函数input()的工作原理　　101<br>7.1.1 编写清晰的程序　　102<br>7.1.2 使用int()来获取数值输入　　102<br>7.1.3 求模运算符　　104<br>7.2 while循环简介　　105<br>7.2.1 使用while循环　　105<br>7.2.2 让用户选择何时退出　　105<br>7.2.3 使用标志　　107<br>7.2.4 使用break退出循环　　108<br>7.2.5 在循环中使用continue　　109<br>7.2.6 避免无限循环　　109<br>7.3 使用while循环处理列表和字典　　111<br>7.3.1 在列表之间移动元素　　111<br>7.3.2 删除为特定值的所有列表元素　　112<br>7.3.3 使用用户输入来填充字典　　112<br>7.4 小结　　114<br>第8章 函数　　115<br>8.1 定义函数　　115<br>8.1.1 向函数传递信息　　116<br>8.1.2 实参和形参　　116<br>8.2 传递实参　　117<br>8.2.1 位置实参　　117<br>8.2.2 关键字实参　　119<br>8.2.3 默认值　　119<br>8.2.4 等效的函数调用　　120<br>8.2.5 避免实参错误　　121<br>8.3 返回值　　122<br>8.3.1 返回简单值　　122<br>8.3.2 让实参变成可选的　　123<br>8.3.3 返回字典　　124<br>8.3.4 结合使用函数和while循环　　125<br>8.4 传递列表　　127<br>8.4.1 在函数中修改列表　　128<br>8.4.2 禁止函数修改列表　　130<br>8.5 传递任意数量的实参　　131<br>8.5.1 结合使用位置实参和任意数量实参　　132<br>8.5.2 使用任意数量的关键字实参　　134<br>8.6.1 导入整个模块　　134<br>8.6.2 导入特定的函数　　135<br>8.6.3 使用as给函数指定别名　　136<br>8.6.4 使用as给模块指定别名　　136<br>8.6.5 导入模块中的所有函数　　137<br>8.7 函数编写指南　　137<br>8.8 小结　　138<br>第9章 类　　140<br>9.1 创建和使用类　　140<br>9.1.1 创建Dog类　　141<br>9.1.2 根据类创建实例　　142<br>9.2 使用类和实例　　144<br>9.2.1 Car类　　145<br>9.2.2 给属性指定默认值　　145<br>9.2.3 修改属性的值　　146<br>9.3 继承　　149<br>9.3.1 子类的方法__init__()　　149<br>9.3.2 给子类定义属性和方法　　151<br>9.3.3 重写父类的方法　　152<br>9.3.4 将实例用作属性　　152<br>9.3.5 模拟实物　　154<br>9.4 导入类　　155<br>9.4.1 导入单个类　　155<br>9.4.2 在一个模块中存储多个类　　157<br>9.4.3 从一个模块中导入多个类　　158<br>9.4.4 导入整个模块　　158<br>9.4.5 导入模块中的所有类　　159<br>9.4.6 在一个模块中导入另一个模块　　159<br>9.4.7 使用别名　　160<br>9.4.8 自定义工作流程　　160<br>9.5 Python标准库　　161<br>9.6 类编码风格　　162<br>9.7 小结　　163<br>第10章 文件和异常　　164<br>10.1 从文件中读取数据　　164<br>10.1.1 读取整个文件　　164<br>10.1.2 文件路径　　166<br>10.1.3 逐行读取　　167<br>10.1.4 创建一个包含文件各行内容的列表　　168<br>10.1.5 使用文件的内容　　168<br>10.1.6 包含一百万位的大型文件　　170<br>10.2 写入文件　　171<br>10.2.1 写入空文件　　171<br>10.2.2 写入多行　　172<br>10.2.3 附加到文件　　173<br>10.3 异常　　174<br>10.3.1 处理ZeroDivisionError异常　　174<br>10.3.2 使用try-except 代码块　　174<br>10.3.3 使用异常避免崩溃　　175<br>10.3.4 else代码块　　176<br>10.3.5 处理FileNotFoundError异常　　177<br>10.3.6 分析文本　　178<br>10.3.7 使用多个文件　　179<br>10.3.8 静默失败　　180<br>10.3.9 决定报告哪些错误　　181<br>10.4 存储数据　　182<br>10.4.1 使用json.dump()和json.load()　　182<br>10.4.2 保存和读取用户生成的数据　　183<br>10.4.3 重构　　185<br>10.5 小结　　187<br>第11章 测试代码　　188<br>11.1 测试函数　　188<br>11.1.1 单元测试和测试用例　　189<br>11.1.2 可通过的测试　　189<br>11.1.3 未通过的测试　　191<br>11.1.4 测试未通过时怎么办　　192<br>11.1.5 添加新测试　　193<br>11.2 测试类　　194<br>11.2.1 各种断言方法　　194<br>11.2.2 一个要测试的类　　195<br>11.2.3 测试AnonymousSurvey类　　197<br>11.2.4 方法setUp()　　198<br>11.3 小结　　200<br>第二部分 项 目<br>项目1 外星人入侵　　202<br>第12章 武装飞船　　203<br>12.1 规划项目　　203<br>12.2 安装Pygame　　204<br>12.3 开始游戏项目　　204<br>12.3.1 创建Pygame窗口及响应用户输入　　204<br>12.3.2 设置背景色　　206<br>12.3.3 创建设置类　　207<br>12.4 添加飞船图像　　208<br>12.4.1 创建Ship类　　209<br>12.4.2 在屏幕上绘制飞船　　210<br>12.5 重构：方法_check_events()和__update_screen()　　211<br>12.5.1 方法_check_events()　　211<br>12.5.2 方法_update_screen()　　212<br>12.6 驾驶飞船　　213<br>12.6.1 响应按键　　213<br>12.6.2 允许持续移动　　214<br>12.6.3 左右移动　　215<br>12.6.4 调整飞船的速度　　216<br>12.6.5 限制飞船的活动范围　　218<br>12.6.6 重构_check_events()　　218<br>12.6.7 按Q键退出　　219<br>12.6.8 在全屏模式下运行游戏　　219<br>12.7 简单回顾　　220<br>12.7.1 alien_invasion.py　　220<br>12.7.2 settings.py　　220<br>12.7.3 ship.py　　220<br>12.8 射击　　221<br>12.8.1 添加子弹设置　　221<br>12.8.2 创建Bullet类　　221<br>12.8.3 将子弹存储到编组中　　223<br>12.8.4 开火　　223<br>12.8.5 删除消失的子弹　　225<br>12.8.6 限制子弹数量　　225<br>12.8.7 创建方法_update_bullets()　　227<br>第13章 外星人来了　　228<br>13.1 项目回顾　　228<br>13.2 创建第一个外星人　　229<br>13.2.1 创建Alien类　　229<br>13.2.2 创建Alien实例　　230<br>13.3 创建一群外星人　　232<br>13.3.1 确定一行可容纳多少个外星人　　232<br>13.3.2 创建一行外星人　　232<br>13.3.3 重构_create_fleet()　　234<br>13.3.4 添加行　　234<br>13.4 让外星人群移动　　237<br>13.4.1 向右移动外星人群　　237<br>13.4.2 创建表示外星人移动方向的设置　　238<br>13.4.3 检查外星人是否撞到了屏幕边缘　　238<br>13.4.4 向下移动外星人群并改变移动方向　　239<br>13.5 射杀外星人　　240<br>13.5.1 检测子弹与外星人的碰撞　　241<br>13.5.3 生成新的外星人群　　242<br>13.5.4 提高子弹的速度　　243<br>13.5.5 重构_update_bullets()　　243<br>13.6 结束游戏　　244<br>13.6.1 检测外星人和飞船碰撞　　244<br>13.6.2 响应外星人和飞船碰撞　　245<br>13.6.3 有外星人到达屏幕底端　　247<br>13.6.4 游戏结束　　248<br>13.7 确定应运行游戏的哪些部分　　248<br>13.8 小结　　249<br>第14章 记分　　250<br>14.1 添加Play按钮　　250<br>14.1.1 创建Button类　　250<br>14.1.2 在屏幕上绘制按钮　　252<br>14.1.3 开始游戏　　253<br>14.1.4 重置游戏　　254<br>14.1.5 将Play按钮切换到非活动状态　　254<br>14.1.6 隐藏鼠标光标　　255<br>14.2 提高等级　　256<br>14.2.1 修改速度设置　　256<br>14.2.2 重置速度　　258<br>14.3 记分　　258<br>14.3.1 显示得分　　259<br>14.3.2 创建记分牌　　260<br>14.3.3 在外星人被消灭时更新得分　　261<br>14.3.4 重置得分　　262<br>14.3.5 将消灭的每个外星人都计入得分　　262<br>14.3.6 提高分数　　263<br>14.3.7 舍入得分　　264<br>14.3.8 最高得分　　265<br>14.3.9 显示等级　　267<br>14.3.10 显示余下的飞船数　　269<br>14.4 小结　　272<br>项目2 数据可视化　　273<br>第15章 生成数据　　274<br>15.1 安装Matplotlib　　274<br>15.2 绘制简单的折线图　　275<br>15.2.1 修改标签文字和线条粗细　　277<br>15.2.3 使用内置样式　　278<br>15.2.4 使用scatter()绘制散点图并设置样式　　279<br>15.2.5 使用scatter()绘制一系列点　　280<br>15.2.6 自动计算数据　　281<br>15.2.7 自定义颜色　　282<br>15.2.8 使用颜色映射　　283<br>15.2.9 自动保存图表　　284<br>15.3 随机漫步　　284<br>15.3.1 创建RandomWalk类　　284<br>15.3.2 选择方向　　285<br>15.3.3 绘制随机漫步图　　286<br>15.3.4 模拟多次随机漫步　　287<br>15.3.5 设置随机漫步图的样式　　288<br>15.4 使用Plotly模拟掷骰子　　292<br>15.4.1 安装Plotly　　292<br>15.4.2 创建Die类　　293<br>15.4.3 掷骰子　　293<br>15.4.4 分析结果　　294<br>15.4.5 绘制直方图　　294<br>15.4.6 同时掷两个骰子　　296<br>15.4.7 同时掷两个面数不同的骰子　　298<br>15.5 小结　　300<br>第16章 下载数据　　301<br>16.1 CSV文件格式　　301<br>16.1.1 分析CSV文件头　　302<br>16.1.2 打印文件头及其位置　　302<br>16.1.3 提取并读取数据　　303<br>16.1.4 绘制温度图表　　304<br>16.1.5 模块datetime　　305<br>16.1.6 在图表中添加日期　　306<br>16.1.7 涵盖更长的时间　　307<br>16.1.8 再绘制一个数据系列　　308<br>16.1.9 给图表区域着色　　309<br>16.1.10 错误检查　　310<br>16.1.11 自己动手下载数据　　313<br>16.2 制作全球地震散点图：JSON格式　　315<br>16.2.2 查看JSON数据　　315<br>16.2.3 创建地震列表　　317<br>16.2.4 提取震级　　317<br>16.2.5 提取位置数据　　318<br>16.2.6 绘制震级散点图　　319<br>16.2.7 另一种指定图表数据的方式　　320<br>16.2.8 定制标记的尺寸　　321<br>16.2.9 定制标记的颜色　　322<br>16.2.10 其他渐变　　323<br>16.2.11 添加鼠标指向时显示的文本　　324<br>16.3 小结　　325<br>第17章 使用API　　326<br>17.1 使用Web API　　326<br>17.1.1 Git 和GitHub　　326<br>17.1.2 使用API调用请求数据　　327<br>17.1.3 安装Requests　　327<br>17.1.4 处理API响应　　328<br>17.1.5 处理响应字典　　329<br>17.1.6 概述最受欢迎的仓库　　331<br>17.1.7 监视API的速率限制　　332<br>17.2 使用Plotly可视化仓库　　332<br>17.2.1 改进Plotly图表　　334<br>17.2.2 添加自定义工具提示　　336<br>17.2.3 在图表中添加可单击的链接　　337<br>17.2.4 深入了解Plotly和GitHub API　　338<br>17.3 Hacker News API　　338<br>17.4 小结　　341<br>项目3 Web 应用程序　　342<br>第18章 从Django 入手　　343<br>18.1 建立项目　　343<br>18.1.1 制定规范　　343<br>18.1.2 建立虚拟环境　　344<br>18.1.3 激活虚拟环境　　344<br>18.1.4 安装Django　　345<br>18.1.5 在Django中创建项目　　345<br>18.1.6 创建数据库　　346<br>18.1.7 查看项目　　346<br>18.2 创建应用程序　　348<br>18.2.1 定义模型　　348<br>18.2.2 激活模型　　349<br>18.2.3 Django管理网站　　351<br>18.2.4 定义模型Entry　　353<br>18.2.5 迁移模型Entry　　354<br>18.2.6 向管理网站注册Entry　　354<br>18.2.7 Django shell　　355<br>18.3 创建页面：学习笔记主页　　357<br>18.3.1 映射URL　　358<br>18.3.2 编写视图　　359<br>18.3.3 编写模板　　360<br>18.4 创建其他页面　　361<br>18.4.1 模板继承　　361<br>18.4.2 显示所有主题的页面　　363<br>18.4.3 显示特定主题的页面　　366<br>18.5 小结　　369<br>第19章 用户账户　　370<br>19.1 让用户输入数据　　370<br>19.1.1 添加新主题　　370<br>19.1.2 添加新条目　　374<br>19.1.3 编辑条目　　378<br>19.2 创建用户账户　　381<br>19.2.1 应用程序users　　381<br>19.2.2 将users添加到settings.py 中　　381<br>19.2.3 包含users的URL　　382<br>19.2.4 登录页面　　382<br>19.2.5 注销　　384<br>19.2.6 注册页面　　386<br>19.3 让用户拥有自己的数据　　388<br>19.3.1 使用@login_required限制访问　　388<br>19.3.2 将数据关联到用户　　390<br>19.3.3 只允许用户访问自己的主题　　393<br>19.3.4 保护用户的主题　　393<br>19.3.5 保护页面edit_entry　　394<br>19.3.6 将新主题关联到当前用户　　396<br>第20章 设置应用程序的样式并部署　　397<br>20.1.1 应用程序django-bootstrap4　　398<br>20.1.3 修改base.html　　399<br>20.1.4 使用jumbotron设置主页的样式　　403<br>20.1.5 设置登录页面的样式　　404<br>20.1.6 设置显示所有主题的页面的样式　　405<br>20.1.7 设置显示单个主题的页面中的条目样式　　406<br>20.2 部署“学习笔记”　　407<br>20.2.1 建立Heroku账户　　408<br>20.2.2 安装Heroku CLI　　408<br>20.2.3 安装必要的包　　408<br>20.2.4 创建文件requirements.txt　　409<br>20.2.6 为部署到Heroku而修改settings.py　　410<br>20.2.7 创建启动进程的Procfile　　410<br>20.2.8 使用Git 跟踪项目文件　　410<br>20.2.9 推送到Heroku　　412<br>20.2.10 在Heroku上建立数据库　　414<br>20.2.12 确保项目的安全　　416<br>20.2.13 提交并推送修改　　416<br>20.2.14 在Heroku 上设置环境变量　　417<br>20.2.15 创建自定义错误页面　　418<br>20.2.16 继续开发　　420<br>20.2.17 设置SECRET_KEY　　421<br>20.2.18 将项目从Heroku删除　　421<br>20.3 小结　　422<br>附录A 安装与故障排除　　423<br>附录B 文本编辑器与IDE　　428<br>附录C 寻求帮助　　432<br>附录D 使用Git 进行版本控制　　436<br>后记　　445</p><h3 id="Python编程：从入门到实践-PDF-下载地址"><a href="#Python编程：从入门到实践-PDF-下载地址" class="headerlink" title="Python编程：从入门到实践 PDF 下载地址:"></a>Python编程：从入门到实践 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Y3kieRXl42PGLymLpxszAw?pwd=k4fy">https://pan.baidu.com/s/1Y3kieRXl42PGLymLpxszAw?pwd=k4fy</a> </p><p>提取码：k4fy</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python高性能编程》</title>
      <link href="/2023/05/19/Python%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/19/Python%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/EHSJKJIKVBS3BNBQJNOVZB066ZN13RBX.png" alt="《Python高性能编程》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书共有12章，围绕如何进行代码优化和加快实际应用的运行速度进行详细讲解。本书主要包含以下主题：计算机内部结构的背景知识、列表和元组、字典和集合、迭代器和生成器、矩阵和矢量计算、并发、集群和工作队列等。最后，通过一系列真实案例展现了在应用场景中需要注意的问题。</p><p>本书适合初级和中级Python程序员、有一定Python语言基础想要得到进阶和提高的读者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Micha Gorelick在bitly公司从事与数据打交道的工作，并负责建立</p><p>了快速前进实验室（Fast Forward Labs），研究从机器学习到高性</p><p>能流算法领域的问题。</p><p>Ian Ozsvald是ModelInsight.io的数据科学家和教师，有着超过十</p><p>年的Python经验。他在PyCon和PyData会议上教授Python编程，</p><p>这几年一直在英国从事关于数据科学和高性能计算方面的咨询工</p><p>作。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 理解高性能Python 1<br>1.1 基本的计算机系统 1<br>1.1.1 计算单元 2<br>1.1.2 存储单元 5<br>1.1.3 通信层 6<br>1.2 将基本的元素组装到一起 8<br>1.3 为什么使用Python 12<br>第2章 通过性能分析找到瓶颈 15<br>2.1 高效地分析性能 16<br>2.2 Julia集合的介绍 17<br>2.3 计算完整的Julia集合 20<br>2.4 计时的简单方法——打印和修饰 24<br>2.5 用UNIX的time命令进行简单的计时 27<br>2.6 使用cProfile模块 28<br>2.7 用runsnakerun对cProfile的输出进行可视化 33<br>2.8 用line_profiler进行逐行分析 34<br>2.9 用memory_profiler诊断内存的用量 39<br>2.10 用heapy调查堆上的对象 45<br>2.11 用dowser实时画出变量的实例 47<br>2.12 用dis模块检查CPython字节码 49<br>2.13 在优化期间进行单元测试保持代码的正确性 53<br>2.14 确保性能分析成功的策略 56<br>2.15 小结 57<br>第3章 列表和元组 58<br>3.1 一个更有效的搜索 61<br>3.2 列表和元组 63<br>3.2.1 动态数组：列表 64<br>3.2.2 静态数组：元组 67<br>3.3 小结 68<br>第4章 字典和集合 69<br>4.1 字典和集合如何工作 72<br>4.1.1 插入和获取 73<br>4.1.2 删除 76<br>4.1.3 改变大小 76<br>4.1.4 散列函数和熵 76<br>4.2 字典和命名空间 80<br>4.3 小结 83<br>第5章 迭代器和生成器 84<br>5.1 无穷数列的迭代器 87<br>5.2 生成器的延迟估值 89<br>5.3 小结 93<br>第6章 矩阵和矢量计算 94<br>6.1 问题介绍 95<br>6.2 Python列表还不够吗 99<br>6.3 内存碎片 103<br>6.3.1 理解perf 105<br>6.3.2 根据perf输出做出抉择 106<br>6.3.3 使用numpy 107<br>6.4 用numpy解决扩散问题 110<br>6.4.1 内存分配和就地操作 113<br>6.4.2 选择优化点：找到需要被修正的地方 116<br>6.5 numexpr：让就地操作更快更简单 120<br>6.6 告诫故事：验证你的“优化”（scipy） 121<br>6.7 小结 123<br>第7章 编译成C 126<br>7.1 可能获得哪种类型的速度提升 127<br>7.2 JIT和AOT编译器的对比 129<br>7.3 为什么类型检查有助代码更快运行 129<br>7.4 使用C编译器 130<br>7.5 复习Julia集的例子 131<br>7.6 Cython 131<br>7.6.1 使用Cython编译纯Python版本 132<br>7.6.2 Cython注解来分析代码块 134<br>7.6.3 增加一些类型注解 136<br>7.7 Shed Skin 140<br>7.7.1 构建扩展模块 141<br>7.7.2 内存拷贝的开销 144<br>7.8 Cython和numpy 144<br>7.9 Numba 148<br>7.10 Pythran 149<br>7.11 PyPy 151<br>7.11.1 垃圾收集的差异 152<br>7.11.2 运行PyPy并安装模块 152<br>7.12 什么时候使用每种工具 154<br>7.12.1 其他即将出现的项目 155<br>7.12.2 一个图像处理单元（GPU）的注意点 156<br>7.12.3 一个对未来编译器项目的展望 157<br>7.13 外部函数接口 157<br>7.13.1 ctypes 158<br>7.13.2 cffi 160<br>7.13.3 f2py 163<br>7.13.4 CPython模块 166<br>7.14 小结 170<br>第8章 并发 171<br>8.1 异步编程介绍 172<br>8.2 串行爬虫 175<br>8.3 gevent 177<br>8.4 tornado 182<br>8.5 AsyncIO 185<br>8.6 数据库的例子 188<br>8.7 小结 191<br>第9章 multiprocessing模块 193<br>9.1 multiprocessing模块综述 196<br>9.2 使用蒙特卡罗方法来估算Pi 198<br>9.3 使用多进程和多线程来估算Pi 199<br>9.3.1 使用Python对象 200<br>9.3.2 并行系统中的随机数 207<br>9.3.3 使用numpy 207<br>9.4 寻找素数 210<br>9.5 使用进程间通信来验证素数 221<br>9.5.1 串行解决方案 225<br>9.5.2 Naïve Pool解决方案 225<br>9.5.3 Less Naïve Pool解决方案 226<br>9.5.4 使用Manager.Value作为一个标记 227<br>9.5.5 使用Redis作为一个标记 229<br>9.5.6 使用RawValue作为一个标记 232<br>9.5.7 使用mmap作为一个标记 232<br>9.5.8 使用mmap作为一个标记的终极效果 234<br>9.6 用multiprocessing来共享numpy数据 236<br>9.7 同步文件和变量访问 243<br>9.7.1 文件锁 243<br>9.7.2 给Value加锁 247<br>9.8 小结 249<br>第10章 集群和工作队列 251<br>10.1 集群的益处 252<br>10.2 集群的缺陷 253<br>10.2.1 糟糕的集群升级策略造成华尔街损失4.62亿美元 254<br>10.2.2 Skype的24小时全球中断 255<br>10.3 通用的集群设计 255<br>10.4 怎样启动一个集群化的解决方案 256<br>10.5 使用集群时避免痛苦的方法 257<br>10.6 三个集群化解决方案 258<br>10.6.1 为简单的本地集群使用Parallel Python模块 259<br>10.6.2 使用IPython Parallel来支持研究 260<br>10.7 为鲁棒生产集群的NSQ 265<br>10.7.1 队列 265<br>10.7.2 发布者&#x2F;订阅者 266<br>10.7.3 分布式素数计算器 268<br>10.8 看一下其他的集群化工具 271<br>10.9 小结 272<br>第11章 使用更少的RAM 273<br>11.1 基础类型的对象开销高 274<br>11.2 理解集合中的RAM使用 278<br>11.3 字节和Unicode的对比 280<br>11.4 高效地在RAM中存储许多文本 281<br>11.5 使用更少RAM的窍门 290<br>11.6 概率数据结构 291<br>11.6.1 使用1字节的Morris计数器来做近似计数 292<br>11.6.2 K最小值 295<br>11.6.3 布隆过滤器 298<br>11.6.4 LogLog计数器 303<br>11.6.5 真实世界的例子 307<br>第12章 现场教训 311<br>12.1 自适应实验室（Adaptive Lab）的社交媒体分析（SoMA） 311<br>12.1.1 自适应实验室（Adaptive Lab）使用的Python 312<br>12.1.2 SoMA的设计 312<br>12.1.3 我们的开发方法论 313<br>12.1.4 维护SoMA 313<br>12.1.5 对工程师同行的建议 313<br>12.2 使用RadimRehurek.com让深度学习飞翔 314<br>12.2.1 最佳时机 314<br>12.2.2 优化方面的教训 316<br>12.2.3 总结 318<br>12.3 在Lyst.com的大规模产品化的机器学习 318<br>12.3.1 Python在Lyst的地位 319<br>12.3.2 集群设计 319<br>12.3.3 在快速前进的初创公司中做代码评估 319<br>12.3.4 构建推荐引擎 319<br>12.3.5 报告和监控 320<br>12.3.6 一些建议 320<br>12.4 在Smesh的大规模社交媒体分析 321<br>12.4.1 Python在Smesh中的角色 321<br>12.4.2 平台 321<br>12.4.3 高性能的实时字符串匹配 322<br>12.4.4 报告、监控、调试和部署 323<br>12.5 PyPy促成了成功的Web和数据处理系统 324<br>12.5.1 先决条件 325<br>12.5.2 数据库 325<br>12.5.3 Web应用 326<br>12.5.4 OCR和翻译 326<br>12.5.5 任务分发和工作者 327<br>12.5.6 结论 327<br>12.6 在Lanyrd.com中的任务队列 327<br>12.6.1 Python在Lanyrd中的角色 328<br>12.6.2 使任务队列变高性能 328<br>12.6.3 报告、监控、调试和部署 328<br>12.6.4 对开发者同行的建议 329</p><h3 id="Python高性能编程-PDF-下载地址"><a href="#Python高性能编程-PDF-下载地址" class="headerlink" title="Python高性能编程 PDF 下载地址:"></a>Python高性能编程 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1KEKmLyxrB3v1utpKL8l2BQ?pwd=tjsm">https://pan.baidu.com/s/1KEKmLyxrB3v1utpKL8l2BQ?pwd=tjsm</a> </p><p>提取码: tjsm </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站所有文档密码</title>
      <link href="//mima/"/>
      <url>//mima/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">  <script id="hbeData" type="hbeData" data-hmacdigest="8db921aceeece298fa0ee0c99b8d3229beacb72c92e02fe4c1e252f461de7186">7c351404e46fa1c7280678d51bf9554c54ebb642ef2fdc7f9d2e4e83b89517e84c2b4fa42deb4a15a5e466b16087a1cb77ef0bc6c5672c6fa7950d637c05b9f18ee4bb8c88dc6442955d25749c1de471a0aacf3a752a169658acd879372ae5a669d756844de2c7c154cc10a9038bf4f72217f859aeab3eaffbd4379fa0d1b1fd324da80ab45781acb4f43cd8f467c2aa223ab9b684cc7ea3313a51551eb5b97debd6d71e067781a937932c4ac84c69a4e307af4c80ba5a1a768ed2e3be20e59d3c684778afe7a20d5f0eafae7338aa9b16557b54c07be3cea4f2ee8d5690a128e9e5aedf5c4fe18f249e2500953adf8bb6777996ea50c338fb04d4e2661aa8f7798536c6cc5bedc6b8ea654bc1ff6aead4d0775a8dfb00c39d1a39668187b3c13d6259d800878d07d3a3e81547653401df1c05b1b0c84fb84c6f7d5ee5778b0ee4895602215ca19f8e46f1142bb607d0ab5c2fc1e6861d086da9eca8f72011d65bbae25bd7d57ac243548014f56aabea40c4133db7893eb69dc67faffe84ca0669108db026bdb7766221fb8c4d1a477d4ba99fa188741adb17f05896200f41f31a049104e53c40d1cdcbe80b04ec70b802413a48b31d317ecaf6cd7b9a2a8b894ef70619db14193b21aa9e4f12b8a09195fa8327e64261539f58030f3983d068c98c43fb9fb1f3a489a9c937fa40a0b706f7a861a2aa9e29cfc5a5ca9434a25da38a7e6455bd0be779aa0637930737bf3bd62a5d67d4c81ee2750c8d00426cce0dc134ad106059ae742b8da21864298d4369dbd6e15c7eba1ccd398b264a653206f591d9987da0ad189727fd5b6c3636d3577c424bf58ed3a317148fa95e5e9aca0309c1a12d6b2eb42066d7494b3c54a55d2514939eb08773d890152c8d7a79076c9f566d2fbe2413eecd912bd26e92b4ba6ccbd988757fea94f2db39202d91607c4079e5cccead49d816606bf109d696790e9854abaf34fcb2d24bdbc921c30dbb0604615b63e4392cebbbd271be5e3fff1654ec45ca81e4f390762882245fbe09adb42362474bb6d336ad0ade506b429dd52409dba3999059b24b05c77290ce41568ca886eccb6c7f604d5261d005f2fea5a00c33dcfe002becdf9bda7adf88be3a8350e23a304ba1165d0ea9fa1bf9008a317cb879794a0f61764fcda6a68fe2218ebda838a6242c2fc91409a93f1d0925c8258e752026682ab2c9efcf376ef38c60699c1417e4150ebcc540285661f43f10520c23128aa3de1b9aabfae3bd2a399539567909ac11b09adab08ae744cd9ef2831e3b39a9cb6355b1b9981500f0433b29489740b775c3859f64d1472a0fefebee360eb20657321c77911976a6990d42e3c2f68114121ac8fbf39be5175ebeeb001a8ed72a9fcd1d901d213ce56e05fefc7f846516092b115f7fb4ca471896a7553ca2fd86923ff7381703e5af202d68117a603a830642b3d228d8d769e6dcf2bb96450d83e993da403ea330b26faf1df65e5e140d0d5fc6973491cd91d0b2da53c631ae501c3a19b5a94a1723204d1755e3616b4d8e3e4a87722e87cd73880d48d14cd515ddaa54bf797de4cef3b39458600c08cb1f297c146f986740cb6c937d81391ef600cb84e57382c78c563acd2d1703d74341f65d1e2f34f86abf93b566acfdd09a1f45611289d4ef66373882e75780ac555f6d1b18bc978f29c7005b7e14671a67abd408b9149eac26befbdc182fa1626ae7349ae6ee3858d3371e21cc5d3c75614b3245bed02bab7c19de59f5c93987471d9628c509516aa3e15bbd3fb7de6c8d9dbc0bebf70d92b69205e2721bbd0d520177c3245fc62a5eeee2e04f9ad967149bf0888d4104c8428b5a33357cbf6ade56afe98e6ff4451d9d4a18ee4ba40a90b887f1bf00b3b12b6f124e908a7ab2a751665570d88a8f8bbb8c94159643b896e23ffa24542b4ffa576387f30e791b58dc61aa5711c74d37a667bcf8dcc3a36cfbb08b3135aea050fcc854d2eaab35941f85164d8c3fd9461130ea4639ddc88b5e41144d319447fc32b1775ef4a73bf1614e4c73233ad4575849ccad5f03f58d5a3ddcefd516695517f03e898737ac02abb21236f78688450f30ddd0339ee8f65e7c63df1ebefbf53904c9b624e185e22242f7941fb71028d62e44dab5068af8af4ae14c8ba2226eb084e4c1eb550e3547dd666824f2884c7a725d72f2e8dde649d24bbc382eccfae035c953936eba6650c79ced5e70afb93b1e10b1ddd64017ef419046bd05785caf1c84c2232c325c21dbcba87defd4ea6cc58683b8a030bddf935bcb8e4d0c22b43cf0b4f42d6a1e4c6f3372e1185a05e3f82bff3ca98538aa42203ee0abf8b977f547cc4fec7bbd86aaa4cbafe15e4ec33bb2482f015717a0ec7f4b9f376a36a83ff2925e492598a705e74ed6a0678e73b5141dfd51811e56a877d59f934daf9b842f947d64f39510fed315af39446a0fc4ce0e3ed78036b8d0b44543867992bf1782727659cfaaf83890f15a84eaa63c184bd1dc89ff5c0a27b7e86c8a1ed806d6f188a117b9f46d9ace1ef33efce69fe85bba37f7dae34ed230757b66944c24c5e8e24d35a5893845aa1cba0d8df2dd803197535e3379f57ba70eb6b1c388d47d0d6cc0ffda70e7278845724db5134f70005fa40e541bbe8bbc6324d5aa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 此文章需要要密码才可以查看.">您好, 此文章需要要密码才可以查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> PDF密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《pytest测试实战》</title>
      <link href="/2023/05/19/pytest%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/19/pytest%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/6E7FFAC4BE6AA9069DB81181D116D110.png" alt="《pytest测试实战》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>pytest是动态编程语言Python专用的测试框架，它具有易于上手、功能强大、第三方插件丰富、效率高、可扩展性好、兼容性强等特点。《pytest测试实战》深入浅出地讲解了pytest的使用方法，尤其是具有特色的fixture的用法。作者通过丰富的测试实例，手把手教读者编写简洁、易于维护的测试代码和插件，让你轻松掌握这个业界最受欢迎的Python测试工具。</p><p>第1章介绍pytest的安装，同时会介绍Tasks项目的数据结构部分（名为Task的namedtuple），并用它作为测试示例。我们会学习如何指定测试文件运行，以及pytest常用的命令行命令，包括重新运行失败测试、遇到失败即停止所有测试、控制堆栈跟踪、控制日志输出，等等。</p><p>第2章将使用pip在本地安装Tasks项目，学习在Python项目中如何组织测试目录，这样才能针对实际项目编写测试用例。这一章的所有示例都依赖外部程序，包括数据库写入。</p><p>第2章的重点是测试函数，你将学习在pytest中高效使用断言语句。这一章还会讲解marker标记功能的用法，marker标记可以将测试进行归类或分组，方便一起运行，也可以将某些测试标记为skip（跳过不执行），marker标记还可以告诉pytest我们知道某些测试是一定会失败的。如果希望运行指定的测试子集，除了使用marker，还可以将测试代码组织成测试目录、测试模块、测试类，然后运行。</p><p>并非所有的测试代码都要放到测试函数中。第3章介绍如何将测试数据、启动逻辑、销毁逻辑放入fixture（pytest定义的一种测试脚手架）。设置系统（或子系统、系统单元）是软件测试的重要环节，第3章将介绍用一个简单的fixture完成这方面的工作（包括对数据库进行初始化，写入数据以备测试之用）。Fixture模块的功能非常强大，你可以利用它简化测试代码，从而提高代码的可读性和可维护性。Fixture像测试函数一样，也有参数。利用参数，你只需要编写一份代码，就可以针对TinyDB和MongoDB（或其他Tasks项目支持的数据库）开展测试。</p><p>第4章介绍pytest内置的fixture以满足测试中常见的一些需求，包括生成和销毁临时目录、截取输出流（通过日志判定结果）、使用monkey patch、检查是否发出警告，等等。</p><p>第5章讲解如何在pytest中添加命令行选项，如何改进打印输出，如何打包分发自己编写的插件，如何共享定制化的pytest（包括fixture）。这一章开发的插件可以改善Tasks项目测试失败时的输出呈现方式。你还将学习测试自己的测试插件（元测试）。读完这一章，想必你已经等不及编写自己的插件了。附录C收集了一些热门的社区插件，可供参考。</p><p>第6章讲解通过pytest.ini文件修改默认配置，自定义pytest的运行方式。pytest.ini文件可以存放某些命令选项，从而减少你重复输入命令的次数；利用它还可以指定pytest忽略某些测试目录，或者指定pytest的最低版本，等等。使用tox.ini和setup.cfg文件也可以实现同样的功能。</p><p>第7章（最后一章）介绍pytest与其他工具的结合使用。我们将借助tox让Tasks项目在多个Python版本上运行；学习如何测试Tasks项目的CLI部分，而不必mock系统的其余部分；借助coverage.py检查Tasks项目代码块的测试覆盖情况；通过Jenkins发起测试并实时显示结果。最后，还会学习如何让pytest运行基于unittest的测试用例，以及把pytest的fixture共享给unittest的测试用例使用。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Brian Okken是一位有二十多年工作经验的软件测试工程师，他业余时间录制了Test &amp; Code和Python Bytes两个播客。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>第1章 pytest入门 1<br>1.1 资源获取 4<br>1.2 运行Pytest 5<br>1.3 运行单个测试用例 10<br>1.4 使用命令行选项 10<br>–collect-only选项 11<br>-k选项 11<br>-m选项 12<br>-x选项 13<br>–maxfail&#x3D;num 15<br>-s与–capture&#x3D;method 16<br>–lf（–last-failed）选项 16<br>–ff（–failed-first）选项 17<br>-v（–verbose）选项 17<br>-q（–quiet）选项 18<br>-l（–showlocals）选项 19<br>–tb&#x3D;style选项 20<br>–duration&#x3D;N选项 21<br>–version选项 22<br>-h（–help）选项 23<br>1.5 练习 24<br>1.6 预告 25<br>第2章 编写测试函数 27<br>2.1 测试示例程序 27<br>本地安装Tasks项目程序包 30<br>2.2 使用assert声明 32<br>2.3 预期异常 35<br>2.4 测试函数的标记 36<br>完善冒烟测试 38<br>2.5 跳过测试 40<br>2.6 标记预期会失败的测试 43<br>2.7 运行测试子集 45<br>单个目录 45<br>单个测试文件&#x2F;模块 46<br>单个测试函数 47<br>单个测试类 47<br>单个测试类中的测试方法 48<br>用测试名划分测试集合 48<br>2.8 参数化测试 49<br>2.9 练习 56<br>2.10 预告 57<br>第3章 pytest Fixture 59<br>3.1 通过conftest.py共享fixture 60<br>3.2 使用fixture执行配置及销毁逻辑 61<br>3.3 使用–setup-show回溯fixture的执行过程 63<br>3.4 使用fixture传递测试数据 64<br>3.5 使用多个fixture 66<br>3.6 指定fixture作用范围 68<br>修改Tasks项目的fixture作用范围 70<br>3.7 使用usefixtures指定fixture 73<br>3.8 为常用fixture添加autouse选项 74<br>3.9 为fixture重命名 75<br>3.10 Fixture的参数化 77<br>3.11 参数化Tasks项目中的fixture 80<br>3.12 练习 83<br>3.13 预告 83<br>第4章 内置Fixture 85<br>4.1 使用tmpdir和tmpdir_factory 86<br>在其他作用范围内使用临时目录 88<br>4.2 使用pytestconfig 90<br>4.3 使用cache 92<br>4.4 使用capsys 100<br>4.5 使用monkeypatch 102<br>4.6 使用doctest_namespace 106<br>4.7 使用recwarn 109<br>4.8 练习 110<br>4.9 预告 111<br>第5章 插件 113<br>5.1 寻找插件 114<br>5.2 安装插件 114<br>从PyPI安装 114<br>从PyPI安装指定版本 115<br>从.tar.gz或.whl文件安装 115<br>从本地目录安装 115<br>从Git存储仓库安装 116<br>5.3 编写自己的插件 116<br>5.4 创建可安装插件 121<br>5.5 测试插件 125<br>5.6 创建发布包 129<br>通过共享目录分发插件 130<br>通过PyPI发布插件 130<br>5.7 练习 131<br>5.8 预告 131<br>第6章 配置 133<br>6.1 理解pytest的配置文件 133<br>用pytest –help查看ini文件选项 135<br>插件可以添加ini文件选项 135<br>6.2 更改默认命令行选项 136<br>6.3 注册标记来防范拼写错误 136<br>6.4 指定pytest的最低版本号 138<br>6.5 指定pytest忽略某些目录 138<br>6.6 指定测试目录 139<br>6.7 更改测试搜索的规则 141<br>6.8 禁用XPASS 142<br>6.9 避免文件名冲突 143<br>6.10 练习 145<br>6.11 预告 145<br>第7章 pytest与其他工具的搭配使用 147<br>7.1 pdb：调试失败的测试用例 147<br>7.2 coverage.py：判断测试覆盖了多少代码 151<br>7.3 mock：替换部分系统 155<br>7.4 tox：测试多种配置 162<br>7.5 Jenkins CI：让测试自动化 166<br>7.6 unittest：用pytest运行历史遗留测试用例 173<br>7.7 练习 179<br>7.8 预告 180<br>附录A 虚拟环境 181<br>附录B Pip 183<br>附录C 常用插件 187<br>C.1 改变测试流程的插件 187<br>pytest-repeat：重复运行测试 187<br>pytest-xdist：并行运行测试 189<br>pytest-timeout：为测试设置时间限制 190<br>C.2 改善输出效果的插件 191<br>pytest-instafail：查看错误的详细信息 191<br>pytest-sugar：显示色彩和进度条 192<br>pytest-emoji：为测试增添一些乐趣 193<br>pytest-html：为测试生成HTML报告 195<br>C.3 静态分析用的插件 197<br>pytest-pycodestyle和pytest-pep8：Python代码风格检查 197<br>pytest-flake8：更多的风格检查 197<br>C.4 Web开发用的插件 198<br>pytest-selenium：借助浏览器完成自动化测试 198<br>pytest-django：测试Django应用 198<br>pytest-flask：测试Flask应用 199<br>附录D 打包和发布Python项目 201<br>D.1 创建可安装的模块 201<br>D.2 创建可安装的包 203<br>D.3 创建源码发布包和Wheel文件 205<br>D.4 创建可以从PyPI安装的包 209<br>附录E xUnit Fixture 211<br>E.1 xUnit Fixture的语法 211<br>E.2 混合使用pytest Fixture和xUnit Fixture 214<br>E.3 xUnit Fixture的限制 215<br>索引 216</p><h3 id="pytest测试实战-PDF-下载"><a href="#pytest测试实战-PDF-下载" class="headerlink" title="pytest测试实战 PDF 下载"></a>pytest测试实战 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Mg_nwvwOtwIiWakKA2BPJA?pwd=ylqm">https://pan.baidu.com/s/1Mg_nwvwOtwIiWakKA2BPJA?pwd=ylqm</a> </p><p>提取码：ylqm</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> PyTest </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
